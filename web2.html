<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title></title><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none 0s ease 0s; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }


html { font-size: 19px; }
html, body { margin: auto; background: rgb(254, 254, 254); }
body { font-family: Vollkorn, Palatino, Times; color: rgb(51, 51, 51); line-height: 1.4; text-align: justify; }
#write { max-width: 960px; margin: 0px auto 2em; line-height: 1.53; padding-top: 40px; }
#write > h1:first-child, h1 { margin-top: 1.6em; font-weight: normal; }
h1 { font-size: 3em; }
h2 { margin-top: 2em; font-weight: normal; }
h3 { font-weight: normal; font-style: italic; margin-top: 3em; }
h1, h2, h3 { text-align: center; }
h2::after { border-bottom: 1px solid rgb(47, 47, 47); content: ""; width: 100px; display: block; margin: 0px auto; height: 1px; }
h1 + h2, h2 + h3 { margin-top: 0.83em; }
p, .mathjax-block { margin-top: 0px; }
ul { list-style: square; padding-left: 1.2em; }
ol { padding-left: 1.2em; }
blockquote { margin-left: 1em; padding-left: 1em; border-left: 1px solid rgb(221, 221, 221); }
code, pre { font-family: Consolas, Menlo, Monaco, monospace, serif; font-size: 0.9em; background: white; }
.md-fences { margin-left: 1em; padding-left: 1em; border: 1px solid rgb(221, 221, 221); padding-bottom: 8px; padding-top: 6px; margin-bottom: 1.5em; }
a { color: rgb(36, 132, 193); text-decoration: none; }
a:hover { text-decoration: underline; }
a img { border: none; }
h1 a, h1 a:hover { color: rgb(51, 51, 51); text-decoration: none; }
hr { color: rgb(221, 221, 221); height: 1px; margin: 2em 0px; border-top: 1px solid rgb(221, 221, 221); border-bottom: none; border-left: 0px; border-right: 0px; }
.ty-table-edit { background: rgb(237, 237, 237); padding-top: 4px; }
table { margin-bottom: 1.33333rem; }
table th, table td { padding: 8px; line-height: 1.33333rem; vertical-align: top; border-top: 1px solid rgb(221, 221, 221); }
table th { font-weight: bold; }
table thead th { vertical-align: bottom; }
table caption + thead tr:first-child th, table caption + thead tr:first-child td, table colgroup + thead tr:first-child th, table colgroup + thead tr:first-child td, table thead:first-child tr:first-child th, table thead:first-child tr:first-child td { border-top: 0px; }
table tbody + tbody { border-top: 2px solid rgb(221, 221, 221); }
.task-list { padding: 0px; }
.md-task-list-item { padding-left: 1.6rem; }
.md-task-list-item > input::before { content: "√"; display: inline-block; width: 1.33333rem; height: 1.6rem; vertical-align: middle; text-align: center; color: rgb(221, 221, 221); background-color: rgb(254, 254, 254); }
.md-task-list-item > input:checked::before, .md-task-list-item > input[checked]::before { color: inherit; }
.md-tag { color: inherit; font: inherit; }
#write pre.md-meta-block { min-height: 35px; padding: 0.5em 1em; }
#write pre.md-meta-block { white-space: pre; background: rgb(248, 248, 248); border-width: 0px 30px; border-top-style: initial; border-bottom-style: initial; border-top-color: initial; border-bottom-color: initial; border-image: initial; color: rgb(153, 153, 153); width: 100vw; max-width: calc(100% + 60px); margin-left: -30px; border-left-style: solid; border-left-color: rgb(248, 248, 248); border-right-style: solid; border-right-color: rgb(248, 248, 248); margin-bottom: 2em; margin-top: -1.33333rem; padding-top: 26px; padding-bottom: 10px; line-height: 1.8em; font-size: 0.76em; padding-left: 0px; }
.md-img-error.md-image > .md-meta { vertical-align: bottom; }
#write > h5.md-focus::before { top: 2px; }
.md-toc { margin-top: 40px; }
.md-toc-content { padding-bottom: 20px; }
.outline-expander::before { color: inherit; font-size: 14px; top: auto; content: ""; font-family: FontAwesome; }
.outline-expander:hover::before, .outline-item-open > .outline-item > .outline-expander::before { content: ""; }
#typora-source { font-family: Courier, monospace; color: rgb(106, 106, 106); }
.html-for-mac #typora-sidebar { box-shadow: rgba(0, 0, 0, 0.176) 0px 6px 12px; }
.cm-s-typora-default .cm-header, .cm-s-typora-default .cm-property, .CodeMirror.cm-s-typora-default div.CodeMirror-cursor { color: rgb(66, 139, 202); }
.cm-s-typora-default .cm-atom, .cm-s-typora-default .cm-number { color: rgb(119, 119, 119); }
.typora-node .file-list-item-parent-loc, .typora-node .file-list-item-time, .typora-node .file-list-item-summary { font-family: arial, sans-serif; }
.md-task-list-item > input { margin-left: -1.3em; margin-top: calc(1rem - 12px); }
.md-mathjax-midline { background: rgb(250, 250, 250); }
.md-fences .code-tooltip { bottom: -2em !important; }
.dropdown-menu .divider { border-color: rgb(229, 229, 229); }

 .typora-export li, .typora-export p, .typora-export,  .footnote-line {white-space: normal;} 
</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node'><p><span>Web服务组合作为AI规划–调查[ </span><a href='#'><span>1 </span><span>]</span></a></p><p><span>约阿希姆·佩尔（Joachim Peer）</span></p><p><span>2005年3月22日</span></p><p><strong><span>抽象</span></strong></p><p><span>本文概述了AI（人工智能）计划技术，并讨论了它们在Web服务组合问题中的应用。</span></p><p><strong><span>内容</span></strong></p><p><strong><span>1简介和动机.............................................. .................................... 3</span></strong></p><p><strong><span>2种情况................................................ ................................................... ............ 5</span></strong></p><p><strong><span>3初稿................................................ ................................................... ..... 6</span></strong></p><p><a href='#'><span>3.1规范规划领域.................................... ........................ 6</span></a></p><p><a href='#'><span>3.2正式化初始世界.................................... ...................... 9</span></a></p><p><a href='#'><span>3.3正式制定目标.............................................. ................................................... 11</span></a></p><p><a href='#'><span>3.4代表计划............................................... .................................................... 13</span></a></p><p><strong><span>4基本规划范式.............................................. ................................ 14</span></strong></p><p><a href='#'><span>4.1基于状态空间的规划........................................... ................................. 14</span></a></p><p><a href='#'><span>4.2基于图的计划..................................... ............................................................... 18</span></a></p><p><a href='#'><span>4.3部分订单优化计划................................. ................... 22</span></a></p><p><a href='#'><span>4.4规划为可满足性.................................... ................................... 26</span></a></p><p><a href='#'><span>4.4.1作为命题可满足性进行规划........................................... ........... 27</span></a></p><p><a href='#'><span>4.4.2规划描述逻辑可满足性.......................................... ..... 28</span></a></p><p><a href='#'><span>4.4.3作为Petri网可达性进行规划..................................................... ..................... 29</span></a></p><p><a href='#'><span>4.5作为逻辑编程进行规划.................................... ........................ 30</span></a></p><p><strong><span>5具有控制知识的计划.................................... ................... 31</span></strong></p><p><a href='#'><span>5.1分层任务网络规划.................................... ................................ 31</span></a></p><p><a href='#'><span>5.2高级程序执行..................................................... ............................ 33</span></a></p><p><a href='#'><span>5.3计划作为模型检查.................................... ............................................. 36</span></a></p><p><a href='#'><span>5.4时间规划............................................... ..................................................... 39</span></a></p><p><strong><span>6讨论与展望.............................................. .................................... 41</span></strong></p><p>&nbsp;</p><h1><a name="1%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8A%A8%E6%9C%BA" class="md-header-anchor"></a><span>1介绍与动机</span></h1><p><span>Web服务是可以使用标准协议通过Internet公开和调用的分布式软件组件。这个概念是由Microsoft，IBM和Sun等主要IT公司提出的，它们是用于分布式计算的Web兼容解决方案，具有开放，完全标准化和与供应商无关的方法的特别吸引人的特性。</span></p><p><span>Web服务通过在Internet上发送基于XML的消息来与其客户和其他Web服务进行通信。Web服务提供的操作的签名及其支持的消息格式形成于其</span><em><span>接口中</span></em><span>。通常，接口描述语言（IDL）（例如Web服务描述语言WSDL，W3C，2002）用于描述服务接口。</span></p><p><span>WSDL允许将服务类型（称为</span><em><span>Port Types</span></em><span>）的抽象描述与服务的具体实现分离。因此，单个端口类型描述可用于相似类型的多个服务。这允许定义</span><em><span>标准化的</span></em><span>服务接口，并且具有共同兴趣的参与者可以就这些描述的语义共同达成协议。基于此类协议，可以设计客户端应用程序以使用Web服务，并且可以构成涉及多个服务的复杂流程，例如使用BPEL4WS（IBM等，2002）流程描述语言。</span></p><p><span>当服务偏离初始协议时，这种方法的问题就变得迫在眉睫。例如，当服务更改其实现（例如，以改进其服务产品）时，其语义以及可能的语法接口将发生更改。由于在语义和句法接口之间没有定义正式的机器可解释的连接，因此需要人工干预来确定服务是否仍与约定的语义兼容。</span></p><p><span>解决此限制的一种方法是以</span><em><span>正式的机器可解释的</span></em><span>方式写下服务语义的足够大的部分，这与语法接口非常相似。这减少了对外部语义协议的依赖，这些语义通常难以达成，对于每种新服务类型都必须达到，并且每次对Web服务进行修改后都必须重新评估。取而代之的是，语义描述为软件代理提供了一种对服务的语义进行自主推理的方式，即服务运行的前提条件和后果。</span></p><p><span>在语义注释的服务环境中，需要实现某些目标的用户可以由软件代理协助，该软件代理可以自动识别并在必要时动态组合服务以实现用户的目标，这些服务可以明确声明或从中获得。用户所处的情况。</span></p><p><span>但是，服务的动态组合是一个难题，尚不清楚哪种技术最能解决问题。为此任务提出的一种技术是AI（人工智慧）计划。计划是一个复杂的问题，人工智能研究对此进行了广泛的研究。（Russel和Norvig，1995）将计划问题描述为：“计划可以解释为一种解决问题的方法，其中，代理人使用其对可用行为及其后果的信念，以识别抽象集上的解决方案。可能的计划”。</span></p><p><span>最近，有几篇论文（例如，McDermott，2002年； Srivastava和Koehler，2003年； Carman等人，2003年； Sirin和Parsia，2004年）研究了应用</span><em><span>AI计划技术</span></em><span>来获得实现以下目标的Web服务流程的潜力和边界。期望的目标。在本报告中，我们旨在通过对最重要的计划技术进行调查并讨论其对动态Web服务组合的适用性来扩展此研究。</span></p><p><span>本文的其余部分安排如下：在Sect。2我们列出</span></p><p><span>我们从中收集需求的方案。在宗派。3我们讨论了相关的规划概念框架。然后，我们继续讨论Sect中的基本计划范式。4和Sect中面向知识的计划范式。5.然后，我们将一组代表性的计划引擎与我们确定的核心需求进行对比，并讨论结果和未来工作的可能方向。</span></p><h1><a name="2%E7%A7%8D%E6%83%85%E5%86%B5" class="md-header-anchor"></a><span>2种情况</span></h1><p><span>为了评估我们面临的各种潜在需求的重要性，我们考虑以下Web服务域集合：</span></p><p><span>• </span><em><span>网络购物</span></em><span>域（Peer，2004b）：服务的集合，提供浏览目录和购买商品的功能。可能的目标是找到和购买一种或多种产品，价格可能最好。</span></p><p><span>• </span><em><span>文档处理</span></em><span>域（Peer，2004b），类似于（Golden，1997）中的Softbots域：服务提供了处理文件的功能，例如转换，压缩或加密文件。可能的目标是一系列文档转换，例如转换和打包文档集合。</span></p><p><span>• </span><em><span>邮件复制</span></em><span>域（Vukovic和Robinson，2004年）：该域将与电子邮件相关的服务（即SMTP和POP服务器的SOAP接口）与文档处理域中的服务结合在一起（参见上文）。该领域的典型目标是消息的发送和接收，以及依赖于上下文的邮件系统行为的适应，例如上下文和用户相关的显示，其中涉及文本翻译和图像转换服务。</span></p><p><span>• </span><em><span>旅行</span></em><span>领域（McIlraith和Son，2002年）：该领域的服务提供查询和预订机票和住宿的能力。该领域的典型问题是计划会议出席，这通常涉及要满足的其他用户定义约束（例如，会议日期，某些酒店或航空公司的偏好）。</span></p><h1><a name="3%E5%88%9D%E6%AD%A5" class="md-header-anchor"></a><span>3初步</span></h1><p><span>通常，计划问题包含以下组成部分：</span></p><p><span>•以某种形式的语言描述可能执行的动作（领域理论）。</span></p><p><span>•描述世界的初始状态</span></p><p><span>•预期目标的描述</span></p><p><span>在以下各节中，我们介绍最重要的方法来定义计划问题的组成部分，并将它们与Web服务组合问题的要求进行对比。</span></p><h2><a name="3.1%E8%A7%84%E8%8C%83%E8%AE%A1%E5%88%92%E9%A2%86%E5%9F%9F" class="md-header-anchor"></a><span>3.1规范计划领域</span></h2><p><span>领域形式化的目的是提供一个</span><em><span>领域理论</span></em><span>，即对代理可用或相关的操作语义的形式描述。这些操作可以表示物理操作（例如，由机器人的物理环境定义），但也可以表示更多抽象的操作（例如，从银行帐户提取资金）。</span></p><p><span>领域理论必须正式定义行动的</span><em><span>因果规律</span></em><span>，即必须允许公理化相关方面，例如行动的先决条件及其对世界的影响。通常，领域理论遵循某种状态转换模型，即，它们引入</span><em><span>状态</span></em><span>（或情境）概念，这是描述特定时间点的世界的快照，并且将动作与此类状态之间的转换相关联。大多数方法将状态扩展地定义为一组基本的原子公式（原子），其中随时间变化其值的原子称为</span><em><span>流质，</span></em><span>而那些不变化的原子称为</span><em><span>状态不变量</span></em><span>。</span></p><p><span>关于认识论原理领域理论的基础，我们可以区分两个变体：基于经典逻辑的领域理论和额外逻辑领域理论。</span></p><p><span>在逻辑方法中，有情境演算，它是由（McCarthy，1963）提出，后来又由（Levesque et al。，1998; Pirri and Reiter，1999）改进的，后者将情境演算定义为为用经典的一阶语言表示动态变化的世界。情境演算将世界及其变化表示为情境序列，其中每个情境都是代表状态的术语，是通过执行action [ </span><a href='#'><span>2 </span><span>]</span><span>获得的</span></a><span>。</span></p><p><span>将运算编码为一阶谓词逻辑的另一种方法是</span><em><span>事件演算</span></em><span>（Kowalski和Sergot，1989）。在事件演算中，事件会启动某些属性成立的时期。属性由事件启动，并一直保持到发生某个事件终止该事件为止。事件，事件的影响和持续时间以Horn逻辑表示。</span></p><p><span>另一种基于逻辑的方法是基于模态逻辑的动作理论，如（Giacomo和Lenzerini，1995； Castilho等，1999； Giordano等，1998）所讨论的。像情境演算一样，模态方法定义了一个世界状态系统，其中将动作建模为这些状态之间的转换。模态逻辑方法通过将动作概念化为Kripke结构中的</span><em><span>可访问性关系</span></em><span>，从而可以将动作作为状态转换进行非常自然的建模。正如我们将在后面的章节中看到的。5.3，Kripke结构实际上实际上是用来表示不确定域的。</span></p><p><span>尽管这些基于纯逻辑的方法有很多优点，例如精确的语义和证明领域理论某些属性的能力，但AI规划社区在很大程度上使用了不同的形式主义来表达规划领域。这些形式主义很大程度上源于STRIPS（Fikes and Nilsson，1971）标记，该标记在1970年代用于描述称为“ Shakey”的机器人系统的规划领域。STRIPS允许通过指定一个前提条件，一个ADD列表和一个DELETE列表来直接定义运算符，它们全部表示为原子的连接。直观地讲，此类运算符描述的语义是，仅当当前世界状态（表示为数据库）满足先决条件时，才可应用操作，并且执行该操作后，会将ADD-list的原子添加到世界状态，并删除DELETE-list的原子。但是，STRIPS的精确逻辑语义长期以来一直是争论的话题，并提出了不同的建议，例如（Lifschitz，1986; Reiter，2001）。</span></p><p><span>ADL语言（Pednault，1989； Pednault，1994）为更富表现力的运算符描述提供了支持，并缩小了语义上模棱两可的STRIPS与声明性情境演算之间的差距：ADL允许定义上下文相关效应，普遍量化效应（例如需要来模拟使用卡车的货物运输），取反和分离。</span></p><p><span>随着时间的流逝，已经开发了许多支持各种表达水平的AI计划系统，在许多情况下，它们位于ADL和STRIPS之间的中间地带，有时甚至超出了表达时间推理，度量，任务网络等的范围。各种各样的“即席”格式，其语义通常是模棱两可的。为了解决这个问题，开发了规划域定义语言（PDDL）（Ghallab等，1998）以用作标准域（和问题）规范语言，以简化各种系统的比较。PDDL允许定义ADL的表达域，包括度量标准流利度，并为符合标准的扩展定义规则。原始PDDL版本的后续版本是PDDL 2.1（Fox和Long，2003年），其中增加了时间概念和PDDL 2。2，它添加派生谓词和定时初始文字。例如，已经提出了其他一些扩展（Bertoli等人，2003年），该扩展扩展了PDDL以表达不确定性，有限感测和迭代条件计划。</span></p><h2><a name="3.2%E6%AD%A3%E5%BC%8F%E5%8C%96%E5%88%9D%E5%A7%8B%E4%B8%96%E7%95%8C" class="md-header-anchor"></a><span>3.2正式化初始世界</span></h2><p><span>计划代理必须考虑初始世界状态，因为它必须提供在初始世界中执行时会导致指定目标的计划。</span></p><p><span>在上一节中讨论的概念化不仅定义了动作的概念模型，而且还定义了计划代理给出的初始世界描述的概念模型。实际上，初始世界只是领域理论定义的另一个世界状态（或情况）。</span></p><p><span>在几乎所有方法中，构成世界状态的核心元素是已知在初始世界状态中真实的原子。经典的AI规划方法假定初始世界状态的扩展定义提供了</span><em><span>完整的</span></em><span>描述。这允许采用封闭世界假设，这意味着未在状态数据库中明确列出的任何事实都是错误的。</span></p><p><span>对于现实世界的应用程序，例如机器人技术或我们的Web服务计算领域，这些简化的假设是不现实的。实际上，我们面临以下问题：</span></p><p><span>•信息不完整：初始世界的扩展定义并未指定与计划任务相关的所有知识。例如，在电子商务应用程序中，代理可能不知道哪个在线零售商提供哪些产品，但是它需要此信息来实现其</span><em><span>购买</span></em><span>产品的目标。</span></p><p><span>•错误的信息：在现实中，某些定义为true的原子可能是错误的（反之亦然）。当违反了</span><em><span>调用和合理持久性（IRP）的</span></em><span>假设（McIlraith and Son，2001）时，即发生行为时，即当代理人获得关于这些事实的知识后事实发生变化并且代理人错误地认为其知识是正确的时，就会发生这种情况。</span></p><p><span>•模糊信息：对于每个已知的流利值，可能存在不正确的一定概率（例如，由于传感器模糊）。同样，此问题在我们的域中不经常出现。</span></p><p><span>规划人员的概念模型已随时间扩展，以更好地解决上面列出的困难。由于代理人的世界观可能会偏离现实世界，因此明确表示代理人具有的知识很有用。主体的知识可以由原子事实知识以及某些公理和功能组成。沿着这些思路，已经研究了广泛使用的封闭世界假设的替代方法，例如</span><em><span>本地封闭世界假设</span></em><span>（LCA），它可以代表本地封闭世界（LCW）知识（Golden，1997年）。LCW知识通常组织在两个数据库M和L中，其中数据库M包含所有已知事实的集合，数据库L包含描述M内容的LCW公式，即，它们说明代理的知识可以在世界的哪个部分安全地假定是完整的。例如，当代理商查询在线零售商</span><em><span>A</span></em><span>出售的所有产品的列表时，它可能假设知道从</span><em><span>A</span></em><span>可获得的所有产品（当IRP假设成立时）。</span></p><p><span>当明确表示代理知识时，就需要定义一些域运营商对代理知识的影响。换句话说，将改变</span><em><span>世界</span></em><span>的运营商（或效应）与仅影响代理的</span><em><span>知识的</span></em><span>运营商（或效应）区分开是很有用的。后者称为感应操作（或感应效果）。STRIPS的扩展是UWL（Etzioni等，1992），它解释了不完整的知识和感知动作。同样，SADL（Golden，1997）为ADL添加了对不完整信息和感知的支持，而NPDDL（Bertoli等，2003）提出了对PDDL的类似扩展。提议的对PDDL的另一个扩展是Opt（McDermott，2002），它增加了知识效果和</span><em><span>可学习的术语</span></em><span> 到PDDL框架。</span></p><p><span>在正式的情境演算基础上，对代理人的不完全知识和感知行为进行了解释（Moore，1985），它还引入了知识前提的概念，这是代理人的知识基础才能成功应用操作员所必须满足的条件。</span></p><h2><a name="3.3%E6%AD%A3%E5%BC%8F%E7%9B%AE%E6%A0%87" class="md-header-anchor"></a><span>3.3正式目标</span></h2><p><span>在大多数经典的AI规划方法中，目标表示为需要保持在所需世界状态（</span><em><span>目标状态</span></em><span>）中的属性，通常以文字（正负原子）的合取与析取的形式表示，并使用存在量化。</span></p><p><span>计划者需要确定一个解决方案（一个计划），当该解决方案在初始世界状态下执行时，将导致一个满足目标的世界状态。例如，一个目标</span><em><span>（彩门1红）</span></em><span>规定说流利的条件</span><em><span>颜色</span></em><span>的</span><em><span>门1</span></em><span>的值必须为</span><em><span>红色</span></em><span>计划执行后，和一个目标</span><em><span>（有门House1？d）</span></em><span>将需要不断的存在</span><em><span>Ç</span></em><span>，即什么时候绑定变量？</span><em><span>d</span></em><span>会使公式</span><em><span>（有门House1？d）</span></em><span>成立。</span></p><p><span>对于自动Web服务组合（以及许多其他域），这些目标说明还不够。文献中列出的要求是：</span></p><p><span>•对时间结构的需求：某些复杂的目标不能简单地表达为最终状态的属性。例如，规划从维也纳到苏黎世的往返行程不能表示为目标状态的条件，因为目标状态将等于初始状态（即，代理人位于Vienna [ </span><a href='#'><span>3 </span><span>]</span></a><span>）。因此，需要添加某些结构以将计划目标划分为几个不同的连续阶段。在某些情况下，有效的计划甚至可能必须包括循环和分支，如（Srivastava和Koehler，2003）所指出的。</span></p><p><span>•处理不确定性的策略，即，如果操作的执行未达到预期或期望的结果（例如，通过定义类似BPEL的</span><em><span>补偿措施</span></em><span>），该如何表现。</span></p><p><span>•安全性：并非所有</span><em><span>可能的</span></em><span>解决方案都是</span><em><span>理想</span></em><span>的。例如，可能某些流利的价值不应该或仅适度改变（例如信用卡余额）；这些受保护的流利有时被称为</span><em><span>维护目标</span></em><span>或</span><em><span>资源限制</span></em><span>。此外，在许多领域中，特工可能会陷入某些情况，需要完全避免这种情况，并且对目标的限制可以帮助他们逃避。</span></p><p><span>• </span><em><span>信息目标</span></em><span>和</span><em><span>成就目标</span></em><span>之间的区别：许多问题需要这样的区别，因为信息目标应仅通过</span><em><span>感知行动</span></em><span>来实现。举例来说，找出项目当前颜色的目标只能使用</span><em><span>不会</span></em><span>主动影响其颜色的操作；我们不希望代理使用将颜色设置为某个新值然后报告新分配的颜色的操作（Golden，1997）。取而代之，应该通过</span><em><span>感测操作</span></em><span>来收集值。</span></p><p><span>•用户对可能的解决方案的偏好（例如，优先选择乘飞机旅行而不是乘火车旅行，通过信用卡付款而不是电子现金）以及该解决方案上用户提供的其他限制条件（例如，仅在驾车时间超过3小时的情况下才购买机票） （麦克拉伊斯和儿子，2001年）</span></p><p><span>由于这些困难不仅与Web服务组合有关，而且与许多现实世界的计划领域有关，因此存在几种解决这些问题的方法，这些将在Sect中讨论。5，</span></p><h2><a name="3.4%E4%BB%A3%E8%A1%A8%E8%AE%A1%E5%88%92" class="md-header-anchor"></a><span>3.4代表计划</span></h2><p><span>计划作为解决计划问题的解决方案的经典观点是</span><em><span>一系列操作员实例</span></em><span>，这些</span><em><span>实例</span></em><span>在执行后会导致满足给定目标的状态。考虑到上一节中对目标的讨论，特别是对不确定性问题的讨论，这种经典的计划观点并不总是足以捕获复杂计划问题的解决方案也就不足为奇了。</span></p><p><span>计划所需的复杂性不仅取决于领域和目标的复杂性，还取决于针对该计划预见的执行模型：如果一项操作未产生期望的结果，则代理将有机会重新生成该计划。计划（例如在重新计划/反应式计划体系结构中，例如（Firby，1987）），还是代理商必须依赖预定义的计划？在后一种情况下，需要一个</span><em><span>有条件的</span></em><span>计划，该计划应通过构建一个计划来解决不确定性和不完整的信息，该计划应考虑可能发生的突发事件。在运行时，代理必须确定其所处的状况，然后选择为该状况准备的适当计划分支。采用该策略的计划者也称为应急计划者。</span></p><p><span>除了应急计划制定者外，计划还存在其他几个简单序列的扩展。正如我们稍后将在Sect中讨论的那样。4.3，部分订单计划者允许计划其动作被部分排序的计划，即某些动作可以并行执行而不是顺序执行，这通常会提高系统的效率。使用本节中介绍的计划作为模型检查（MC）方法，甚至可以创建功能更丰富的计划。5.3，其中计划者综合可能包含循环和分支的计划。</span></p><h1><a name="4%E7%A7%8D%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%92%E8%8C%83%E4%BE%8B" class="md-header-anchor"></a><span>4种基本规划范例</span></h1><p><span>在下文中，我们将概述基本规划范式以及这些概念的一些代表性实现。</span></p><h2><a name="4.1%E5%9F%BA%E4%BA%8E%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E7%9A%84%E8%A7%84%E5%88%92" class="md-header-anchor"></a><span>4.1基于状态空间的规划</span></h2><p><span>状态空间由状态</span><em><span>S</span></em><span>的有限集合，动作</span><em><span>A</span></em><span>的有限集合，描述动作如何将一个状态映射到另一个状态的状态转换函数</span><em><span>f</span></em><span>以及度量成本的成本函数</span><em><span>c</span></em><span>（</span><em><span>a，s</span></em><span>）</span><em><span>&gt;</span></em><span> 0组成状态</span><em><span>s</span></em><span>中执行动作</span><em><span>a</span></em><span> </span><em><span>的过程</span></em><span>（Fikes and Nilsson，1971）。以给定的初始状态</span><em><span>s</span></em><span> 0和一组目标</span><em><span>SG</span></em><span>扩展的状态空间也称为</span><em><span>状态模型</span></em><span>（Bonet和Geffner，2001b）。</span></p><p><span>基于状态的计划者旨在通过搜索实现所需状态的有用的操作员实例来解决计划问题。根据搜索的起点，我们区分前向状态搜索（也称为渐进式）和后向状态搜索（也称为回归）：基于渐进式状态的计划程序从初始状态开始，并搜索使计划程序更接近状态的动作实例。目标。回归计划器从满足目标的状态开始，然后搜索使计划器更接近初始状态的操作实例。</span></p><p><span>在这两种情况下，目标都是找到一系列动作，这些动作从初始状态开始应用时，将导致目标状态。更正式地讲，状态模型的解决方案是一系列动作</span><em><span>a</span></em><span> 0 </span><em><span>，a</span></em><span> 1 </span><em><span>，...，an</span></em><span>，生成状态轨迹</span><em><span>s</span></em><span> 0 </span><em><span>，s</span></em><span> 1 = </span><em><span>f</span></em><span>（</span><em><span>s</span></em><span> 0）</span><em><span>，...，sn</span></em><span> +1 = </span><em><span>˚F</span></em><span>（</span><em><span>一个，SN</span></em><span>），从而使得每个动作</span><em><span>的AI</span></em><span>是适用于</span><em><span>SI</span></em><span>和</span><em><span>SN</span></em><span> 1是一个目标状态，即，</span><em><span>AI</span></em><span> ∈ </span><em><span>甲</span></em><span>（</span><em><span>SI</span></em><span>）和</span><em><span>SN</span></em><span> 1∈ </span><em><span>ģ</span></em><span> （Bonet and Geffner，2001b）。</span></p><p><span>原则上，任何搜索算法都可用于执行基于状态的搜索，而均值末端分析的学科起源于1950年代，即GPS以来的悠久历史（Newell和Simon，1963年）。但是，规划人员通常必须从呼吁减少方法的方法中选择许多不同的动作分支，这些方法可减少搜索空间或帮助区分搜索树的有益分支与无用分支。减少搜索空间的早期尝试是STRIPS算法。它使用向后搜索，即从目标开始，搜索达到目标或其子目标之一的动作，然后继续搜索达到动作先决条件的动作，依此类推。STRIPS仅考虑添加到计划中的最后一个运算符的前提条件，并承诺当前条件满足其前提条件的运算符，从而增强了此搜索范围。这显着减少了计划空间，但是却使STRIPS不完整，即，即使存在问题，也不能保证找到解决方案。</span></p><p><span>处理计划空间巨大的另一种方法是采用</span><em><span>启发式函数</span></em><span>，这些</span><em><span>函数</span></em><span>估计计划者可以选择的替代操作的有用性，从而</span><em><span>指导</span></em><span>计划者选择富有成效的搜索路径，并忽略可能导致死胡同或失败的分支。低质量的解决方案。真正的自动领域独立计划者别无选择，只能从领域及其遇到的问题描述中收集这些启发式方法，这与专门的算法相反，例如解决AI教科书中所讨论的8难题的算法（Nilsson，1980）。</span></p><p><span>采用这种与域无关的启发式方法的计划者是UNPOP（McDermott，1996），它使用回归匹配图。该图的构建从目标开始，该目标与当前情况相匹配，从而产生了一组要实现的文字。在图表的下一个级别中，将考虑实现某些子目标的操作，这会产生执行这些操作所需的另一组子目标。这些子目标将添加到图形的下一层，然后重复该过程。为了增强图形遍历，</span><em><span>估计工作量</span></em><span>的概念使用，即估算要达到主要目标将要采取的行动，从而在当前情况下已经给出的目标的努力为0，而在此情况下任何操作员都无法实现的目标的努力该域是∞。在遍历回归图时，联合国人口基金会首先选择其工作量估计似乎比较合适的分支机构，与“盲目”无指导搜索相比，这会提高计划速度。</span></p><p><span>在相关工作中，提出了基于</span><em><span>累加启发式hadd</span></em><span>的前向计划器HSP（启发式搜索计划器）。这种启发式定义了一组的成本</span><em><span>Ç</span></em><span>原子作为的元件的成本的总和</span><em><span>Ç</span></em><span>。假设子目标彼此独立，这并不总是正确的，因为一旦实现其他目标，某些目标可能会变得越来越（或什至更大）困难。HSP系统使用</span><em><span>hadd</span></em><span>指导从初始状态到目标</span><em><span>的爬山搜索</span></em><span>。在每个步骤中，最好的子节点之一（即其</span><em><span>had的</span></em><span>节点）值最小）进行扩展，并重复相同的过程，直到达到目标为止。成本计算为</span><em><span>估算值</span></em><span>，这些</span><em><span>估算值</span></em><span>是从宽松的计划问题</span><em><span>P</span></em><span>中提取的0，忽略运算符的负面影响。通过迭代应用许多操作的正效应来进行估计，这些操作的前提条件适用于当前状态（忽略负效应），并通过跟踪在实现了多少步后在该过程中实现的每个原子（Bonet）和Geffner，1998年）。经验数据表明，如国际规划竞赛IPC1998（McDermott，2000； Bonet和Geffner，2001b）的结果所示，使用松弛问题来收集启发式估计以及假设目标独立的想法产生了较好的结果。</span></p><p><span>在随后的工作中，开发了计划程序HSP2（Bonet和Geffner，2001a），该计划程序使用了相同的启发式功能</span><em><span>hadd</span></em><span>，但是使用</span><em><span>bestfirst搜索</span></em><span>（Pearl，1985）而不是爬山。最佳优先搜索通过评估函数</span><em><span>f</span></em><span>（</span><em><span>n</span></em><span>）= </span><em><span>g</span></em><span>（</span><em><span>n</span></em><span>）+ </span><em><span>W</span></em><span> ∗ </span><em><span>h</span></em><span>（</span><em><span>n</span></em><span>）加权节点，其中</span><em><span>g</span></em><span>（</span><em><span>n</span></em><span>）是累积成本，</span><em><span>h</span></em><span>（</span><em><span>n</span></em><span>）是目标的估计成本，并且</span><em><span>W</span></em><span>是一个常数。较高的</span><em><span>W</span></em><span>值不仅与更快的计划搜索相关，而且与更低的计划质量相关（Korf，1993）。HSP2 在HSP中生成的每个新状态下，从头开始评估</span><em><span>hadd</span></em><span>启发式方法。</span></p><p><em><span>hadd</span></em><span>的重新生成是一个明显的性能问题，这是HSP规划人员以及UNPOP等相关规划人员的瓶颈。尝试解决此问题的是HSPr（Bonet和Geffner，1999），它是HSP的一种变体，它使用从目标向后搜索而不是从初始状态进行正向搜索。估计仅从初始状态计算一次，启发式函数</span><em><span>hadd</span></em><span>（</span><em><span>s</span></em><span>）始终是从初始状态实现目标所需的费用总和（Bonet和Geffner，1999）。前向传播以获取估计值和后向搜索计划的结合让人联想到Graphplan（Blum和Furst，1995年），该计划已在Sect。中进行了讨论。4.2。尽管事实证明，HSPr可以显着提高某些领域的性能，但新算法在其他领域却不如HSP（Bonet和Geffner，1999）。</span></p><p><span>快进（FF）计划程序（Hoffmann，2001年）进一步推进了启发式搜索的计划，该计划是ICP2000竞赛的胜出者，胜过HSP2等。像HSP一样，FF依靠状态空间中的前向搜索，并通过启发式算法进行引导，该启发式算法使用松弛问题估算目标距离。但是，FF基于Graphplan样式算法（参见第4.2节）使用了更为复杂的提取启发式值的方法。松弛解中的动作数用作目标距离估计；类似于Graphplan的解决方案提取的优点之一是，它考虑了事实之间的积极相互作用。估算值用于指导一种新颖的本地搜索策略，称为</span><em><span>强制爬山</span></em><span>。与HSP随机选择每个中间状态的最佳后继相比，FF评估一个状态的所有后继（如果需要，还评估后继等），以寻找一种具有比当前状态更好的启发式值的状态。简而言之，在每次搜索迭代中，首先进行广度优先搜索，以严格评估评估状态。这种策略使计划者可以逃脱高原和局部极小值。FF的第三个优势是其</span><em><span>有益行动的</span></em><span>概念，即，它使用规划图中的信息来识别每个状态在其所达到的效果方面似乎最有用的行动，并且它比那些看上去似乎有用的行动者更喜欢这些行动。多余的（Hoffmann，2001; Hoffmann and Nebel，2001）。</span></p><p><span>FF的扩展名为Metric-FF，已在（Hoffmann，2003; Hoffmann，2002）中提出。它处理PDDL 2.1级别2中捕获的数值变量，约束和效果。Metric-FF支持数值状态变量，这些变量可以在前提条件（例如</span><em><span>Cash&gt;</span></em><span> 100）中进行数值约束，并且可以在效果中进行算术运算（例如</span><em><span>Cash</span></em><span> − = 10） ）。</span></p><p><span>尽管近年来使用松弛计划图的启发式方法取得了显著成功，但在某些领域，FF和HSP计划者系列的表现不佳，因为他们忽略负面影响的松弛方法会丢失太多重要信息。最近解决此问题的启发式搜索计划器是Fast Downward（Helmert和Richter，2004）。与以前的计划者（例如HSP和FF）相比，它没有使用宽松的计划图，而是使用了因果图（CG）数据结构（Helmert，2004年）。</span></p><h2><a name="4.2%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E8%AE%A1%E5%88%92" class="md-header-anchor"></a><span>4.2基于图的计划</span></h2><p><span>到目前为止，已经讨论过的一些计划者利用图结构来提取启发式方法。在本节中，我们将讨论（布鲁姆和弗斯特，1995年）中引入的图形计划框架，该框架使称为规划图形的紧凑结构的构造，注释和分析形式化。尽管有一些相似之处，但是“规划图”并不是像UNPOP中使用的那样的空间图。事实上，与状态空间图，其中一个计划是通过曲线图中的路径，在一个规划图，平面图是一个</span><em><span>流</span></em><span>在网络流量传感（百隆和弗斯特，1997）。</span></p><p><span>计划图是有向图。它由两种类型的节点组成，即</span><em><span>动作节点</span></em><span>和</span><em><span>命题节点</span></em><span>。这些节点布置在交替的</span><em><span>水平</span></em><span>包含命题节点，后面是动作节点层，依此类推。每个级别都与一个时间步长相关联。计划图的第一层是一个命题层，它包含一个针对初始情况的每个命题的节点。第二层是一个动作层，其中包含所有动作的前提由第一层的命题节点满足。第三级别还是命题级别，包含来自第一级别的命题节点和代表前一动作层的动作效果的命题节点。当两个连续的命题层相同时，计划图的构造停止；已经表明，这种情况总是发生，保证了过程的终止。</span></p><p><span>在</span><em><span>i</span></em><span>级别上的所有动作都与</span><em><span>i</span></em><span> -1 级别的前提条件及其在</span><em><span>i</span></em><span> +1 级别的效果相关，从而在</span><em><span>i</span></em><span> +1中引入或否定了命题。对于从</span><em><span>i</span></em><span> -1到</span><em><span>i</span></em><span> +1 层持续存在且未连接到动作节点的文字，将添加持久性动作节点。此外，（Blum和Furst，1995年）为动作和文字定义了互斥关系（“互斥体”）。动作之间可能的互斥关系是</span><em><span>不一致的效果</span></em><span>，其中一个动作否定另一个动作的影响，</span><em><span>推论</span></em><span>，其中一个动作的影响之一是否定另一个</span><em><span>需求</span></em><span>和</span><em><span>竞争需求</span></em><span>的前提。，其中一项行动的先决条件与另一项行动的先决条件互斥。如果一个命题相互否定，或者可以实现两个命题的每对可能的动作都是互斥的（Russel和Norvig，2002），则在同一层次上两个命题之间存在相互关系。</span></p><p><span>在这样的计划图中捕获的信息，尤其是排除关系，传播了有关该问题的各种直观有用的事实。规划人员可以使用此信息来指导他们的搜索。使用此技术的第一个计划者是Graphplan，它在（Blum and Furst，1995）中引入。Graphplan算法的操作分为两个主要步骤，它们在循环内交替进行：</span><em><span>图形展开</span></em><span>和</span><em><span>解决方案提取</span></em><span>。图的扩展将如上图所示增长规划图，直到达到命题级别，在该命题级别上，所有目标命题都存在，并且任何一对对象之间都没有互斥体链接。这是存在计划的必要条件（但不足）。为了寻找潜在的计划，然后开始溶液提取阶段。Graphplan算法使用反向链接策略，采用逐级方法，以便充分利用互斥约束（Blum和Furst，1997）。给定时间（级别）</span><em><span>t的</span></em><span>一组目标，Graphplan旨在确定时间</span><em><span>t的</span></em><span>一组动作-1，这些目标具有效果。在每个步骤中，仅考虑与计划中现有操作不互斥的操作。失败时，Graphplan会回溯并尝试不同的操作集。如果未找到计划，并且尚未调整计划图，则Graphplan将继续进行图扩展，直到到达另一个有希望的命题层。可以将解提取公式化为约束求解问题[ </span><a href='#'><span>4 </span><span>]</span></a><span>（Do和Kambhampati，2001）或搜索问题（Russel和Norvig，2002）。</span></p><p><span>Graphplan的优点除了其良好的性能外，还具有诸如健全性，完整性，生成最短计划以及终止无法解决的问题等理论特性。但是，原始的Graphplan算法具有一些局限性：首先，其表示语言仅限于纯STRIPS运算符，不允许有条件或普遍量化的效果；其次，如果在计划任务的规范中包含了太多不相关的信息，则性能可能会急剧下降（Nebel等，1997）。</span></p><p><span>在（Koehler et al。，1997）中，提出了Ipp计划程序的早期版本，该计划将Graphplan扩展到处理条件和普遍量化的影响。作者表明，此扩展的计算开销可忽略不计，并且与支持ADL子集的其他计划程序（例如UCPOP和Prodigy）竞争很好。在其他工作中，RIPP（Koehler等，1997）中增加了RIFO（消除不相关的算子和规划问题的初始事实）策略，以不相关的信息解决了Graphplan的问题。此外，Ipp新增了一个目标议程管理器（GAM），用于订购子目标集并逐步计划子问题（Koehler和Hoffmann，2000年），最近又添加到FF计划器中。</span></p><p><span>Stan（Long and Fox，1999）是另一个基于Graphplan的计划者，该计划者随着时间的推移而发展。它以多种方式改进了Graphplan。首先，Stan使用（Fox and Long，1998）中描述的类型推断模块（TIM）在计划之前对计划域执行了许多预处理分析或STate ANalyses。此外，Stan使用前提条件和效果的有效内部表示形式（作为位向量），从而可以实现计划图的资源高效表示（称为</span><em><span>穗</span></em><span>），并可以使用有效的位操作来对动作和事实进行互斥检查。操作[ </span><a href='#'><span>5 </span><span>]</span></a><span>。此外，使用称为</span><em><span>波前</span></em><span>的技术可避免在尖峰结构中出现冗余信息。 （Long and Fox，1999），这导致了比Graphplan更好的空间需求。</span></p><p><span>感官图计划SGP（Weld等人，1998）是对图计划的扩展，不仅支持（Gazen和Knoblock，1997）中所述的条件效应，而且还处理不确定性效应（Smith和Weld，1998）和不确定性。在初始情况下。（Smith and Weld，1998）提出的想法是为每个可能的世界扩展一个单独的计划图，跟踪世界之间的互斥，然后向后搜索在所有可能的世界都可行的计划。SGP引入了</span><em><span>（swwf）</span></em><span>形式的观察效果，其中</span><em><span>wwf</span></em><span>表示由命题组成的任意逻辑表达式。SGP中的运算符可能具有零个或多个这样的观察效果，当在运行时执行该观察效果时，传递指定表达式</span><em><span>wwf</span></em><span>的真值。为了完成Graphplan的扩展，SGP修改了图扩展阶段，以使其从传感器定义和先前的规划图命题层获得知识命题。此外，它将解决方案威胁解决方案方法整合到解决方案提取阶段。此外，SGP生成具有可重新加入分支机构的应急计划。</span></p><h2><a name="4.3%E9%83%A8%E5%88%86%E8%AE%A2%E5%8D%95%E4%BC%98%E5%8C%96%E8%AE%A1%E5%88%92" class="md-header-anchor"></a><span>4.3部分订单优化计划</span></h2><p><span>与迄今为止讨论的技术相比，部分订单细化计划者（也称为部分订单因果联系计划者（POCL）或部分订单因计划者（POP））提出的计划问题不是在</span><em><span>世界国家</span></em><span>空间中搜索，而是在</span><em><span>部分指定计划</span></em><span>的空间中搜索，即搜索空间的节点不是状态而是</span><em><span>计划</span></em><span>，并且节点之间的弧不是动作执行而是</span><em><span>计划的完善</span></em><span>。</span></p><p><span>POCL计划者通常会生成部分排序的计划，即，并非所有动作在计划中都有固定的顺序，并且计划可能具有多个不同的线性化，所有这些线性化都可以达到相同的结果。</span></p><p><span>在较早的文献中，部分排序的计划也称为任务网络，可以表示为四重</span><em><span>π</span></em><span> = hS </span><em><span>，</span></em><span> O </span><em><span>，</span></em><span> B </span><em><span>，</span></em><span> Li，它由以下组件组成：S是一组计划步骤，即操作实例。O是一组排序约束。每个排序约束的形式的</span><em><span>SI</span></em><span> ≺ </span><em><span>SJ</span></em><span>，这意味着步骤</span><em><span>SI</span></em><span>必须执行</span><em><span>前</span></em><span>步骤</span><em><span>SJ</span></em><span>。如果某些计划的集合S </span><em><span>π</span></em><span>至少有两个步骤</span><em><span>SA</span></em><span>和</span><em><span>SB</span></em><span>其中O既不含有</span><em><span>SA</span></em><span> ≺ </span><em><span>某人</span></em><span>也不</span><em><span>SA</span></em><span>≺ </span><em><span>某人</span></em><span>，那么</span><em><span>π</span></em><span>是一个</span><em><span>部分有序的</span></em><span>计划。B是对操作实例的参数的一组变量绑定约束：每个变量约束的形式为</span><em><span>var</span></em><span> = </span><em><span>x</span></em><span>或</span><em><span>var</span></em><span> 6 = </span><em><span>x</span></em><span>，其中</span><em><span>var</span></em><span>是某个计划步骤的变量，并且</span><em><span>x</span></em><span>是常数值或引用到其他计划步骤的变量。如果仅使用平面图步骤，则B =∅。L是一组因果关系。因果链接用于跟踪计划中引入步骤的原因，并防止其他步骤干扰该目的。如果步骤</span><em><span>si</span></em><span>实现了命题</span><em><span>p</span></em><span>为了满足步骤</span><em><span>sj</span></em><span>的先决条件，将因果链接</span><em><span>si</span></em><span> → </span><em><span>p sj</span></em><span>添加到L。</span></p><p><span>此外，在部分订单计划中考虑了以下派生集：OC是计划的开放条件集。当</span><em><span>p</span></em><span>是</span><em><span>Prec（s）的</span></em><span>一部分，并且L中没有因果联系</span><em><span>sx</span></em><span> → </span><em><span>ps</span></em><span>时，就会出现一个开放条件→ </span><em><span>ps</span></em><span>。换句话说，开放条件是计划步骤尚未解决的先决条件当前的计划。UL是不安全链接的集合。的因果关系</span><em><span>SI</span></em><span> → </span><em><span>p SJ</span></em><span>称为</span><em><span>不安全</span></em><span>如果存在步骤</span><em><span>SK</span></em><span> ∈S，从而使（ⅰ）¬ </span><em><span>p</span></em><span>是的（效果的一部分</span><em><span>SK</span></em><span>）和（ii）O是含{一致</span><em><span>SI</span></em><span>≺ </span><em><span>SK</span></em><span> ≺ </span><em><span>SJ</span></em><span> }。在这种情况下，据说</span><em><span>sk</span></em><span> </span><em><span>威胁</span></em><span>因果关系</span><em><span>si</span></em><span> → </span><em><span>p sj</span></em><span>。计划的开放条件和不安全链接的联盟被称为集F的</span><em><span>缺陷</span></em><span>的</span><em><span>π</span></em><span>，即F（</span><em><span>π</span></em><span>）= OC（</span><em><span>π</span></em><span>）∪UL（</span><em><span>π</span></em><span>）。没有缺陷的计划</span><em><span>π</span></em><span>称为</span><em><span>完成</span></em><span>。</span></p><p><span>可以通过引入或重新使用计划步骤来解决开放条件→ </span><em><span>ps</span></em><span>，该步骤可以实现</span><em><span>p</span></em><span>。在另一方面，</span><em><span>威胁</span></em><span>的因果关系的</span><img src='file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif' alt='img' referrerPolicy='no-referrer' /><span>一个步骤</span><em><span>SK</span></em><span>可以解决可能或者通过</span><em><span>促销</span></em><span>，通过添加排序约束，即</span><em><span>SK</span></em><span> ≺ </span><em><span>SI</span></em><span>至O或</span><em><span>降级</span></em><span>，加入即</span><em><span>SJ</span></em><span> ≺ </span><em><span>SK</span></em><span>到O.如果规划者使用提升的动作，即，如果允许动作实例的参数列表中包含变量，则威胁也可以通过</span><em><span>分离</span></em><span>来解决，即通过添加绑定约束使</span><em><span>p</span></em><span>和¬ </span><em><span>p</span></em><span>不能统一。计划者在计划空间中的导航方式，即，其用来选择要改进的计划的策略以及要消除的缺陷决定了计划者的效率。</span></p><p><span>1975年与NOAH（Sacerdoti，）签订了部分有序计划，这在近三十年间引发了研发活动。1977年，提出了NONLIN系统（Tate，1977年），该系统引入了因果联系的概念。（Chapman，1987）给出了部分订单计划的正式说明，该计划介绍了TWEAK系统，该系统可以处理合取和析取的先决条件以及合取效应。（Chapman，1987）还提供了TWEAKS稳健性和完整性的证明，其中使用</span><em><span>模态真值准则</span></em><span>（MTC）给出了后者，以明确检查所有安全接地线性化是否对应于解。但是，最近的计划者依赖于</span><em><span>保护策略</span></em><span>和</span><em><span>冲突解决方案</span></em><span>间接保证解决方案的安全性和必要性的正确性：SNLP（McAllester和Rosenblitt，1991年）引入了威胁和安全条件的概念，而UCPOP（Penberthy和Weld，1992年）将领域和问题描述的复杂性扩展到了具有条件效果和普遍量化的前提条件和效果以及普遍量化的目标。随后进行了许多工作来扩大SNLP和UCPOP，最重要的是涉及启发式算法以进行有效的缺陷选择，该算法在（Peot和Smith，1993； Williamson和Hanks，1996； Schubert和Gerevini，1995； Pollack等，1997）中得到了改进。尽管取得了这些逐步的改进，但在1990年代下半叶出现的新的“规划图”，“ SAT”和启发式状态空间规划器的性能却优于部分订单规划。</span></p><p><span>近年来（自2001年左右开始），人们进行了一些有前途的尝试来收回一些对POCL规划的拒绝：（Nguyen和Kambhampati，2001年）指出，负责Graphplan和启发式状态规划器效率的技术可以进行调整以大大提高部分订单计划的效率。（Nguyen和Kambhampati，2001年）介绍了RePOP，它是POP的一项实现，它结合了多项增强功能：它使用规划图来计算实现一组（子）目标的成本估算。此外，它使用一种新颖的技术来处理不安全链接：</span><img src='file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif' alt='img' referrerPolicy='no-referrer' /><span>与动作</span><em><span>ak</span></em><span>冲突的不安全链接不能通过升级或降级自动解决，这会导致新的局部计划，最终炸毁计划空间并降低性能；相反，RePOP使用在（Kambhampati and Yang，1996）中提出的析</span><em><span>取约束处理</span></em><span>，通过发布析取排序约束来解决不安全链接，该析取约束捕获了升级和降级的可能性，并通过传播技术逐步简化了这些约束，结果在发现许多失败的计划之前，先进行选择以进行完善。此外，RePOP改善了部分订单计划的一致性实施。POP认为因果链接</span><em><span>ai</span></em><span> → </span><em><span>p aj</span></em><span>仅受到动作</span><em><span>a的</span></em><span>威胁，如果它具有影响¬</span><em><span>p</span></em><span>。通常，</span><em><span>a</span></em><span>可能会影响</span><em><span>q</span></em><span>，以至于任何合法状态都无法使</span><em><span>p</span></em><span>和</span><em><span>q</span></em><span>一起成立。为了检测这种隐式冲突，需要有关可达状态的信息。同样，使用计划图来生成此信息。然后将可到达状态与</span><em><span>剪切</span></em><span>前后的设置进行对比，这是因果联系和排序约束所定义的计划步骤链中得出的前提条件和前提条件的并集。如果这些割集违反了可达状态的属性，即，如果检测到互斥锁（请参阅第4.2节），则将部分计划丢弃。这些增强的结果是，RePOP能够展示出比CSP和基于状态的计划者更高的性能，而CSP和基于状态的计划者从中借鉴了强大的冲突检测技术。同时，它能够在许多情况下生成更紧凑的解决方案，并且保留了POP框架的开放性和灵活性，这被认为是该框架的优势之一（Smith et al。，2000）。</span></p><p><span>多功能启发式部分订单计划器（VHPOP）取得了部分订单计划的另一项最新进展，该计划在（Younes和Simmons，2002年； Younes和Simmons，2003年）中提出，并在第三届IPC-3国际计划竞赛中成功竞争。</span></p><p><span>像SNLP和UCPOP一样，VHPOP使用</span><em><span>A</span></em><span> ∗算法（Hart等，1968）在计划空间中进行搜索。的</span><em><span>甲</span></em><span> </span><em><span>算法需要搜索节点评价函数</span></em><span>˚F</span><em><span>（</span></em><span>Ñ*）= </span><em><span>克</span></em><span>（</span><em><span>Ñ</span></em><span>）+ </span><em><span>ħ</span></em><span>（</span><em><span>Ñ</span></em><span>），其中</span><em><span>克</span></em><span>（</span><em><span>Ñ</span></em><span>）是获得到的成本</span><em><span>Ñ</span></em><span>从起始节点（即，最初的计划）和</span><em><span>ħ</span></em><span>（</span><em><span>n</span></em><span>）是达到目标节点（即完整计划）的估计剩余成本。为了鼓励搜索最小的计划，计划的成本就是其中的操作数量。而SNLP和UCPOP使用开放缺陷数F（</span><em><span>π</span></em><span>）计划给予的估计的</span><em><span>^ h</span></em><span>（</span><em><span>π</span></em><span>）的VHPOP规划师相适应的添加剂启发式</span><em><span>哈德</span></em><span> HSP的（参见节4.1），以达到更好的知情启发式，其中考虑到目标之间的良性互动。像状态空间规划器FF一样，VHPOP利用轻松的规划图来提取</span><em><span>hadd</span></em><span>的数据。</span></p><p><span>虽然这些启发式方法可以帮助</span><em><span>计划选择</span></em><span>，但VHPOP还提供了强大的启发式方法来进行</span><em><span>缺陷选择</span></em><span>：除了现有策略的实现之外，例如DUnf和DSep（Peot和Smith，1993），LCFR（Joslin和Pollack，1994）和ZLFIO（Schubert和Gerevini， 1995年），VHPOP引入了新颖的缺陷选择策略：“ </span><em><span>静态优先”可</span></em><span>有效处理静态开放条件，</span><em><span>LCFF-Loc</span></em><span>允许局部缺陷选择，这使计划人员对操作员规范中的前提条件不太敏感，以及几种由冲突驱动的缺陷部分策略引入这些假设的前提是，那些封闭时会受到威胁的开放条件应得到更高的优先处理（Younes和Simmons，2003年）。</span></p><p><span>此外，VHPOP扩展了POP框架以处理PDDL 2.1级别3所指定的持续性操作，在打开的条件上附加了时间注释，以告知计划者条件必须在哪个时间保持。</span></p><h2><a name="4.4%E8%A7%84%E5%88%92%E4%B8%BA%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7" class="md-header-anchor"></a><span>4.4规划为可满足性</span></h2><p><em><span>作为可满足性</span></em><span>方法的</span><em><span>计划</span></em><span>背后的思想是将计划问题表示为存在强大的问题解决算法的推理问题。</span></p><h3><a name="4.4.1%E8%A7%84%E5%88%92%E4%B8%BA%E5%91%BD%E9%A2%98%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7" class="md-header-anchor"></a><span>4.4.1规划为命题可满足性</span></h3><p><span>传统上，规划的逻辑方法是</span><em><span>推论</span></em><span>（例如（Green，1969； McCarthy and Hayes，1987； Rosenschein，1990）），即寻找证明初始条件和领域公理（定义了语义）的证明。操作员）和某些行动顺序暗示着目标情况（以逻辑公式表示）。这样一个定理的证明是逻辑定理的任何有效实例，并且可以从这样的实例中提取动作序列。</span></p><p><span>但是，在（Kautz和Selman，1992）中，提出了通过</span><em><span>满意度</span></em><span>检查进行规划的方法。在这种方法中，计划问题不是要证明的定理，而是被公式化为一组公理，其性质是公理的</span><em><span>任何</span></em><span>模型都对应于有效计划。通过制作排除意外（异常）模型的公理可以实现此属性，例如，需要公理来明确排除未满足其先决条件的情况下执行操作的可能性。</span></p><p><span>此外，公理不包含量化或项，并且所有谓词都具有尾随参数，该参数需要时间。例如[ </span><a href='#'><span>6 </span><span>]</span></a><span>，在公知的块世界（Gupta和瑙，1992），实现的规划问题</span><em><span>上</span></em><span>（</span><em><span>B，A</span></em><span>从初始情况）</span><em><span>上</span></em><span>（</span><em><span>A，B</span></em><span>）∧ </span><em><span>上</span></em><span>（</span><em><span>B，表</span></em><span>）将是表示为：</span></p><p><em><span>上</span></em><span>（</span><em><span>A，B，</span></em><span> 1）∧ </span><em><span>上</span></em><span>（</span><em><span>B，表，</span></em><span> 1）∧ </span><em><span>清晰</span></em><span>（</span><em><span>A，</span></em><span> 1）∧ </span><em><span>上</span></em><span>（</span><em><span>B，A，</span></em><span> 3）</span></p><p><span>此外，将</span><em><span>移动</span></em><span>运算符的语义（前提和效果）形式化为：</span></p><p><span>∀ </span><em><span>X，Y，Z，i.move</span></em><span>（</span><em><span>X，Y，Z，I</span></em><span>）⊃（</span><em><span>清晰</span></em><span>（</span><em><span>X，I</span></em><span>）∧ </span><em><span>清晰</span></em><span>（</span><em><span>Z，I</span></em><span>）∧ </span><em><span>上</span></em><span>（</span><em><span>X，Y，I</span></em><span>））</span></p><p><span>需要使用其他公理来确保在一个时间步中仅执行一项操作。在此示例中，唯一满足公理化计划问题的模型是：</span></p><p><span>{ </span><em><span>move</span></em><span>（</span><em><span>A，B，Table，</span></em><span> 1）</span><em><span>，move</span></em><span>（</span><em><span>B，Table，A，</span></em><span> 2）}</span></p><p><span>这是预期的模型，可以用作代理的计划。可以使用诸如Davis-Putnam程序之类的可满足性决策程序或诸如GSAT之类的随机程序来构建模型（Selman等，1992）。另一个例子是WalkSAT，也称为WSAT（Selman等，1993）。</span></p><p><span>事实证明，这种规划方法具有很高的竞争力（Kautz和Selman，1996）。基于这种技术的计划程序是Satplan（Kautz和Selman，1992）和后继Blackbox（Kautz和Selman，1998a），它们将Satplan与Graphplan的思想相结合。两种系统在国际计划竞赛中均表现出色。</span></p><p><span>LGP系统（Gerevini和Serina，2002）及其后继者LGP-td（Gerevini等，2004）也采用了类似的方法。两者均基于WalkSAT，但结合了最佳优先搜索算法，并使用规划图进行搜索启发式。</span></p><p><span>除了表现出色之外，基于SAT的计划还有另一个优势：由于在此框架中对状态进行了显式建模（原子的尾随参数），因此很容易提出对状态的要求，如（Huang et al。，1999; Kautz和Selman，1998b）。反过来，这对于表达本节中讨论的复杂目标很有用。3.3。</span></p><h3><a name="4.4.2%E8%A7%84%E5%88%92%E6%8F%8F%E8%BF%B0%E9%80%BB%E8%BE%91%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7" class="md-header-anchor"></a><span>4.4.2规划描述逻辑可满足性</span></h3><p><span>（Berardi et al。，2003）提出了另一种将计划任务表示为逻辑可满足性问题的方法。更准确地说，本文集中讨论自动Web服务组合的问题。在这种方法中，“目标逻辑”不是命题逻辑，而是描述逻辑ALU。</span></p><p><span>该方法定义了一个Web服务</span><em><span>社区</span></em><span>，该</span><em><span>社区</span></em><span>的特征在于一组通用的操作（称为社区的字母）和一组根据该通用操作指定的Web服务。服务提供的交互协议表示为</span><em><span>执行树</span></em><span>，其中每个节点代表客户端-服务器交互中的可能状态，每个边缘代表客户端遵循该协议调用的操作。现在，Web服务组合问题是要确定由社区中服务的动作组成的执行树，该树与给定的所需执行树相对应。</span></p><p><span>构造这样一棵树的任务让人想起生成描述逻辑概念的模型以证明其可满足性（或不可满足性）的任务：为了利用此属性，Web Service域和计划问题是从情境演算表示形式转换而来的。到ALU，然后可以使用任何高效的基于表格的描述逻辑推理器（例如（Volker Haarslev，2001; Horrocks，1999））来生成可满足性检查的树模型，从中综合过程（如果它的存在）可以直接提取。</span></p><h3><a name="4.4.3%E8%A7%84%E5%88%92%E4%B8%BApetri-net%E5%8F%AF%E8%BE%BE%E6%80%A7" class="md-header-anchor"></a><span>4.4.3规划为Petri-Net可达性</span></h3><p><span>（Narayanan and McIlraith，2002）提出了另一项工作，该工作以基于情境演算的规划问题的公理化开始，然后将其转化为一个知名的正式框架：本文建议可以执行Web服务规划任务在Petri网</span><em><span>可达性分析</span></em><span>的概念下（Petri，1962）。这个想法是基于原子Web服务创建一个Petri网，该Petri网表示原子操作的所有可能组合，并将所需目标指定为该Petri网的状态（即令牌的配置）。然后，可以使用标准Petri网技术（其中包括可满足性检查）来确定此目标状态是否可以达到。这些技术也可以用来验证计划是否格式正确（Narayanan和McIlraith，2002）。</span></p><h2><a name="4.5%E4%BD%9C%E4%B8%BA%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B%E8%BF%9B%E8%A1%8C%E8%A7%84%E5%88%92" class="md-header-anchor"></a><span>4.5作为逻辑编程进行规划</span></h2><p><span>提出了一种将计划领域的行为定律编码为逻辑表示形式的方法的另一种方法是计划形式</span><em><span>逻辑编程</span></em><span>方法，该形式可以修改为形式推理方法。</span></p><p><span>一个逻辑程序由一组格式为</span><em><span>A</span></em><span> ← </span><em><span>B</span></em><span> 1 </span><em><span>，...，Bn</span></em><span>的Horn子句组成。每一个这样的喇叭子句也可以解释为文字的析取与至多一个正文字，即</span><em><span>甲</span></em><span> ∨¬ </span><em><span>乙</span></em><span> 1∨ </span><em><span>...</span></em><span> ∨¬ </span><em><span>BN</span></em><span>。逻辑程序中的负性通常表示为“ </span><em><span>失败时否定”</span></em><span>（NAF），这使它们成为非单调的。</span></p><p><span>逻辑编程（LP）与计划之间的关系以及作为逻辑程序的计划问题的编码已在文献中进行了广泛研究，例如（Gelfond and Lifschitz，1993; Turner，1997; Lifschitz，1999）。</span></p><p><span>虽然演绎推理的直接应用，如Prolog的SLD似乎是不言而喻的，但作为LP方法的规划的许多进展已通过使用其他方法获得了启发（Subrahmanian和Zaniolo，1995）。（Subrahmanian和Zaniolo，1995）表明，计划问题可以在线性时间内转换为逻辑程序，这样，只要且仅当相关目标</span><em><span>G</span></em><span> ∗ 在逻辑的某个</span><em><span>稳定模型</span></em><span>中为真时，才能在计划范围内实现给定目标</span><em><span>G</span></em><span>通过转换获得的程序；目标</span><em><span>G</span></em><span>＊也可以在线性时间内获得（Subrahmanian和Zaniolo，1995）。通过计算</span><em><span>答案集</span></em><span>可以有效地生成这些稳定的模型逻辑程序的代码，如在SMODELS之类的工具中实现的那样（Niemelae和Simons，1997）。（Dimopoulos et al。，1997）报告了这种方法的经验测试，并建议，如果对Logic程序进行适当的编码，其性能可以与Graphplan或Satplan等通用计划算法的性能保持同步。</span></p><p><span>逻辑编程的其他应用是Reiter对Golog的实现以及对情况演算的回归（Reiter，2001年）。还应该提到的是（Shanahan，2000），它提出了事件演算的逻辑编程编码。在Web服务组合领域，SWORD工具箱在（Ponnekanti和Fox，2002）中提出，它使用Prolog推理提供信息的服务，从而直接从Prolog解释器的执行跟踪中提取计划。</span></p><h1><a name="5%E5%85%B7%E6%9C%89%E6%8E%A7%E5%88%B6%E7%9F%A5%E8%AF%86%E7%9A%84%E8%AE%A1%E5%88%92" class="md-header-anchor"></a><span>5具有控制知识的计划</span></h1><p><span>尽管上一节中描述的许多计划者的性能令人印象深刻，但许多研究人员认为，有必要为计划代理提供领域或任务相关的控制知识，以便在实际中实现良好的性能。世界域。</span></p><p><span>在以下各节中，我们将简要回顾计划技术，这些技术允许以一种或另一种方式合并和利用与领域或任务相关的控制知识。</span></p><h2><a name="5.1%E5%88%86%E5%B1%82%E4%BB%BB%E5%8A%A1%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92" class="md-header-anchor"></a><span>5.1分层任务网络规划</span></h2><p><span>分层任务网络（HTN）计划最早是在早期的Abstrips（Sacerdoti，1973）计划系统中引入的，随后是NOAH和其他一些计划者。在（Erol et al。，1994b; Erol et al。，1994a）中给出了正式的语义。</span></p><p><span>HTN规划提供了层次抽象，这是一种强大的策略，可以处理大型和复杂的现实世界规划域的复杂性。像其他计划范式一样，当HTN计划的先决条件在执行之前直接成立时，它们会假设一组操作符会实现某些已定义的效果。但是，除了操作（在HTN计划中称为</span><em><span>原始任务</span></em><span>）之外，HTN计划还支持一组</span><em><span>方法</span></em><span>，其中每种</span><em><span>方法</span></em><span>都是如何将某些任务分解为一组子任务的处方。这样的方法描述代表了公共</span><em><span>领域的知识</span></em><span>，或者如果从计划者的角度来看，则代表</span><em><span>计划的片段</span></em><span>。</span></p><p><span>根据（Erol et al。，1994b）中的定义，HTN规划中有三种类型的目标：（i）目标任务，它们是最终状态的期望属性，就像在大多数其他规划范式中一样，（ii）已经提到的原始任务，以及（iii）复合任务，表示涉及几个目标任务和原始任务的所需更改。</span></p><p><span>最近受到广泛关注的HTN计划的一种变体是</span><em><span>有序任务分解</span></em><span>计划，其中代理按与执行任务相同的顺序计划任务，这大大降低了计划问题的复杂性。基于该原理的计划者，例如SHOP（简单的分层有序计划者）（Nau等，1999）接受目标作为任务列表，其中复合任务可以由复合任务或原始任务组成。目标任务不受支持。因此，有序任务分解系统不计划实现定义的（声明性）目标，而是执行给定的（复杂或原始的）任务。</span></p><p><span>这种基于HTN的计划系统将所需任务分解为一组子任务，然后将这些任务分解为另一组子任务（依此类推），直到最终的任务集仅包含可以执行的原始任务为止直接调用原子操作。在每轮任务分解过程中，将测试是否违反了某些给定条件。如果将所需的复杂任务分解为一组原始任务而又不违反任何给定条件，则可以成功解决计划问题。</span></p><p><span>在（Hendler等人，2003）中提出了一种在Web服务领域中使用HTN规划的方法，以促进SHOP2系统（Nau等人，2003），该系统属于</span><em><span>有序任务分解</span></em><span>家族。我们上面描述的计划者。论文（Hendler等，2003； Wu等，2003）提出了一种将OWL-S流程转换为分层任务网络的方法。像HTN任务网络一样，OWL-S流程是为完成特定任务而要执行的操作的预定义描述，这使得转换相当自然。这种方法的优点是能够处理非常大的问题域。但是，需要明确为计划者提供需要完成的任务，这可能被视为不利条件，因为这需要在动态环境中可能并不总是可用的描述。</span></p><h2><a name="5.2%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C" class="md-header-anchor"></a><span>5.2高级程序执行</span></h2><p><span>在经典的计划方法中，计划是在给出领域描述和计划目标的情况下综合而成的，计划者必须在其中寻找通常通常非常大的可能性空间，以找到适当的计划问题解决方案。另一种方法是</span><em><span>高级程序执行</span></em><span>；这种方法背后的思想是，与其寻找满足声明性目标的一系列动作，不如找出一系列构成</span><em><span>合法执行</span></em><span>的动作序列给定的高级程序。在规划中，有必要对域运营商的先决条件和影响进行推理，以找出可以详细应用哪些操作。如果高层计划是详细制定的，并且是确定性制定的，那么就没有太多的理由要执行了；否则，当程序的制定不详细时，如果它使用不确定的控制结构，则搜索任务开始类似于传统的计划（Giacomo等，2000）。</span></p><p><span>Golog（LOGic中的alGOL）（Levesque等人，1997）语言是一种高级编程语言，它是专为在动态域中指定和执行复杂动作而设计的。此外，它是基于逻辑的，这意味着Golog程序可修改为正式的验证程序，并且可以通过逻辑工具（如定理证明）来执行基于Golog的计划问题。</span></p><p><span>Golog基于情境演算（请参阅第3.1节），它是由（McCarthy，1963）引入的，从那时起，它通常被用作提供动态系统形式化描述的一种手段。尽管对情境演算的早期处理可以识别具有状态的情境，即在瞬间对宇宙进行描述（McCarthy和Hayes，1969），但最近的形式化处理（Levesque等，1998； Pirri和Reiter，1999）。情境演算可识别具有世界历史的情境。世界的所有变化都是命名动作的结果。情况是可能的世界历史，是由一系列操作引起的，并表示为一阶条件。常数</span><em><span>S</span></em><span> 0表示</span><em><span>初始情况</span></em><span>，即动作的空序列。函数</span><em><span>做</span></em><span>（</span><em><span>α，s</span></em><span>）表示由于在状况</span><em><span>s中</span></em><span>执行动作</span><em><span>α</span></em><span>而产生的状况。动作被写为函数，并且可以被参数化。例如，函数</span><em><span>paint</span></em><span>（？</span><em><span>o，</span></em><span>？</span><em><span>c</span></em><span>）可能代表绘制一个对象？</span><em><span>Ø</span></em><span>颜色？</span><em><span>c</span></em><span>，在这种情况下，</span><em><span>do</span></em><span>（</span><em><span>paint</span></em><span>（</span><em><span>Door，Red</span></em><span>）</span><em><span>，s</span></em><span>）将表示由于将</span><em><span>门</span></em><span>涂成红色而导致的情况。表达式</span><em><span>do</span></em><span>（</span><em><span>putDown</span></em><span>（</span><em><span>Red</span></em><span>）</span><em><span>，do</span></em><span>（</span><em><span>paint</span></em><span>（</span><em><span>Door，Red</span></em><span>）</span><em><span>，do</span></em><span>（</span><em><span>pickUp</span></em><span>（</span><em><span>Red</span></em><span>）</span><em><span>，S</span></em><span> 0）））表示在情况</span><em><span>S</span></em><span> 0中执行</span><em><span>pickUp（Red）</span></em><span>，然后执行</span><em><span>paint（Door，Red）</span></em><span>，接着是</span><em><span>putDown（Red）导致的情况</span></em><span>。</span></p><p><span>Golog通过提供一组额外的逻辑构造来构建情境演算之上，这些构架充当情境演算语言中逻辑表达式的</span><em><span>缩写</span></em><span>。缩写</span><em><span>Do</span></em><span>（</span><em><span>δ，s，s</span></em><span> 0）</span><em><span>宏扩展</span></em><span>为一种情境演算公式，该公式表示可以通过执行由</span><em><span>δ</span></em><span>指定的一系列动作从情境</span><em><span>s</span></em><span>达到情境</span><em><span>s</span></em><span> 0，这是一个复杂的动作表达式。Golog提供以下宏可扩展的语言构造：原始动作，测试动作，序列，两个动作的不确定性选择，动作参数的不确定性选择和不确定性迭代（while循环）。Golog还允许定义（可能是递归的）过程（Reiter，2001）。</span></p><p><span>给定基于情境演算的领域公理化</span><em><span>公理</span></em><span>，初始情境</span><em><span>S</span></em><span> 0和Golog程序</span><em><span>δ</span></em><span>，计划（即程序执行）任务可以表示为以下定理证明任务（Reiter，2001）：</span></p><p><em><span>公理</span></em><span> `（∃ </span><em><span>š</span></em><span>）</span><em><span>待办事项</span></em><span>（</span><em><span>δ，S</span></em><span> 0 </span><em><span>，S</span></em><span>）</span></p><p><span>换句话说，规划有识别情况</span><em><span>小号</span></em><span>为其宏扩展是从公理证明的。实例</span><em><span>小号</span></em><span>作为证明的副作用获得的，并且从该实例中的动作序列</span><em><span>〜一个</span></em><span>可以被提取，使得</span><em><span>公理</span></em><span> | = </span><em><span>待办事项</span></em><span>（</span><em><span>δ，S</span></em><span> 0 </span><em><span>，做</span></em><span>（</span><em><span>〜A，S</span></em><span>））成立，其中</span><em><span>〜一</span></em><span>简写</span><em><span>做</span></em><span>（</span><em><span>一个，做</span></em><span>（</span><em><span>一个</span></em><span> -1 </span><em><span>，...，做</span></em><span>（</span><em><span>一个</span></em><span> 1 </span><em><span>，S</span></em><span> 0）））。（Levesque等，1997）提出了基于Prolog的Golog解释器的实现。</span></p><p><span>能够处理并发性的Golog的一个变体是ConGolog（并发性Golog）（Giacomo等人，2000年）：它允许并发进程，从而通过在组件进程中插入原子动作来建立并发。它还支持中断（例如，当在电梯中按下警报按钮时处理情况）和外部动作，即可能与程序并行发生但不受解释器控制的动作。（Giacomo等，2000）介绍了基于Conlog的基于Prolog的解释器。</span></p><p><span>在（McIlraith and Son，2001； McIlraith and Son，2002）中，将ConGolog的修改版本应用于Web服务组合问题。ConGolog解释器的扩展功能包括自定义用户约束，Golog序列构造的更灵活变体以及将感应动作实现为外部函数调用的能力。在（Narayanan和McIlraith，2002）中，给出了从OWL-S到情境演算和Golog的正式转换。在这种情况下，OWL-S流程可以用作要执行的所需流程的规范，以及Web服务所提供的原子性和复杂动作的描述。然后，Web服务组合问题将是查找确实满足目标中定义的属性的Golog程序的执行。</span></p><h2><a name="5.3%E8%A7%84%E5%88%92%E4%BD%9C%E4%B8%BA%E6%A8%A1%E5%9E%8B%E6%A3%80%E6%9F%A5" class="md-header-anchor"></a><span>5.3规划作为模型检查</span></h2><p><span>将计划作为模型检查方法最早是在（Cimatti等，1997； Giunchiglia和Traverso，1999）中提出的，它把计划问题表述为语义模型检查问题。模型检查是一种形式验证技术，它可以确定属性是否在形式化为有限状态模型的特定系统中拥有。此技术用于硬件和软件系统的验证，以正式说明系统的行为，例如，系统永远不会达到某个不需要的状态（安全性），或者保证一定程度上达到某个状态。点（活力）。例如，SPIN模型检查器用于验证NASA DEEP SPACE 1任务中的多线程计划执行模块，并发现了五个以前未知的并发错误（Havelund等，2001）。更一般地说</span></p><p><span>1991）。</span></p><p><span>通过模型检查（PBM）进行规划在语义上具有良好的基础，并且能够处理不确定性，部分可观察性和扩展目标。在PBM中，计划域被形式化为非确定性状态转换系统，其中动作是一种转换，可能会将系统从一个状态转换为一组可能的后续状态。与其他计划方法一样，计划目标可以表示为对所需目标状态的约束；另外，可以通过关于</span><em><span>计划本身的</span></em><span>属性的声明来扩展目标，例如通过CTL（计算树逻辑）时间公式（Emerson，1990）或使用最近提出的Eagle（Lago等，2002）语言。</span></p><p><span>PBM方法的基本思想是通过确定目标公式在模型中是否成立来生成计划，从而通常将模型形式化为Kripke结构。由PBM生成的计划是“情境计划”（Georgeff和Lansky，1990），是由反应性代理执行的计划，在每个迭代循环中，反应性代理都会确定其所处的状态，然后应用计划为该州预见的行动。为了更正式地说明这一点，请考虑一个规划域Σ=（</span><em><span>S，A，γ</span></em><span>），其中</span><em><span>S</span></em><span>是状态的有限集合，</span><em><span>A</span></em><span>是动作的有限集合，并且</span><em><span>γ</span></em><span>：</span><em><span>S</span></em><span> × </span><em><span>A</span></em><span> →2 </span><em><span>s</span></em><span>是不确定状态转换函数。现在，一个有效的PBM生成的计划</span><em><span>π</span></em><span>，也叫</span><em><span>政策</span></em><span>对这一规划领域Σ，是一组对（</span><em><span>S，A</span></em><span>），使得</span><em><span>S ^</span></em><span> ∈ </span><em><span>小号</span></em><span>和</span><em><span>一</span></em><span> ∈ </span><em><span>一</span></em><span>（</span><em><span>小号</span></em><span>）。据需要，对于任何状态</span><em><span>小号</span></em><span>存在（至多）一个动作</span><em><span>一个</span></em><span>使得（</span><em><span>S，A</span></em><span>）＆Element; </span><em><span>π</span></em><span>。</span></p><p><span>由于PBM域中允许使用不确定性，因此解决方案的定义与经典规划假设下解决方案的定义不同。根据解决方案固有的偶然性，它可以是</span><em><span>弱</span></em><span>，</span><em><span>强</span></em><span>或</span><em><span>强循环的</span></em><span>：弱解决方案是可以实现目标但不能保证达到目标的解决方案。无论域的不确定性如何，都可以保证有一个强大的解决方案可以实现目标。一个强力的循环解决方案是保证达到目标的一种方法，如果给出了</span><em><span>公平性假设</span></em><span>，该状态说明了解决方案所预期的循环最终将终止（Giunchiglia and Traverso，1999）。</span></p><p><span>类似地，已经提出了几种算法，它们能够构造弱循环（例如（Cimatti等，1997），强循环（例如（Daniele等，2000））或强循环（例如（Cimatti等，1998））。 ）解决方案。这些算法的共同点是它们总是终止。</span></p><p><span>由于实际问题涉及可能包含大量状态的模型，因此这些算法的实际实现通常采用</span><em><span>符号模型检查</span></em><span>（Burch等人，1990）。在“符号模型检查”中，Kripke结构的可能状态集和状态之间的过渡关系用</span><em><span>符号</span></em><span>表示，通常使用表示状态命题真值的变量向量，从而更简洁，更少冗余地表示状态，并有效地应用集合理论和逻辑运算。通过搜索状态集而不是单个状态来执行计划，计划本身以公式表示。符号模型检查的表示和推理技术的实际实现通常使用二进制决策图（BDD）进行（Bryant，1986）。</span></p><p><span>基于BDD的MIPS（Edelkamp and Helmert，2000）是“模型检查计划”方法的一种实现。MIPS的主要优势在于其预编译阶段，该阶段可识别隐式领域知识，例如状态不变式，该知识在正确编码后可以缩短状态描述的长度。此外，MIPS实现了许多新颖的技术来提高BDD遍历的效率（Edelkamp和Helmert，2000）。</span></p><p><span>确定性领域的其他PBM实现方法是Proplan（Fourman，2000年）和BDDPlan（Holldobler和Storr，2000年）。但是，它们缺少类似于MIPS的预编译阶段，因此无法在较大的域中达到MIPS的高性能。</span></p><p><span>虽然MIPS，Proplan和BDDPLan是为</span><em><span>确定性</span></em><span>领域设计的，但已经设计了MBP（基于模型的计划器）（Bertoli等人，2001）和UMOP（基于通用多代理基于对象的计划器）（Jensen和Veloso，2000）等系统。利用模型检查的主要优点，即处理不</span><em><span>确定性</span></em><span>环境：MBP可以处理初始情况，动作效果和动作执行状态的不确定性。它使用自己的动作描述语言NuPDDL，它是PDDL 2.1的变体，可以表达初始状态中的不确定性，不确定的动作效果和不完美的感应动作。</span></p><p><span>同样，UMOP使用其自己的域描述语言NADL（非确定性代理域语言）；NADL问题和域规范被转换为以OBDD表示的符号Kripke结构（Bryant，1986）。</span></p><h2><a name="5.4%E6%97%B6%E9%97%B4%E8%A7%84%E5%88%92" class="md-header-anchor"></a><span>5.4时间规划</span></h2><p><span>术语“时间规划”在狭义上并不一定指特定的规划技术，而是指规划人员处理规划领域和问题的</span><em><span>时间方面</span></em><span>的能力。大多数计划范式已经以某种方式扩展以支持计划的某些时间方面。这样的时间方面的示例是：</span></p><p><span>•持续性行动：在经典计划方法中，行动通常被形式化为没有时间扩展。但是，在许多领域中，动作的持续时间至关重要。因此，效果器的精确时间安排和时间高效的计划对于计划者来说很重要。</span></p><p><span>•命题的有效期间隔：在经典计划中，命题保持不变，直到代理人使用运算符将其明确更改为止。在现实世界中，许多流利的语言依赖于时间。例如，访问Web服务的权限可能仅在定义的时间间隔内有效。</span></p><p><span>•并发动作：经典计划通常假定一次只执行一个动作。持久性有机污染物及其部分有序的计划似乎是一个例外，但这并不是故意寻求此类计划中行动的时间并发性。这仅表示这些操作是独立的，没有发现除并发以外的任何限制。但是，有些问题</span><em><span>要求</span></em><span>必须同时执行两个动作，因为顺序操作不会产生期望的结果。</span></p><p><span>•时间扩展目标的规范（Bacchus和Kabanza，1996），该目标不仅表达了实现某个最终状态的经典目标，而且还表达了一组可接受</span><em><span>的状态序列</span></em><span>。暂时扩展目标还可能会扩展临时期限，安全和维护目标（Weld和Etzioni，1994； Penberthy和Weld，1992）。</span></p><p><span>早期计划者已经解决了</span><em><span>持续</span></em><span>性行为问题，例如部分订单计划者NONLIN（Tate，1977）和分层SIPE（Wilkins，1988）计划者，并且最近的计划者如VHPOP（Younes and Simmons，2003）也解决了这个问题。 ，LPG（Gerevini和Serina，2002）和MIPS（Edelkamp和Helmert，2000）。</span></p><p><em><span>暂时扩大目标</span></em><span>TLPlan（Bacchus和Kabanza，1995； Bacchus和Ady，2001）系统已经解决了该问题，该系统支持在度量间隔时间逻辑（MITL）扩展版本中指定的目标（Alur等，1996）。TLPlan基于前向链接计划引擎。通常，前向链规划师（或一般来说，状态空间规划师）通过确定状态的启发式值来评估状态对预期目标的贡献（参见第4.1节）。TPLan采用了不同的方法。它将每个状态视为数据库，并根据目标公式的逆公式进行检查，并修剪满足该公式的每个状态，因为这意味着它违反了所需目标的属性。应该注意的是，时间扩展目标公式的概念可以扩展为</span><em><span>域控制知识</span></em><span>，它通过指定要识别的状态的期望或不期望属性来编码对计划者的提示。</span></p><p><span>TLPlan的后继产品是TALPlanner（Kvarnstrom和Haslum，2001），与TLPlan一样，它是基于正向搜索的，但是使用TAL语言而不是MITL来指定计划目标和域控制知识。TAL是基于叙事的线性度量时间逻辑，用于推理不完整指定的动态环境中的动作和更改。TAL目标（或控制）公式输入到TALplanner，然后生成包含目标（或控制）公式的解决方案。</span></p><h1><a name="6%E8%AE%A8%E8%AE%BA%E4%B8%8E%E5%B1%95%E6%9C%9B" class="md-header-anchor"></a><span>6讨论与展望</span></h1><p><span>现在，我们将回顾我们先前讨论的最重要的需求，并将它们与一系列最新的计划系统进行对比。我们针对问题场景（参见第2节）确定的核心要求是：</span></p><p><span>\ 1。该</span><em><span>域名的复杂性</span></em><span>应该支持ADL的显著子集：例如，需要普遍量化效应来描述Web服务，与多个对象处理（例如，用来删除虚拟购物车的所有项目的操作）。还需要显式标记传感动作和不确定的服务结果。</span></p><p><span>\ 2。支持</span><em><span>复杂的目标</span></em><span>（参见第3.3节），即“提示”，告诉计划者哪些行动应先于其他行动。几乎所有复杂的问题都需要这样做，例如在比较购物中，解决方案是三个不同阶段的序列（获取报价，做出决定，进行购买）。</span></p><p><span>\ 3。如前所述，处理</span><em><span>不完整信息</span></em><span>的能力（参见第3.2节），例如查询Web购物域中的目录，是大多数Web服务域的核心要求。反过来，这又需要支持</span><em><span>感知</span></em><span>行为的支持，这些行为可以帮助代理获取所需数据（例如，一种返回在线零售商销售产品清单的方法）</span></p><p><span>\ 4。与支持感测动作的问题相关的是，计划人员具有向域（或从域</span><em><span>）动态添加（或删除）对象</span></em><span>的能力，例如，添加有关从感测动作查询的产品信息的知识，或对文件副本进行适当建模的能力。功能在文档处理领域。</span></p><p><span>\ 5。最后，强烈需要处理服务的</span><em><span>不确定性行为</span></em><span>：Web服务操作在执行期间可能会失败，或者会产生意外或不希望的结果；例如，旅行域中的一家航空公司可能会突然空余座位（可能违反了IRP假设），或者在电子邮件复制方案中进行图像转换操作可能会失败。</span></p><p><span>在表1和表2中，我们将代表性计划制定者的实现与我们为WSC问题提出的核心要求进行了对比。选项卡中列出的计划者。1是基于我们在Sect中讨论的技术的新古典主义[ </span><a href='#'><span>7 </span><span>]</span></a><span>规划师。4，工具和选项卡中列出。图2是本节中讨论的具有控制知识的规划方法的实现。5，</span></p><p><span>表1显示，我们列出的大多数新古典主义计划者都允许对必要复杂性（即ADL的重要子集）进行域描述。但是，除了SGP可以为不完整的初始状态和检测操作提供支持外，所有这些计划人员都不支持WSC的其余要求。</span></p><p><span>另一方面，使用域控制知识的计划人员可以为我们的需求提供更广泛的支持：他们支持复杂的领域，并且也允许复杂的目标。例如，MBP允许定义时间扩展的目标，而Golog以类似于程序的方式表示目标，包括分支和迭代。因此，可以通过提供应急处理代码来解决不确定性领域（例如，不确定性迭代，迫使计划者继续循环单元，以实现某些操作的预期效果）。</span></p><p><span>这是否意味着WSC问题已经由具有控制知识的计划者解决，并且新古典主义的计划者不能用于此任务？</span></p><p><span>我们认为并非如此：虽然很明显领域知识是解决WSC问题的关键，但尚不清楚</span><em><span>哪种</span></em><span>形式的领域知识最适合，以及</span><em><span>如何</span></em><span>应该对其进行收集和编码。在这里，诸如接受目标开发者社区之类的“软需求”也很重要。（Hendler et al。，2003）行使的将先前存在的过程描述（在OWL-S中）转换为域控制信息（HTN方法）的想法似乎是一种合理的方法：它不需要开发人员采用新的逻辑基于语言的语言，但允许他们使用广泛的过程工程技能。但是，（Hendler等，2003）使用了HTN计划的受限变体，即有序任务分解计划，它不支持声明性目标任务。这意味着代理仅依赖于其给出的任务列表，而不是试图自行寻找“创造性”的解决方案。同样，由于</span><em><span>代理</span></em><span>不调用感测动作确定感测的需求；而是在任务列表中显式预定义了感应动作。尽管对于许多领域来说这是一种有用且实用的方法，但我们认为寻找替代方法以使代理方面具有更大的灵活性，例如处理尚不存在预定义策略的情况，仍然很有趣。</span></p><p><span>此外，Tab的领域独立的新古典规划者。1远非适用于WSC问题。但是，需要一种适当的体系结构，该体系结构允许将规划问题分解为与新古典规划者的能力相匹配的一系列子问题。</span></p><p><span>一个例子是执行监视和重新计划架构（例如（Haigh，1998）），其中控制器组件将问题转换为一系列更简单的计划问题，并使用计划执行的反馈信息更好地告知嵌入式计划者启发式方法（ s）。由于计划问题被分解为一系列计划问题，因此动态对象创建和销毁的问题消失了（因为在每个步骤中都重新创建了世界），并且甚至对于非正式计划的非正式计划者，也可以进行感知动作的计划（Peer，2004a）中所述。</span></p><p><span>最后，还有许多未解决的问题，这些问题一旦解决，无论采用何种计划方法，都可能会非常有帮助。一个核心问题是</span><em><span>自动域分析</span></em><span> ; 在本次调查中，我们讨论了由于在预处理阶段</span><em><span>自动</span></em><span>收集的领域知识（例如STAN，MIPS）而超过了其直接竞争的几种计划实施方式。因此，确定从Web服务域收集有用的控制知识的方法似乎是一项值得的工作。类似地，可以考虑应用</span><em><span>学习技术</span></em><span>（例如基于来自较早运行的反馈）来改善代理的计划试探法。</span></p><p><strong><span>致谢</span></strong></p><p><span>这项工作得到了欧盟委员会和瑞士联邦教育与科学办公室在第六框架计划REWERSE编号506779中的支持，并得到了瑞士国家科学基金会的200021-104009合同的支持。作者要感谢Juergen Zimmer，Drew McDermott和Maja Vukovic的评论和宝贵的反馈。</span></p><p>&nbsp;</p><p><span> </span></p></div>
</body>
</html>