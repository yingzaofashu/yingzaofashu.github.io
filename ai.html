<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>ai</title><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none 0s ease 0s; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }


html { font-size: 19px; }
html, body { margin: auto; background: rgb(254, 254, 254); }
body { font-family: Vollkorn, Palatino, Times; color: rgb(51, 51, 51); line-height: 1.4; text-align: justify; }
#write { max-width: 960px; margin: 0px auto 2em; line-height: 1.53; padding-top: 40px; }
#write > h1:first-child, h1 { margin-top: 1.6em; font-weight: normal; }
h1 { font-size: 3em; }
h2 { margin-top: 2em; font-weight: normal; }
h3 { font-weight: normal; font-style: italic; margin-top: 3em; }
h1, h2, h3 { text-align: center; }
h2::after { border-bottom: 1px solid rgb(47, 47, 47); content: ""; width: 100px; display: block; margin: 0px auto; height: 1px; }
h1 + h2, h2 + h3 { margin-top: 0.83em; }
p, .mathjax-block { margin-top: 0px; }
ul { list-style: square; padding-left: 1.2em; }
ol { padding-left: 1.2em; }
blockquote { margin-left: 1em; padding-left: 1em; border-left: 1px solid rgb(221, 221, 221); }
code, pre { font-family: Consolas, Menlo, Monaco, monospace, serif; font-size: 0.9em; background: white; }
.md-fences { margin-left: 1em; padding-left: 1em; border: 1px solid rgb(221, 221, 221); padding-bottom: 8px; padding-top: 6px; margin-bottom: 1.5em; }
a { color: rgb(36, 132, 193); text-decoration: none; }
a:hover { text-decoration: underline; }
a img { border: none; }
h1 a, h1 a:hover { color: rgb(51, 51, 51); text-decoration: none; }
hr { color: rgb(221, 221, 221); height: 1px; margin: 2em 0px; border-top: 1px solid rgb(221, 221, 221); border-bottom: none; border-left: 0px; border-right: 0px; }
.ty-table-edit { background: rgb(237, 237, 237); padding-top: 4px; }
table { margin-bottom: 1.33333rem; }
table th, table td { padding: 8px; line-height: 1.33333rem; vertical-align: top; border-top: 1px solid rgb(221, 221, 221); }
table th { font-weight: bold; }
table thead th { vertical-align: bottom; }
table caption + thead tr:first-child th, table caption + thead tr:first-child td, table colgroup + thead tr:first-child th, table colgroup + thead tr:first-child td, table thead:first-child tr:first-child th, table thead:first-child tr:first-child td { border-top: 0px; }
table tbody + tbody { border-top: 2px solid rgb(221, 221, 221); }
.task-list { padding: 0px; }
.md-task-list-item { padding-left: 1.6rem; }
.md-task-list-item > input::before { content: "√"; display: inline-block; width: 1.33333rem; height: 1.6rem; vertical-align: middle; text-align: center; color: rgb(221, 221, 221); background-color: rgb(254, 254, 254); }
.md-task-list-item > input:checked::before, .md-task-list-item > input[checked]::before { color: inherit; }
.md-tag { color: inherit; font: inherit; }
#write pre.md-meta-block { min-height: 35px; padding: 0.5em 1em; }
#write pre.md-meta-block { white-space: pre; background: rgb(248, 248, 248); border-width: 0px 30px; border-top-style: initial; border-bottom-style: initial; border-top-color: initial; border-bottom-color: initial; border-image: initial; color: rgb(153, 153, 153); width: 100vw; max-width: calc(100% + 60px); margin-left: -30px; border-left-style: solid; border-left-color: rgb(248, 248, 248); border-right-style: solid; border-right-color: rgb(248, 248, 248); margin-bottom: 2em; margin-top: -1.33333rem; padding-top: 26px; padding-bottom: 10px; line-height: 1.8em; font-size: 0.76em; padding-left: 0px; }
.md-img-error.md-image > .md-meta { vertical-align: bottom; }
#write > h5.md-focus::before { top: 2px; }
.md-toc { margin-top: 40px; }
.md-toc-content { padding-bottom: 20px; }
.outline-expander::before { color: inherit; font-size: 14px; top: auto; content: ""; font-family: FontAwesome; }
.outline-expander:hover::before, .outline-item-open > .outline-item > .outline-expander::before { content: ""; }
#typora-source { font-family: Courier, monospace; color: rgb(106, 106, 106); }
.html-for-mac #typora-sidebar { box-shadow: rgba(0, 0, 0, 0.176) 0px 6px 12px; }
.cm-s-typora-default .cm-header, .cm-s-typora-default .cm-property, .CodeMirror.cm-s-typora-default div.CodeMirror-cursor { color: rgb(66, 139, 202); }
.cm-s-typora-default .cm-atom, .cm-s-typora-default .cm-number { color: rgb(119, 119, 119); }
.typora-node .file-list-item-parent-loc, .typora-node .file-list-item-time, .typora-node .file-list-item-summary { font-family: arial, sans-serif; }
.md-task-list-item > input { margin-left: -1.3em; margin-top: calc(1rem - 12px); }
.md-mathjax-midline { background: rgb(250, 250, 250); }
.md-fences .code-tooltip { bottom: -2em !important; }
.dropdown-menu .divider { border-color: rgb(229, 229, 229); }

 .typora-export li, .typora-export p, .typora-export,  .footnote-line {white-space: normal;} 
</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node'><p>&nbsp;</p><h2><a name="ai%E8%A7%84%E5%88%92%E4%B8%8B%E7%9A%84web%E6%9C%8D%E5%8A%A1%E7%BB%84%E5%90%88-%E4%B8%80%E9%A1%B9%E8%B0%83%E6%9F%A5" class="md-header-anchor"></a><span>AI规划下的Web服务组合-一项调查</span></h2><p><strong><span>摘要</span></strong></p><p><span>本文概述了人工智能（AI）规划技术，并讨论了它们在Web服务组合问题中的应用。</span></p><p><strong><span>目录</span></strong></p><p><strong><span>1简介和动机............................................ 3</span></strong></p><p><strong><span>2种情况......................................................  5</span></strong></p><p><strong><span>3初稿................................................ ......... 6</span></strong></p><p><a href='https://ziyanliupb.github.io/#'><span>3.1规范规划领域.................................... .. 6</span></a></p><p><a href='https://ziyanliupb.github.io/#'><span>3.2正式化初始世界................................. 9</span></a></p><p><a href='https://ziyanliupb.github.io/#'><span>3.3正式制定目标.......................................... 11</span></a></p><p><a href='https://ziyanliupb.github.io/#'><span>3.4代表计划.......................................................... 13</span></a></p><p><strong><span>4基本规划范式............................................. 14</span></strong></p><p><a href='https://ziyanliupb.github.io/#'><span>4.1基于状态空间的规划....................................14</span></a></p><p><a href='https://ziyanliupb.github.io/#'><span>4.2基于图的计划..................................... ........... 18</span></a></p><p><a href='https://ziyanliupb.github.io/#'><span>4.3部分订单优化计划................................. .... 22</span></a></p><p><a href='https://ziyanliupb.github.io/#'><span>4.4规划为可满足性.................................... ................. 26</span></a></p><p><a href='https://ziyanliupb.github.io/#'><span>4.4.1作为命题可满足性进行规划............................... 27</span></a></p><p><a href='https://ziyanliupb.github.io/#'><span>4.4.2规划描述逻辑可满足性............................... 28</span></a></p><p><a href='https://ziyanliupb.github.io/#'><span>4.4.3作为Petri网可达性进行规划.......................................29</span></a></p><p><a href='https://ziyanliupb.github.io/#'><span>4.5作为逻辑编程进行规划.................................. 30</span></a></p><p><strong><span>5具有控制知识的计划.................................... ........ 31</span></strong></p><p><a href='https://ziyanliupb.github.io/#'><span>5.1分层任务网络规划.................................... ................ 31</span></a></p><p><a href='https://ziyanliupb.github.io/#'><span>5.2高级程序执行............................................................ 33</span></a></p><p><a href='https://ziyanliupb.github.io/#'><span>5.3计划作为模型检查.................................... ..................... 36</span></a></p><p><a href='https://ziyanliupb.github.io/#'><span>5.4时间规划............................................... .......................... 39</span></a></p><p><strong><span>6讨论与展望.............................................. ......................... 41</span></strong></p><p>&nbsp;</p><h2><a name="1%E5%BC%95%E8%A8%80%E5%92%8C%E5%8A%A8%E6%9C%BA" class="md-header-anchor"></a><span>1引言和动机</span></h2><p><span>		</span><span>Web服务是可以使用标准协议在互联网上公开和调用的分布式软件组件。这一概念是微软，IBM和Sun等主要IT公司提出的，它是一种用于分布式计算的兼容Web的解决方案，具有开放的，完全规范和供应商中立的特性。</span>
<span>​</span><span>		</span><span>Web服务通过在异步上发送基于XML的消息来与客户端和其他Web服务进行通信。Web服务提供的操作的签名及其所支持的消息格式构成其接口。通常，使用某种Web服务描述语言WSDL（W3C，2002）的接口描述语言（IDL）来描述服务接口。</span>
<span>​</span><span>		</span><span>WSDL允许将服务类型(称为端口类型)的抽象描述与服务的具体实现分离。因此，一个端口类型描述可用于类似类型的多个服务。这允许定义标准化的服务接口，并且有共同兴趣的参与者可以在这些描述的语义上达成协议。基于这样的协议，可以使用Web服务来编写客户端应用程序，并且可以使用涉及BPEL4WS（IBM等，2002）过程描述语言的复杂服务来处理涉及多个服务的复杂过程。</span>
<span>​</span><span>		</span><span>当服务与初始协议背离时，这种方法的问题就出现了。例如，当服务改变其实现（例如，细化其服务提供）时，它的语义和语法接口可能会改变。由于语义和语法接口之间没有定义正式的机器解释关系，因此需要人工干预来确定服务是否仍然与约定的语义兼容。</span>
<span>​</span><span>		</span><span>解决这个限制的一种方法是，以一种形式化的机器可解释的方式(非常类似于语法接口)将服务的大部分语义写下来。这减少了对外部语义协议的依赖，而这些外部协议通常很难实现，必须针对特定的服务类型，并且在Web服务的每次修改之后都需要重新评估。相反，语义描述为软件代理提供了一种自主地推理服务的语义的方法，即其操作的前提条件和结果。。</span>
<span>​</span><span>		</span><span>在语义注释服务的环境中，需要实现某些目标的用户可以由软件代理来协助，该软件代理会自动识别并在必要时动态地构成服务以完成用户的目标，其可以明确地陈述或衍生自用户所处的情况。</span>
<span>​</span><span>		</span><span>然而，动态的服务组合是一个困难的问题，而且并不完全清楚哪种技术最适合这个问题。在这本文中提出的一系列的解决技术是人工智能(AI)规划。规划是一个复杂的问题， （罗素和诺维格，1995）将规划问题描述如下：“规划可以被解释为一种解决问题的方法，其代理使用其可能的操作及其结果的信度，在一组抽象的可能计划上确定解决的方案</span>
<span>​</span><span>		</span><span>最近，一些论文，例如（德莫特，2002； Sravasava和Koehler，2003； Carman等人，2003； SiRin和PARSIA，2004），已经研究了应用人工智能规划技术来获得实现预期目标的web服务流程的潜力和边界。在本报告中，我们的目标是通过对最重要的规划技术进行调查并讨论它们对动态Web服务组合的适用性来扩展这项研究。</span>
<span>​</span><span>		</span><span>文章的其余部分整理如下：第二部分，我们列出了我们收集的需求的场景。第三部分，讨论规划的相关概念框架。然后，我们在第四部分讨论了基本的规划范式，在第五部分讨论知识导向的规划范式。 然后，我们将一系列具有代表性的规划引擎与我们确定的核心需求进行对比，并讨论结果和未来工作的可能方向。</span></p><h2><a name="2-%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D" class="md-header-anchor"></a><span>2 场景介绍</span></h2><p><span>为了评估我们面临的各种潜在需求的潜力，我们考虑了以下Web服务领的集合：</span></p><p><span>•网上购物域（Peer-No.44B）：提供浏览目录和购买商品的服务集。可能的目标是找到并购买一个或多个产品，可能以最好的价格。</span></p><p><span>•文件处理域（对等体，No.44b），类似于（金，1997）中的软件机器人域：服务提供操作文件的功能，例如转换，压缩或加密文件。可能的目标是多种文档转换，例如转换和打包文档集合。</span></p><p><span>•邮件复制域（Vukovic和鲁滨孙，2004）：该域将电子邮件相关服务（即SOAP接口与SMTP和POP服务器）结合在文档处理域中的服务（见上文）。该领域中的典型目标是消息的发送和接收，以及其他相关的邮件系统的行为适应，例如某些和用户相关的显示，涉及文本翻译和图像转换服务。</span></p><p><span>•旅行域（McIlraith和儿子，2002）：在这个领域的服务提供查询和预订机票和住宿旅客的功能。该领域的一个典型问题是计划出席会议，这通常涉及满足用户定义的额外约束（例如会议的日期） ，某些酒店或航空公司的偏好）。</span></p><h2><a name="3-%E9%A2%84%E5%A4%87%E5%B7%A5%E4%BD%9C" class="md-header-anchor"></a><span>3 预备工作</span></h2><p><span>通常，规划问题有以下几个组成部分：</span></p><ul><li><span>描述在某种形式语言中可能执行的可能的行为（域理论）。</span></li><li><span>描述世界的初始状态</span></li><li><span>描述期望的目标</span></li></ul><p><span>在下面的部分中，我们将介绍定义规划问题的组件的最重要的方法，并将它们与Web服务组合问题的需求进行对比。</span></p><h3><a name="3.1%E8%A7%84%E5%88%92%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8C%96" class="md-header-anchor"></a><span>3.1规划领域的形式化</span></h3><p><span>		</span><span>领域形式化的目的是提供一个领域理论，对可用或与代理相关的操作的语义的正式说明。这些操作可以表示物理操作（例如由机器人的物理环境定义），但也可以表示更抽象的动作（例如从银行帐户中取钱）。</span>
<span>​</span><span>		</span><span>一个领域理论必须正式定义因果律的操作，它必须允许将有关方面，例如行动的先决条件及其对世界的影响等公理化。通常，域理论通常遵循某种状态转移模型，即它引入了状态(或情况)的概念，它是在某个时间点描述世界的快照，它将动作与这些状态之间的转换联系起来。大多数方法将一个状态定义为一组地面原子公式（原子），可以随时间改变其值的原子称为通量，而不改变其值的原子称为状态不变量。</span>
<span>​</span><span>		</span><span>关于领域理论的认识论原则，我们可以区分两种变体：基于经典逻辑的领域理论和超逻辑域理论。</span>
<span>​</span><span>		</span><span>在逻辑方法中，情境演算是由（麦卡锡，1963）引进的，后来被（LaveSK等人，1998； Pirri和赖特，1999）精炼，他们将情形演算定义为一种二阶框架，用于用经典一阶语言表示动态变化的世界。情景演算将世界及其变化表示为一系列情景，其中每个情景都是一个术语，表示一种状态，并通过执行一个动作获得。</span>
<span>​</span><span>		</span><span>将操作编码成一阶谓词逻辑的另一种方法是事件演算（科瓦尔斯基和塞尔格，1989）。在事件演算中，事件启动某些属性保持的周期。一个属性由一个事件启动并继续保持直到一些事件终止。事件，它们的影响和持续时间用喇叭逻辑来表示。</span></p><p>&nbsp;</p><p>&nbsp;</p><p><span>另一种基于逻辑的方法是基于模态逻辑的行动理论，如（Giacomo和LeZrRiNi，1995； CasTiHo等人，1999；佐丹奴等人，1998）所讨论的。世界状态系统，其中行为被建模为这些状态之间的转换。模态逻辑的方法允许一个非常自然的行为建模作为状态转换，通过概念化为</span><em><span>可达性关系</span></em><span>5.3，克里普克结构确实被称为表示非确定性域。</span></p><p><span>尽管这些基于纯逻辑的方法的优点，如精确语义和证明领域理论的某些性质的能力，人工智能规划社区在使用不同的形式主义来表示规划域。这些形式主义主要植根于条带允许通过指定预条件，添加列表和删除符号直接定义运算符，所有这些都表示为原子的连接。直观而言，这样的操作符描述的语义是：如果当前世界状态（表示为数据库）满足了条件，则只适用于操作，并且在执行操作之后，将添加列表的原子添加然而，条带的精确逻辑语义一直是一个争议的话题，提出了不同的建议，例如（LIFSCIZ，1986； ReITER，2001）。</span></p><p><span>ADL语言（PotoNuLTE，1989； PitoNaLUT，1994）为表达表现力的操作符号描述提供了支持，并缩小了语义歧义条带和声明性情境演算之间的差异：的效果（例如，需要使用卡车运输货物的模型），否定和析取。</span></p><p><span>随着时间的推移，许多人工智能规划系统已经被开发出来，支持不同的表达水平，在许多情况下，在ADL和条带之间的中间位置，有时甚至超过，例如表达时间推理，尺度，任务为了解决这个问题，规划域定义语言（PDDL）（GHALAB等，1998）被开发为标准域（和问题）规范PDDL定义了ADL的表现力域，包括尺度流，并定义了标准的扩展扩展规则。原始PDDL版本的后继版本是PDDL 2.1（Fox and Lon，2003），它增加了时间概念和PDDL 2.2，它增加了派生名词词和定时初始文字。已经提出了几个其他扩展，例如（Bertoli等人，2003），它扩展了PDDL来表示非确定性，有限感知和迭代条件计划。</span></p><h3><a name="3.2%E5%88%9D%E5%A7%8B%E4%B8%96%E7%95%8C%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8C%96" class="md-header-anchor"></a><span>3.2初始世界的形式化</span></h3><p><span>规划代理必须考虑到最初的世界状态，因为它必须提供一个计划，当在初始世界中执行时，从而导致指定的目标。</span></p><p><span>在最后一级中讨论的概念化完全定义了行动的概念模型，还定义了规划代理的初始世界描述的概念模型。事实上，初始世界只是域理论所定义的另一个世界状态（或情境）。</span></p><p><span>在几乎所有的方法中构成世界状态的中心元素是已知的在初始世界状态中是真实的原子。经典的人工智能规划方法替代初始世界状态的外延定义提供了</span><em><span>完成</span></em><span>描述这允许采用封闭世界假设，这意味着在状态数据库中未明确列出的任何事实都是假的。</span></p><p><span>对于现实世界的应用，如机器人技术或我们的Web服务计算领域，这些简化的假设是不现实的。事实，我们面临以下问题：</span></p><p><span>不完整的信息：初始世界的外延定义不指定与规划任务相关的所有知识。例如，在电子商务应用中，代理可能不知道哪一个在线零售商提供某种产品，但它需要这些信息来实现其目标。</span><em><span>购买</span></em><span>一种产品</span></p><p><span>错误的信息：一些被定义为真的原子在现实中可能是错误的（反之亦然）。这种情况发生在</span><em><span>引发与合理持久性（IRP）</span></em><span>假设（McIlraith和儿子，2001）被违反，即当事实改变后，代理人已获得有关这些事实的知识，当代理人错误地认为其知识是准确的。</span></p><p><span>模糊信息：对于每个已知的FLUENT值，可能存在某种不正确的概率（例如，由于模糊传感器）。同样，这个问题在我们的领域中并不经常出现。</span></p><p><span>规划师的概念模型已经被延长，刹车更好地处理上面列出的困难。由于代理的世界观可能替换世界的真实性，因此明确地表示代理具有的知识是有用的。Agent的知识可以由原子事实知识和某些公理和函数构成。交替这条线，已经研究了广泛使用的封闭世界假设的替代物，例如</span><em><span>本地封闭世界假设</span></em><span>（LCA），它允许代表局部封闭世界（LCW）知识（黄金，1997）。LCW知识通常组织在两个数据库M和L中，其中数据库M包含所有已知事实的集合，并且数据库L包含描述M的内容的LCW公式，即它们的状态，对于世界的哪些部分，代理的知识可以被安全地假定为完整的。例如，当代理查询所有产品的列表时，在线零售商。</span><em><span>一</span></em><span>出售，它可以预先知道所有的产品，可从</span><em><span>一</span></em><span>（“ IRP豁免成立时”）</span></p><p><span>当代理的知识被明确地表达时，必然需要定义域的某些操作员对代理知识的影响。换句话说，区分改变的操作符（或效果）是有用的。</span><em><span>全球</span></em><span>从只影响代理的操作员（或影响）</span><em><span>知识点</span></em><span>。对不完全知识和感测动作的扩展的扩展是UWL（EtZoii等人，1992）。类似地，SADL（金，1997）增加了对不完整信息的支持和对ADL的感测，NPDDL（Beltoi等人，2003）提出了对PDDL的类似扩展。另一个建议的PDDL扩展是OPT（德莫特，2002），它增加了知识效应和</span><em><span>可学习术语</span></em><span>到PDDL框架</span></p><p><span>在穆尔（1985）中提出了一个基于形式上下文演算的不完全知识的代理和感测动作，这也约会了知识的概念，这是代理的必须满足条件的成功地应用操作员。</span></p><h3><a name="3.3%E4%B8%AA%E5%BD%A2%E5%BC%8F%E5%8C%96%E7%9B%AE%E6%A0%87" class="md-header-anchor"></a><span>3.3个形式化目标</span></h3><p><span>在大多数经典的人工智能规划方法中，目标被表示为需要在所需的世界状态中保持的属性。</span><em><span>目标状态</span></em><span>（通常以连词和析取的形式（正或负原子）的形式，从而用生存量化来处理变量。</span></p><p><span>规划人员需要识别一个解决方案（一个计划），当它在初始世界状态下执行时，将产生满足目标的世界状态。例如一个目标</span><em><span>（彩色门一红）</span></em><span>指定一个条件，表示流畅。</span><em><span>颜色</span></em><span>属于</span><em><span>门1</span></em><span>必须肯定</span><em><span>红色</span></em><span>计划执行之后，还有一个目标</span><em><span>有门屋吗？d）</span></em><span>需要常数的存在</span><em><span>C</span></em><span>，当绑定到变量时？</span><em><span>d</span></em><span>将公式化</span><em><span>有门屋吗？d）</span></em><span>真的</span></p><p><span>对于自动化的Web服务组合（和许多其他领域），这些目标规范是不够的。文献中列出的要求是：</span></p><p><span>需要时间结构：某些复杂的目标不能简单地表示为最终状态的属性。例如，从维也纳到苏黎世和运送的往返行程的规划不能被表示为目标状态的条件，因为目标状态将等于初始状态（即在维也纳的代理）。</span><a href='https://ziyanliupb.github.io/#'><span>三</span><span>]</span></a><span>）因此，需要增加某些结构来将规划目标分成几个不同的，连续的阶段。在某些情况下，一个有效的计划甚至可能包括循环和分支，如Sristava和Koehler，2003年指出的。</span></p><p><span>•处理非确定性的策略，即，如果操作的执行未达到预期或期望的结果（例如，通过定义BPEL），则如何表现</span><em><span>补偿行动</span></em><span>）</span></p><p><span>安全属性：不是全部</span><em><span>可能的</span></em><span>实现目标的解决方案是</span><em><span>渴望的</span></em><span>那些。例如，可能存在某些不应该或仅适度地改变（例如信用卡余额）的某些通量；有时这些被保护的熔剂被称为</span><em><span>维护目标</span></em><span>或</span><em><span>资源约束</span></em><span>。此外，在许多领域中，有一定的情况下，代理人可能绊倒，这需要完全避免，和约束的目标可以帮助逃避他们。</span></p><p><span>区别</span><em><span>信息目标</span></em><span>和</span><em><span>成就目标</span></em><span>许多问题需要这样的区别，因为信息目标应该完全由</span><em><span>感知动作</span></em><span>。作为一个例子，查找项目当前颜色的目标只能使用</span><em><span>不</span></em><span>积极地影响其颜色；我们不希望代理使用将颜色设置为某个新值的操作，然后报告新分配的颜色（金，1997）。取而代之的是，应该通过</span><em><span>传感操作</span></em><span>。</span></p><p><span>·用户对可能的解决方案的替代（例如，宁愿乘飞机旅行超过火车，通过信用卡支付电子现金）和其他用户提供的解决方案的限制（例如，仅在驾驶时购买机票将需要3小时以上）（ McIlraith和儿子，2001）</span></p><p><span>由于这些困难与许多真实世界规划领域相关，既是Web服务组合，还存在多种方法来解决这些问题，这将在SECT中讨论。5。</span></p><h3><a name="3.4%E4%B8%AA%E4%BB%A3%E8%A1%A8%E8%AE%A1%E5%88%92" class="md-header-anchor"></a><span>3.4个代表计划</span></h3><p><span>计划作为解决规划问题的经典观点是</span><em><span>算子实例序列</span></em><span>，由于讨论了最后一段的目标，特别是非确定性问题，因此，这种经典的计划观点并不总是捕捉复杂规划问题的解决方案。</span></p><p><span>计划的所需复杂性超出预定范围和目标复杂度，而且还取决于计划预见的执行模型：如果一个操作没有产生期望的结果，代理将有机会重新生成计划（如在重新规划/无功规划架构中，例如（FiBuy，1987）），或代理必须依赖预定义的计划吗？在后一种情况下，A</span><em><span>有条件的</span></em><span>计划是通过处理可能出现的突发事件的计划来处理非确定性和不完全信息的。在运行时，代理必须确定其所在的情况，然后选择为该情况准备的适当计划分支。采用这种策略的规划者也被称为应急规划师。</span></p><p><span>我们将在后面讨论。4.3，偏序规划者允许计划的行动是部分有序的，即一些行动可以并行执行，而不是5.3，规划师综合可能包含回路和分支的计划。顺序，这经常提高了系统的效率。甚至更多的功能丰富的计划可以使用规划作为模型检查（MC）的方法在SECT中创建。</span></p><h2><a name="4%E7%A7%8D%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%92%E8%8C%83%E5%BC%8F" class="md-header-anchor"></a><span>4种基本规划范式</span></h2><p><span>在总体中，我们将概述基本规划范式和一些预期的实现这些概念。</span></p><h3><a name="4.1%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E8%A7%84%E5%88%92" class="md-header-anchor"></a><span>4.1状态空间规划</span></h3><p><span>状态空间由有限状态集组成。</span><em><span>小号</span></em><span>一个有限的动作集合</span><em><span>一</span></em><span>一个状态转移函数</span><em><span>F</span></em><span>描述操作如何将一个状态映射到另一个状态，以及成本函数。</span><em><span>C</span></em><span>（</span><em><span>如</span></em><span>）</span><em><span>＆＃62;</span></em><span>0规范执行行为的成本</span><em><span>一</span></em><span>处于状态</span><em><span>小号</span></em><span>（Fikes和尼尔森，1971）。用给定初始状态扩展的状态空间</span><em><span>小号</span></em><span>0和一组</span><em><span>SG</span></em><span>目标也被称为</span><em><span>状态模型</span></em><span>（博内特和Geffner，2001年B）。</span></p><p><span>根据状态的规划者逐步通过搜索实现期望状态的有用的算子实例化来解决规划问题。根据搜索的起点，我们区分正向状态搜索（也称为渐进）和向后状态搜索（也称为回归）：基于状态的计划器从初始状态开始，并搜索使规划人员更接近目标的动作实例。回归规划器从满足目标的状态开始，并搜索使规划人员更接近初始状态的动作实例。</span></p><p><span>在这两种情况下，目标是找到的动作，当在初始状态开始应用时，将导致目标状态。更正式地说，状态模型的解决方案是一系列动作。</span><em><span>一</span></em><span>零</span><em><span>一种</span></em><span>一</span><em><span>……</span></em><span>生成状态轨迹的</span><em><span>小号</span></em><span>零</span><em><span>的S</span></em><span> 1 = +1 =</span><em><span>F</span></em><span>（</span><em><span>小号</span></em><span>0）</span><em><span>，…，锡**F</span></em><span>（</span><em><span>安，锡</span></em><span>）每个动作</span><em><span>人工智能</span></em><span>适用于</span><em><span>硅</span></em><span>和</span><em><span>锡</span></em><span>1是目标状态，即</span><em><span>人工智能</span></em><span>γ</span><em><span>一</span></em><span>（</span><em><span>硅</span></em><span>）</span><em><span>锡</span></em><span>1℃</span><em><span>G</span></em><span>（博内特和Geffner，2001年B）。</span></p><p><span>原则上，任何搜索算法都可以执行执行状态的搜索，而手段终结分析的学科有着悠久的传统，起源于20世纪50年代以来的GPS（纽厄尔和西蒙，1963）。然而，通常需要大量的不同分支行动，规划者必须从调用减少搜索空间的方法中选择，或者帮助区分搜索树的所有权的无用分支。减少搜索空间的早期尝试是条带算法。它使用反向搜索，即从目标开始，搜索实现目标目标子目标之一的动作，然后继续搜索实现动作的替代条件的动作，等等。条带仅通过考虑添加到计划中的最后一个操作员的先决条件和提交到由当前状态满足其先决条件的运算符来增强该搜索。这显着地减少了计划空间，但它造成条带不完整，即不能保证甚至存在一个问题也会找到解决方案。</span></p><p><span>处理规划空间浩瀚的另一种方法是使用。</span><em><span>启发式功能</span></em><span>它估计计划者可以选择的替代行动的有用性，从而</span><em><span>指导</span></em><span>规划师选择富有成效的搜索路径，忽略分区将导致死胡同或低质量的解决方案。真正的自动领域无关规划者除了收集来自领域的启发式和他们所面临的问题描述外，没有其他选择，与专门算法相反，例如在AI教科书中讨论的解决8个难题的算法（尼尔森，1980）。</span></p><p><span>采用这种独立于域的启发的规划者是UNPOP（德莫特，1996），它采用回归匹配图。该图的构造从目标开始，该目标与当前情况匹配，产生一组要实现的文字。在图的下一级，动作被认为实现了这些子目标中的一些，这些子目标产生另一组子目标，需要执行这些动作。这些子目标被添加到图的下一级，并且过程重复。加强图的遍历，提出了</span><em><span>估计努力</span></em><span>被使用，即估计要达到主目标需要多少动作，在当前情况下已经已经被通知的目标的努力是0，并且域中的任何操作员所不能达到的目标的努力是无穷的。图时，UNPOP首先选择其工作估计似乎有利的分支，这导致与“盲”非引导搜索排名，计划速度的提高。</span></p><p><span>在相关工作中，提出了基于启发式算法的正向规划HSP（启发式搜索规划器）。</span><em><span>加性启发式HADD</span></em><span>。这个启发式定义了集合的成本。</span><em><span>C</span></em><span>原子作为元素的成本之和。</span><em><span>C</span></em><span>。这预先子目标是相互独立的，这并不总是正确的，因为一旦实现其他目标，某些目标就可能变得越来越（甚至更多）。HSP系统使用</span><em><span>哈德</span></em><span>指导一个</span><em><span>爬山搜索</span></em><span>从初始状态到目标。在每个步骤中，最好的子节点之一（即计数器）</span><em><span>哈德</span></em><span>选择扩展值，重复相同的过程直到达到目标为止。</span><em><span>估计</span></em><span>这是从一个轻松的规划问题中提取出来的。</span><em><span>磷</span></em><span>0，忽略运营商的倾斜影响。通过继承应用其预条件适用于当前状态的多个操作（负效应被忽略）和跟踪在该过程中实现的每个一个原子在其实现了多少步骤之后产生的估计（博内特和GffnER，1998）生成。经验数据表明，使用宽松的问题来收获启发式估计以及假设的目标独立性产生更好的结果，如国际规划竞赛IPC1998（德莫特，2000；博内特和Geffner，2001年B）的结果所记载。</span></p><p><span>在连续的工作中，开发了计划员HSP2（博内特和Geffner，2001年A），其采用相同的启发函数。</span><em><span>哈德</span></em><span>但使用</span><em><span>最佳优先搜索</span></em><span>（珠儿，1985）而不是爬山。最佳的第一次搜索通过评估函数对路由器进行重新</span><em><span>F</span></em><span>（</span><em><span>ñ</span></em><span>）=</span><em><span>G</span></em><span>（</span><em><span>ñ</span></em><span>）</span><em><span>w ^</span></em><em><span>*H</span></em><span>（</span><em><span>ñ</span></em><span>页：1</span><em><span>G</span></em><span>（</span><em><span>ñ</span></em><span>是进步成本，</span><em><span>H</span></em><span>（</span><em><span>ñ</span></em><span>）目标的估计成本，以及</span><em><span>w ^</span></em><span>是常数。更高的值</span><em><span>w ^</span></em><span>与重启的计划搜索相关，但也具有完全的计划质量（KORF，1993）。HSP2评价</span><em><span>哈德</span></em><span>从HSP中产生的每个每个状态的划痕启发式。</span></p><p><span>重生</span><em><span>哈德</span></em><span>是一个明显的性能问题，这是一个必须的HSP规划师，以及相关的规划师，如UNPOP。解决这个问题的尝试是HSPr（博内特和GffnER，1999），HSP的变体，它使用从目标向后搜索而不是从初始状态向前搜索。估计仅从初始状态计算一次，和启发式函数。</span><em><span>哈德</span></em><span>（</span><em><span>小号</span></em><span>总是被计算为从初始状态达到目标的成本之和（博内特和GffnER，1999）。这种向前传播的结合来转化估计和向后搜索计划，这让我们联想到Cop-Prand（百隆和。，FurST，1995），这是在SeCT中讨论的。4.2。虽然HSPr在一些领域中显着地地改进了性能，但是新算法在其他方面不如HSP（博内特和GffnER，1999）。</span></p><p><span>规划作为启发式搜索进一步推进的快进（FF）规划师（霍夫曼，2001），这是在ICP2000竞争的赢家，表现为HSP2和其他。与HSP一样，FF依赖于状态空间中的向向前搜索，由启发式算法指导，使用一个放松的问题来估计目标距离。然而，FF使用一种更复杂的提取启发式值的方法，基于图形计划风格算法（视为SCT）。4.2）。在宽松的解决方案中的行动的数量被采用目标距离估计；图形计划式的解决方案的优点之一是考虑到事实之间的积极相互作用。估计被用来指导一种新的局部搜索策略，称为</span><em><span>强制爬山</span></em><span>。与随机选择最佳中间接受者的HSP相反，FF评估所有状态的继承者（如果必要的话，继任者等的继承者），寻找具有比当前状态更好的启发式值的状态。 ，在每个搜索迭代中，对具有严格更好的评价的状态进行广度优先搜索。这种策略允许规划师逃逸平台和局部极小值。FF的第三个优点是它的概念。</span><em><span>有益的行动</span></em><span>也就是说，它使用规划图中的信息来识别在每个状态下那些在其所达到的效果方面看起来最有用的动作，并且它更喜欢那些看起来多余的操作符的动作（霍夫曼，2001；霍夫曼和内伯尔，2001）。</span></p><p><span>FF的扩展，称为变量FF，在（霍夫曼，2003；霍夫曼，2002）中提出；它处理PDDL 2.1级2中捕获的数值变量，约束和效果。变量FF支持数值状态变量，其可用于预期条件下的数值约束（例如）。</span><em><span>现金＆＃62;</span></em><span>100）和在算术运算中的效果（例如）</span><em><span>现金</span></em><span> − = 10） ）。</span></p><p><span>虽然有时使用校正规划图的启发式算法已经取得了惊人的目的成功，但在某些领域，规划师的FF和HSP家庭表现不佳，因为他们忽略了效应的替代方法失去了太多的重要信息。最近的启发式搜索规划解决这个问题是快速下降（赫尔默特和李希特，2004）。与以前的规划师，如HSP和FF分类，它不使用一个轻松的规划图，而是使用因果图（CG）数据结构（赫尔默特，2004）。</span></p><h3><a name="4.2%E5%9B%BE%E8%A7%84%E5%88%92" class="md-header-anchor"></a><span>4.2图规划</span></h3><p><span>在本节中，我们将讨论在（Blum和FurST，1995）中的图形规划框架，并采用尺寸较小的结构称为规划图的。构造，注释和分析进行了形式化。尽管有一些相似性，规划图不是空间图，如在UNPOP使用的。事实上，相互状态空间图，其中计划是通过图的路径，在计划图中，计划是</span><em><span>流</span></em><span>在网络流意义上（Blum和FurST，1997）。</span></p><p><span>规划图是有向水平图。它由两种类型的例程组成，即</span><em><span>动作例程</span></em><span>和</span><em><span>命题推理</span></em><span>。这些二进制是交替排列的。</span><em><span>水平</span></em><span>每个等级与时间步长相关联。规划图的第一层是一个命题级，它由初始条件的每个命题的一个分组组成。第三级又是命题级，包含来自第一级的命题中断和表示先前动作层动作效果的命中题队列。当两个连续时的命题层是相同的时，规划图的构造停止；已经表明，这总是发生，保证过程的终止。创建计划图的复杂性是动作数和命题数的低阶多重式（Blum和Furst，1997） 。</span></p><p><span>在某种程度上的所有行动</span><em><span>一世</span></em><span>在水平上连接到先决条件</span><em><span>一世</span></em><span>1及其在水平上的作用</span><em><span>一世</span></em><span>1，日期或否定命题</span><em><span>一世</span></em><span>1。对于从层持久化的文字</span><em><span>一世</span></em><span>1至</span><em><span>一世</span></em><span>1，并且没有连接到动作节点，持久化动作的被添加。。（Blum和FurST，1995）定义了动作和文字的相互区别（“互斥”）关系。动作之间可能互斥的关系是</span><em><span>绝对效应</span></em><span>一个动作否定另一个动作的效果，</span><em><span>推论</span></em><span>其中一个动作的效果之一是否定另一个动作的适用条件。</span><em><span>竞争需要</span></em><span>如果一个命题是对另一个命题的否定，或者如果能实现这两个命题的每一对可能的动作是互斥的（RuSSEL和Nordvig，2002），那么在同一水平上的两个命题之间存在相互关系。</span></p><p><span>在这样的规划图中捕获的信息，特别是排除关系传播关于问题的各种直观有用的事实。这些信息可以被规划者用来指导他们的搜索。使用这种技术的第一个计划是图形计划，这是在（Blum和FurST，1995）中约会的。图形计划算法运行在两个主要步骤中，在一个循环中交替：</span><em><span>图展开</span></em><span>和</span><em><span>溶液萃取</span></em><span>。图形扩展增长规划指标缩小，直到达到命题水平，其中所有目标命题是存在的，没有互斥链接之间的任何一对。这是计划存在的必要条件（但不充分）。为了寻找潜在的计划，然后开始解决方案提取阶段。图形计划算法使用反向链接策略，使用逐级的方法来最好地利用互斥约束（Blum和Furst，1997）。一次给定一个目标（水平）</span><em><span>Ť</span></em><span>图形计划提前及时确定一组动作。</span><em><span>Ť</span></em><span>1有这些目标作为效果。在每个步骤中，只考虑与计划中的现有动作不互斥的动作。失败后，Graphplan回溯并尝试不同的动作集。如果没有找到计划和规划图尚未平，那么图形计划恢复图形扩展，直到达到另一个有前途的命题层。可将解的提取归结为约束转化问题。</span><a href='https://ziyanliupb.github.io/#'><span>四</span><span>]</span></a><span>（Do和Kambhampati，2001）或搜索问题（Russel和Norvig，2002）。</span></p><p><span>图形计划的优点除了其良好的性能，它的理论性质，如健全性，本身，生成最短计划和终止在不可解的问题。然而，原始的图形规划算法有一些局限性：首先，它的表示语言被限制为纯的条带操作符，允许有条件或普遍量化的效果；第二，如果在规划任务的规范中包含太多不相关的信息，则性能会急剧下降（Nebelet等人，1997） 。</span></p><p><span>在（Koehler等人，1997）中，提出了IPP规划师的早期版本，它扩展了图形计划来处理条件和普遍转变的效果。作者指出，这种扩展具有可忽略的计算开销，并且与支持ADL子集的其他规划者（例如UCPP和神童）竞争良好。在另外的工作中，将RIFO（除去无关的操作符和从规划问题中得到的初始事实）策略（Koehler等人，1997）添加到IPP中，用不相关的信息来解决Graphplan的问题。最终，目标议程管理器（GAM）来订购子目标集和增量计划子问题（Koehler和霍夫曼，2000）已被添加到IPP，以及最近的FF规划。</span></p><p><span>另一个基于图形计划的规划师，通过时间的过渡，是Stan（龙和狐狸，1999）。它在几个方面进行了改进。和负载，1998）在规划之前对规划域执行多个预先分析或状态分析。转换，Stan使用预条件和效应的有效内部表示（作为位向量），这允许规划图的资源有效表示（称为</span><em><span>道钉</span></em><span>并且允许使用有效的位操作操作执行动作和事实之间的互斥检查。</span><a href='https://ziyanliupb.github.io/#'><span>五</span><span>]</span></a><span>。此外，在尖峰结构中避免多余信息，使用所谓的技术。</span><em><span>波前</span></em><span>（long和狐，1999），这对图形计划产生了有利的空间需求。</span></p><p><span>感官图形计划SGP（CURE等人，1998）是图形计划的扩展，既支持在条件（Gazen和KNOBRON，1997）中描述的条件效应，而且还处理不确定的影响（史米斯和焊缝，1998 ）和初始情况下的不确定性。（史米斯和Curn，1998）中提出的想法是为每个可能的世界扩展一个单独的规划图，跟踪世界上的相互关联，然后向后搜索一个在所有可能的世界中工作的计划。SGP介绍了表单的观察效果</span><em><span>（swwf）</span></em><span>在哪里</span><em><span>世界自然基金会</span></em><span>表示由命题组成的任意逻辑表达式。SGP的操作员可能有零个或多个这样的观察效果，当在运行时执行时，传递指定表达式的真值。</span><em><span>世界自然基金会</span></em><span>。为了完成图形扩展的这种扩展，SGP修改了图形扩展阶段，并使其从传感器定义和先前的规划图命题层转换为知识命题。 SGP生成具有可重新加入的分支的应急计划。</span></p><h3><a name="4.3%E5%81%8F%E5%BA%8F%E7%BB%86%E5%8C%96%E8%A7%84%E5%88%92" class="md-header-anchor"></a><span>4.3偏序细化规划</span></h3><p><span>与完善今所讨论的技术相反，偏序细化规划者（也称为偏序因果链接规划者（POCL）或偏序规划师（POP））制定规划问题而不是搜索空间。</span><em><span>世界各国</span></em><span>只是作为一种在空间中的搜索</span><em><span>局部指定方案</span></em><span>，即搜索空间的基线不是状态，甚至</span><em><span>计划</span></em><span>报表之间的弧不是动作执行，又</span><em><span>计划细化</span></em><span>。</span></p><p><span>POCL规划师通常会产生部分有序的计划，即不是所有的动作都有一个固定的顺序在计划中，一个计划可以有几个不同的线性化，这都实现了相同的结果。</span></p><p><span>偏序计划在旧文献中也被称为任务网络，可以表示为四元组。 </span><em><span>π</span></em><span> = hS </span><em><span>π**，</span></em><span>Ø</span><em><span>，</span></em><span>乙</span><em><span>，</span></em><span>李，它由以下组件组成：S是一组计划步骤，即操作实例。O是一组有序约束。每个排序约束都是形式约束。</span><em><span>硅</span></em><span>γ</span><em><span>J</span></em><span>这意味着这一步骤</span><em><span>硅</span></em><span>必须执行</span><em><span>之前</span></em><span>步</span><em><span>J</span></em><span>。如果某个计划的集合S至少有两个步骤</span><em><span>南非</span></em><span>和</span><em><span>某人</span></em><span>哪里都不包含</span><em><span>南非</span></em><span>γ</span><em><span>某人</span></em><span>也不</span><em><span>南非</span></em><span>γ</span><em><span>某人</span></em><span>然后 </span><em><span>π</span></em><span> = 6 =是常数值或引用到其他计划步骤的变量。如果仅使用平面图步骤，则B =∅。L是一组因果关系。因果链接用于跟踪计划中引入步骤的原因，并防止其他步骤干扰该目的。如果步骤是一个</span><em><span>偏序</span></em><span>计划B是动作实例参数的每个变量绑定约束：每个变量约束都是形式的。</span><em><span>变种**X</span></em><span>或</span><em><span>变种**X</span></em><span>在哪里</span><em><span>变种</span></em><span>是一些计划步骤的变量</span><em><span>X**硅</span></em><span>实现命题</span><em><span>磷</span></em><span>满足步骤的先决条件</span><em><span>J</span></em><span>因果联系</span><em><span>硅</span></em><span>渐次</span><em><span>-</span></em><span>被添加到L</span></p><p><span>此外，在部分顺序规划中考虑以下派生集：OC是计划的开放条件集。开放条件</span><em><span>聚苯乙烯</span></em><span>出现时</span><em><span>磷</span></em><span>是文字的一部分</span><em><span>前S（S）</span></em><span>当没有因果联系时</span><em><span>SX</span></em><span>渐次</span><em><span>聚苯乙烯</span></em><span>原因，在L.，开放条件是计划步骤的先决条件，目前的计划尚未解决。UL是一组不安全的链接。</span><em><span>硅</span></em><span>渐次</span><em><span>-</span></em><span>被称为</span><em><span>不安全的</span></em><span>如果存在一个步骤</span><em><span>SK</span></em><span>这样（我）</span><em><span>磷</span></em><span>是影响的一部分</span><em><span>SK</span></em><span>）和（ii）O是含{一致</span><em><span>硅</span></em><span>γ</span><em><span>SK</span></em><span>γ</span><em><span>J</span></em><span>}。在这种情况下，</span><em><span>SK</span></em><span>可以说</span><em><span>威胁</span></em><span>因果联系</span><em><span>硅</span></em><span>渐次</span><em><span>-</span></em><span>。计划的开放条件和不安全链接的结合称为集合F。</span><em><span>瑕疵</span></em><span>属于 </span><em><span>π</span></em><span> </span><em><span>π</span></em><span>）= OC（</span><em><span>π</span></em><span>）∪UL（</span><em><span>π</span></em><span>）。计划</span><em><span>π</span></em><span>页：1没有瑕疵的叫做</span><em><span>完成</span></em><span>。</span></p><p><span>开放条件</span><em><span>聚苯乙烯</span></em><span>可以通过约会或重用具有实现效果的计划步骤来解决。</span><em><span>磷</span></em><span>。另外，A</span><em><span>威胁</span></em><span>因果联系的</span><img src='https://ziyanliupb.github.io/%E7%A9%BA%E5%80%BC_files/clip_image002.gif' alt='img' referrerPolicy='no-referrer' /><span>一步一步</span><em><span>SK</span></em><span>也可以通过</span><em><span>促销</span></em><span>，即通过添加排序约束</span><em><span>SK</span></em><span>γ</span><em><span>硅</span></em><span>o或通过</span><em><span>降级</span></em><span>，即增加</span><em><span>J</span></em><span>γ</span><em><span>SK</span></em><span>如果规划人员使用提升的动作，即如果允许在其参数列表中具有变量的动作实例，则威胁也可能通过</span><em><span>分离</span></em><span>，就是添加绑定约束，这样</span><em><span>磷</span></em><span>和</span><em><span>磷</span></em><span>不能统一。规划人员通过计划空间的方式，即它采用的策略来选择计划细化和删除缺陷决定了规划师的效率。</span></p><p><span>在查普曼（1987年）中，在1975年与NOAH（SaCaldodoi）的部分计划的制定中，在近三年中引发了研究和开发活动。在1977年，提出了非林系统（TATE，1977）， ）中指定了部分顺序规划的一个形式化的描述，它称为了TWMID系统，它可以处理连接和析取的先决条件以及连接效应。（Chapman，1987）还提供了调整稳健性和完备性的调整的证明，其中其余使用</span><em><span>模态真值准则</span></em><span>（MTC）明确地检查所有的安全接地线性对应于解决方案。然而，最近的规划者们则依赖于</span><em><span>保护策略</span></em><span>和</span><em><span>冲突解决</span></em><span>为了间接保证解决方案的安全性和必要的正确性：SNLP（McAllester和RoShanBLITT，1991）约会威胁和安全条件的概念，UCPOP（彭伯西和CURE，1992）将域和问题描述为复杂性扩展到具有条件许多工作已经跟进，以扩大SNLP和UCPUP，最重要的是涉及启发式的有效缺陷选择，改进了（Poot和史米斯，1993年）。 ；威廉姆森和汉克斯，1996；舒伯特和杰里维尼，1995；波拉克等，1997）。这些这些渐进的改进，部分按顺序规划新计划图，SAT和启发式状态空间规划者，已经出现在1990年下半年。</span></p><p><span>一直以来（自2001年以来）已经进行了一些有前途的尝试来替换一些PoCL规划的忏悔：在（Nguyen和KAMBHAMPATI，2001年）中注意到，负责图形计划和启发式状态规划的效率的技术可以调整（Nguyen和KAMBHAMPATI，2001）介绍了RePOP，一个POP实现，它包含了几个增强：它使用一个规划图来实现单个（子）目标的成本的估计。此外，它使用了一种处理不安全链接的新技术：不安全链接。</span><img src='https://ziyanliupb.github.io/%E7%A9%BA%E5%80%BC_files/clip_image004.gif' alt='img' referrerPolicy='no-referrer' /><span>这与行动冲突</span><em><span>阿克</span></em><span>不是自动升级或降级解决，这将导致新的部分计划，最终炸毁计划空间和降低性能；相反，RePoP使用</span><em><span>析取约束处理</span></em><span>，提出（KAMBHAMPATI和杨，1996），这是解决不安全链接通过放置一个析取分解约束捆绑促销和降级的问题，并逐步简化这些约束的传播技术，这导致在检测到很多失败的计划之前，他们选择精化。最终，RePoP改进了偏序规划的一致性执行。POP考虑因果链接</span><em><span>人工智能</span></em><span>渐次</span><em><span>帕杰</span></em><span>只受行动威胁</span><em><span>一</span></em><span>如果有效果的话</span><em><span>磷</span></em><span>。经常</span><em><span>一</span></em><span>可能有效果</span><em><span>问</span></em><span>没有合法的国家</span><em><span>磷</span></em><span>和</span><em><span>问</span></em><span>真的在一起。为了检测这种隐式冲突，需要关于可达状态的信息。再次，使用规划图生成该信息。然后将可达状态与前后进行对比。</span><em><span>割集</span></em><span>如果这些割集违反了可达状态的性质，即如果检测到互斥（视为SeCT）。4.2）然后放弃部分计划。这些增强的结果是，RePoP能表现出比CSP和基于状态的规划者平等和有时更好的性能，它借用了强大的冲突检测技术。同时，它能够在许多情况下生成更适合的解决方案方案，并且保留POP框架的开放性和合并，这被认为是该框架的优点之一（史米斯等人，2000）。</span></p><p><span>偏序规划的另一个最新进展是通过通用启发式偏序规划（VHPOP）实现的，在（Yunes和西蒙斯，2002； Yunes和西蒙斯，2003）中提出，这在第三国际规划竞赛3中成功地进行了竞争。</span></p><p><span>像SNLP和UCPOP一样，VHPOP使用</span><em><span>一</span></em><span>算法（HART等人，1968）通过规划空间搜索。这个</span><em><span>一</span></em><span>算法要求搜索例程的评价函数</span><em><span>F</span></em><span>（</span><em><span>ñ</span></em><span>）=</span><em><span>G</span></em><span>（</span><em><span>ñ</span></em><span>）</span><em><span>H</span></em><span>（</span><em><span>ñ</span></em><span>页：1</span><em><span>G</span></em><span>（</span><em><span>ñ</span></em><span>是到达的成本吗？</span><em><span>ñ</span></em><span>从开始摘要（即初始计划）和</span><em><span>H</span></em><span>（</span><em><span>ñ</span></em><span>是达到目标目标的估计剩余成本（即完整计划）。为了鼓励搜索最小的计划，计划的成本是在其中的行动数量；而SNLP和UCPP使用开放性缺陷的数量（</span><em><span>π</span></em><span> </span><em><span>π</span></em><span>）一个估计的计划</span><em><span>H</span></em><span>（），VHPOP规划师采用了附加启发式算法。</span><em><span>哈德</span></em><span>HSP（CFS）。4.1）实现更明智的启发式，其中考虑到目标之间的良性互动。与状态空间规划者FF一样，VHPOP利用替代规划图来提取数据。</span><em><span>哈德</span></em><span>。</span></p><p><span>虽然这些启发式通知</span><em><span>方案选择</span></em><span>VHPOP还提供了强大的启发式算法。</span><em><span>缺陷选择</span></em><span>除了现有策略的实施，如Dunf和DSep（Poot和史米斯，1993），LCFR（Joslin和波拉克，1994），ZLFIO（舒伯特和Gerevini，1995），VHPOP上了新的缺陷选择策略：</span><em><span>静态优先</span></em><span>有效地处理静态开放条件， </span><em><span>LCFF-Loc</span></em><span>允许局部缺陷选择，这使规划师对操作者规范中的预条件条件不太敏感，并且约会了几个冲突驱动的缺陷分段策略，这些假设是建立在那些被关闭时受到威胁的开放条件下，应该以更高的优先级来处理（尤尼斯和西蒙斯，2003）。</span></p><p><span>此外，VHPOP扩展了POP框架来处理PDDL 2.1级3所指定的持续性动作，同时时间注释附加到开放条件，该条件告诉规划师该条件必须保持的时间步长。</span></p><h3><a name="4.4%E8%A7%84%E5%88%92%E4%BD%9C%E4%B8%BA%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7" class="md-header-anchor"></a><span>4.4规划作为可满足性</span></h3><p><span>背后的想法</span><em><span>规划作为可满足性</span></em><span>方法是将规划问题表示为一个推理问题，其中存在强大的问题替代算法。</span></p><h4><a name="4.4.1%E4%BD%9C%E4%B8%BA%E5%91%BD%E9%A2%98%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7%E7%9A%84%E8%A7%84%E5%88%92" class="md-header-anchor"></a><span>4.4.1作为命题可满足性的规划</span></h4><p><span>规划的逻辑方法历来是</span><em><span>演绎</span></em><span>（例如，Green，1969；麦卡锡和海因斯，1987； RoSoxein，1990），从而，找到一个证明，初始条件与域公理（定义操作符的语义）和一些动作序列意味着目标情况（表示为逻辑公式）。这种定理的证明是逻辑定理的任何有效实例化，并且可以从这样的实例化中提取动作序列。</span></p><p><span>然而，在（考茨和塞尔曼，1992）规划通过</span><em><span>可满足性</span></em><span>检查。在这种方法中，规划问题不是一个有待证明的定理，相反，它被设计成具有属性的一组公理。</span><em><span>任何</span></em><span>公理的模型对应于一个有效的计划。此属性是通过编写排除非预期（异常）模型的公理来实现的，例如公理需要明确地排除在不满足其条件的情况下执行动作的可能性。</span></p><p><span>此外，公理不包含量化或术语，并且所有谓词都有一个需要时间步长的尾随参数。例如</span><a href='https://ziyanliupb.github.io/#'><span>六</span><span>]</span></a><span>在著名的街区世界（Gupta和NAU，1992）中，实现规划问题。</span><em><span>：（放）</span></em><span>（</span><em><span>乙</span></em><span>）从最初的情况</span><em><span>：（放）</span></em><span>（</span><em><span>甲，乙</span></em><span>）</span><em><span>：（放）</span></em><span>（</span><em><span>B表</span></em><span>）将表示为：</span></p><p><em><span>：（放）</span></em><span>（</span><em><span>甲，乙，</span></em><span>1）</span><em><span>：（放）</span></em><span>（</span><em><span>B，表，</span></em><span>1）</span><em><span>清空</span></em><span>（</span><em><span>一种</span></em><span>1）</span><em><span>：（放）</span></em><span>（</span><em><span>B，A，</span></em><span>3）</span></p><p><span>此外，语义（倾向于和效果）</span><em><span>移动</span></em><span>操作员将被正式化为：</span></p><p><span>γ</span><em><span>x，y，z，i移动</span></em><span>（</span><em><span>x，y，z，i</span></em><span>）</span><em><span>清空</span></em><span>（</span><em><span>X，I</span></em><span>）</span><em><span>清空</span></em><span>（</span><em><span>我是</span></em><span>）</span><em><span>：（放）</span></em><span>（</span><em><span>x，y，i</span></em><span>）</span></p><p><span>需要额外的公理，以确保在一个时间步采取一个精确的动作。在这个例子中，唯一满足公理化规划问题的模型是：</span></p><p><span>{</span><em><span>移动</span></em><span>（</span><em><span>A，B，表，</span></em><span>1）</span><em><span>移动</span></em><span>（</span><em><span>B，表，A，</span></em><span>2）}</span></p><p><span>这是预期的模型，它可以作为一个代理的计划。该模型可以使用可满足性决策过程，如Davis Putnam过程或随机过程，如GSAT（SELMAN等，1992），另一个例子是WalkSAT，也称为WSAT（SELMAN等，1993）。</span></p><p><span>这种方法的规划结果是非常有竞争力的（考茨和塞尔曼，1996）。基于这一技术的规划程序是Satplan（考茨和塞尔曼，1992）和继任者黑匣子（考茨和Selman，1998年A），它结合了SATPLAY和图形计划的想法。这两个系统在国际规划竞赛中都有很好的竞争。</span></p><p><span>LGP系统（Gerevini和Serina，2002）和它的继任者LGP TD（Gerevini等人，2004）采用了类似的方法。它们都是基于WalkSAT，但结合了最佳的第一搜索算法，并使用规划图搜索启发式。</span></p><p><span>除了良好的性能外，基于SAT的规划还有另一个优点：由于状态在该框架中被明确地建模（原子的尾随参数），如黄等人，1999； Kutz和Selman，1998年的，很容易对状态制定要求。这反过来又有助于表达宗派讨论的复杂目标。3.3。</span></p><h4><a name="4.4.2%E8%A7%84%E5%88%92%E4%BD%9C%E4%B8%BA%E6%8F%8F%E8%BF%B0%E9%80%BB%E8%BE%91%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7" class="md-header-anchor"></a><span>4.4.2规划作为描述逻辑可满足性</span></h4><p><span>另一种将规划任务作为逻辑可满足性问题的方法出现在（贝拉尔迪等人，2003）中。更准确地说，这里集中讨论了Web服务自动组合问题。在这种方法中，”目标逻辑”不是命题逻辑，而是描述逻辑ALU。</span></p><p><span>该方法定义了</span><em><span>社区</span></em><span>Web服务的特点是一组共同的动作，称为社区的样式和一组基于公共动作集合指定的Web服务。服务提供的交互协议表示为</span><em><span>执行树</span></em><span>其中，每个收件人表示客户端-服务器交互中的可能状态，并且每个边缘表示由客户端在协议之后调用的动作。Web服务组合问题现在识别由社区中的服务的动作组成的执行树，其对应于给定的期望执行树。</span></p><p><span>构造这样一棵树的任务是想起产生一个描述逻辑概念的模型来证明它的可满足性（或它的不可满足性）的任务：利用这一性质，将Web服务域和规划问题从情景演算表示出来转换为ALU，然后任何高效的基于表格的描述逻辑推理器（如（Volker Haarslev，2001； HORRORKS，1999））可以构建生成可满足性检查的树模型，从中可以直接提取合成过程（如果存在的话）。</span></p><h4><a name="4.4.3%E4%BD%9C%E4%B8%BApetri%E7%BD%91%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%9A%84%E8%A7%84%E5%88%92" class="md-header-anchor"></a><span>4.4.3作为Petri网可达性的规划</span></h4><p><span>另一项工作是从一个基于情景演算的公理化规划问题开始，然后将其转换成一个替代的形式化框架（纳拉亚南和McILRAITS，2002）。</span><em><span>可达性分析</span></em><span>Petri网（Petri，1962）。我们的想法是创建一个基于原子Web服务的Petri网，它代表原子操作的所有可能的组合，并指定为Petri网（即令牌配置）的状态的期望目标。这些技术也可以用于验证计划是否是良好形成的（纳拉亚南和McILRITES，2002）。</span></p><h3><a name="4.5%E8%A7%84%E5%88%92%E4%BD%9C%E4%B8%BA%E9%80%BB%E8%BE%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" class="md-header-anchor"></a><span>4.5规划作为逻辑程序设计</span></h3><p><span>另一种提出一种将规划域的动作规律编码为可用于形式推理方法的逻辑表示的方法是规划。</span><em><span>逻辑程序设计</span></em><span>方法</span></p><p><span>逻辑程序由一组形式的HORN子句组成。</span><em><span>一</span></em><span>γ</span><em><span>乙</span></em><span>一</span><em><span>，…，BN</span></em><span>。每个这样的HOLL子句也可以被解释为文本的析取，最多为一个正文字，即</span><em><span>一</span></em><span>γ</span><em><span>乙</span></em><span>1℃</span><em><span>…</span></em><span>γ</span><em><span>氮化硼</span></em><span>。逻辑程序中的否定性通常表示为</span><em><span>否定作为失败</span></em><span>（nAF），这必然它们不是单调的。</span></p><p><span>逻辑编程（LP）和规划之间的关系，以及作为逻辑程序的规划问题的编码在文献中被广泛研究，例如在（GelFoand和LIFSHIZ，1993； Turnter，1997； LIFSHIZ，1999）。</span></p><p><span>虽然演绎推理的直接应用，如Prolog的SLD将是不言而喻的，作为LP方法的规划的许多进展已经实现使用替代方法，灵感来自（SurrHaman和ZANIOLO，1995）。（SurrHaman和ZANIOLO，1995）存在规划问题可以在线性时间转换成逻辑程序，从而给定的目标。</span><em><span>G</span></em><span>在规划域中，当且仅当相关目标是可实现的</span><em><span>G</span></em><span>在某些方面是正确的</span><em><span>稳定模型</span></em><span>通过变换获得的逻辑程序；目标</span><em><span>G</span></em><span>也可以在线性时序得到（SurabHaMaNi和ZaioLo，1995）。这些稳定模型可以通过计算</span><em><span>答案集</span></em><span>逻辑程序，如在SMODEM（Nimelae和Simon，1997）之类的工具中实现的。（Dimopoulos等人，1997）报告了这种方法的经验测试，并建议，给定一个正确的逻辑程序编码，性能可以跟上通用规划算法的性能，如图形计划或SATPLAY。</span></p><p><span>逻辑编程的其他应用是赖特实现GOOG和回归的正确演算（ReITER，2001）。还应该提到的是（单阿汉，2000），它发出了事件演算的逻辑编程编码。在Web服务组合领域，PrimeKand和Fox（2002）提出了剑工具包，它使用Prolog对信息提供服务进行推理，从而直接从Prolog解释器的执行轨迹中提取计划。</span></p><h2><a name="5%E6%8E%A7%E5%88%B6%E7%9F%A5%E8%AF%86%E8%A7%84%E5%88%92" class="md-header-anchor"></a><span>5控制知识规划</span></h2><p><span>虽然在最后部分中描述的许多规划师的性能是相当令人印象深刻的，在许多研究人员中有一种信念，有必要提供规划代理与域或任务相关的控制知识，从而具有很好的性能在现实中世界域。</span></p><p><span>在下面的章节中，我们将简要回顾规划技术，允许以一种或另一种方式合并和利用域或任务相关的控制知识。</span></p><h3><a name="5.1%E5%B1%82%E6%AC%A1%E4%BB%BB%E5%8A%A1%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92" class="md-header-anchor"></a><span>5.1层次任务网络规划</span></h3><p><span>分级任务网络（HTN）计划首先约会了早期的抽象（SACRDODI，1973）计划系统，其次是诺亚和其他几个规划师；它被赋予了正式的语义（ErOL等人，1994年B； Erol等人，1994年A）。</span></p><p><span>与其他规划范例一样，HTN规划提供了分类摘要，一个强大的策略，以应付复杂和复杂的现实世界规划领域。与其他规划范例一样，HTN规划假设具有运算符，当其先决条件在其执行之前直接举行时，实现一定的定义效果。然而，除了操作（被称为操作）</span><em><span>原始任务</span></em><span>在HTN规划中，HTN规划也支持一套</span><em><span>方法</span></em><span>其中每一个都是一个如何将某些任务分解成一组子任务的处方。这种方法描述代表了共同点。</span><em><span>领域知识</span></em><span>或者，如果从规划者的角度来看，代表</span><em><span>计划碎片</span></em><span>。</span></p><p><span>根据（EOL等人，1994年B）中的定义，HTN规划中有三种类型的目标：（i）目标任务，它是最终状态的期望属性，就像在大多数其他规划范例中一样，（ii ）已经提到的原始任务，和（iii）表示涉及多个目标任务和原始任务的期望变化的复合任务。</span></p><p><span>HTN规划的一个变型近来备受关注。</span><em><span>有序任务分解</span></em><span>规划，其中代理计划的任务，在相同的顺序，他们将被执行，这大大降低了规划问题的复杂性。基于这一原理的规划者，如商店（简单分层规划师）（NAU等人） ，1999）接受目标作为任务列表，其中复合任务可以由复合任务或原始任务组成；不支持目标任务。因此，有序任务分解系统不打算实现定义的（声明的）目标，而是执行给定的（复杂的或原始的）任务。</span></p><p><span>这样的基于HTN的规划系统将期望的任务分解成一组子任务，并且将这些任务分成另一组子任务（等等），直到所得到的任务集仅由原始任务组成，这些任务可以通过调用原子操作直接执行。在每个轮任务分解期间，测试是否违反了某些给定条件。如果期望的复杂任务分解成两个原始任务而不违反任何给定条件，则成功地解决了规划问题。</span></p><p><span>在Hunter等人，2003）中提出了一种在Web服务领域中使用HTN规划的方法，它促进了SuS2系统（NAU等人，2003），其属于</span><em><span>有序任务分解</span></em><span>我们（上面的描述的规划者。论文（HeDell等人，2003；吴等人，2003）提出了OWL-S过程到层次任务网络的转换方法。OWL-S进程和HTN任务网络一样，对要执行的任务进行预先定义的动作描述，这导致转换相当自然。该方法的优点是它能够处理非常大的问题域；然而，需要明确地为规划者提供它需要完成的任务可以被忽略是一个缺点，因为这需要在动态环境中不总是总是的描述。</span></p><h3><a name="5.2%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C" class="md-header-anchor"></a><span>5.2高级程序执行</span></h3><p><span>在经典的规划方法中，一个计划是在给定一个领域描述和一个规划目标的基础上综合的，在这个计划中，规划者必须搜索一个通常是非常大的可能空间来确定规划问题的正确解决方案。另一种方法是</span><em><span>高级程序执行</span></em><span>这种方法背后的思想是，不是搜索满足某种声明性目标的动作序列，而是识别构成一个动作的序列。</span><em><span>法律执行</span></em><span>一个给定的高级程序。在规划中，有必要对域操作符的先决条件和影响进行推理，以发现该操作可以被详细应用。如果详细地制定高级程序并确定性地制定，那么就不需要进行太多的推理，否则，当程序不详细制定，如果它使用非确定性控制结构，那么搜索任务就开始开始传统的计划（GiasMo等人，2000）。</span></p><p><span>GOOGO（逻辑中的ALGOL）（LaveSK等人，1997）语言是这样一种高级编程语言，它特别设计为动态域中的复杂动作的规范和执行。且，它是基于逻辑的，这意味着GOOG程序是可修改的形式验证程序和基于GOOG的规划问题可以通过逻辑工具，如定理证明器来执行。</span></p><p><span>GOOGO是基于情境演算的。3.1），它是由（麦卡锡，1963）约会的，此后常常被采用提供动态系统的正式帐户的手段。虽然情况演算的早期处理识别状态的状态，即在瞬间的宇宙描述（麦卡锡和海因斯，1969），更近期的正式治疗（莱维斯克等人，1998； Pirri和赖特，1999）的情况演算确定的情况与世界历史。世界的所有变化都是命名行动的结果。情境是一个可能的世界历史，是由串联动作产生的，它被表达为一阶项。常数</span><em><span>小号</span></em><span>0表示</span><em><span>初始情况</span></em><span>Distr。函数</span><em><span>做</span></em><span>（ </span><em><span>α，s</span></em><span> </span><em><span>α而</span></em><span>表示执行动作所导致的情况。在官员中</span><em><span>小号</span></em><span>。操作是作为函数编写的，并且可以被参数化。例如，函数</span><em><span>油漆</span></em><span>？</span><em><span>哦，</span></em><span>？</span><em><span>C</span></em><span>可能代表画一个物体吗？</span><em><span>Ø</span></em><span>颜色？</span><em><span>C</span></em><span>，在这种情况下</span><em><span>做</span></em><span>（</span><em><span>油漆</span></em><span>（</span><em><span>红门</span></em><span>）</span><em><span>的S</span></em><span>会说明绘画造成的情况。</span><em><span>门</span></em><span>红色的。表达式</span><em><span>做</span></em><span>（</span><em><span>推倒</span></em><span>（</span><em><span>红色</span></em><span>）</span><em><span>做</span></em><span>（</span><em><span>油漆</span></em><span>（</span><em><span>红门</span></em><span>）</span><em><span>做</span></em><span>（</span><em><span>拾音器</span></em><span>（</span><em><span>红色</span></em><span>）</span><em><span>的S</span></em><span> 0）））表示执行</span><em><span>拾取（红色）</span></em><span>在官员中</span><em><span>小号</span></em><span>0，然后执行</span><em><span>油漆（门，红色）</span></em><span>紧随其后</span><em><span>倒下（红色）</span></em><span>。</span></p><p><span>GOROG通过提供一个外层结构来合并情境演算之上。</span><em><span>简称</span></em><span>用于逻辑表达式在情境演算语言中的应用。</span><em><span>做</span></em><span>（</span><em><span>δ，S，S</span></em><span>0）</span><em><span>宏扩展</span></em><span>转化为一个情境演算公式，表示可能达到的情况</span><em><span>小号</span></em><span> </span><em><span>δ</span></em><span>从情境 0</span><em><span>小号</span></em><span>通过执行指定的动作序列，这是一个复杂的动作表达式。GOOG提供以下宏可扩展语言构造：原始动作，测试动作，序列，两个动作的非确定性选择，动作参数的非确定性选择和非确定性迭代（同时循环）。GOOG还允许（可能递归）过程的定义（ReITER，2001）。</span></p><p><span>称为一种基于态势演算的领域公理化方法</span><em><span>公理</span></em><span>初步情况</span><em><span>小号</span></em><span>0和GOOG程序 </span><em><span>δ</span></em><span>，规划（即程序执行）任务可以表示为以下定理证明任务（ReITER，2001）：</span></p><p><em><span>公理</span></em><span>“</span><em><span>小号</span></em><span>）</span><em><span>做</span></em><span>（</span><em><span>δ，秒</span></em><span>零</span><em><span>的S</span></em><span>）</span></p><p><span>另外，规划师必须识别一种情况。</span><em><span>小号</span></em><span>宏公理可从公理证明。实例</span><em><span>小号</span></em><span>作为证明的异常而获得，并且从该实例获得动作序列。</span><em><span>〜一个</span></em><span> | =））成立，其中</span><em><span>〜一</span></em><span>可以提取这样的</span><em><span>公理**做</span></em><span>（</span><em><span>δ，秒</span></em><span>零</span><em><span>做</span></em><span>（</span><em><span>如</span></em><span>简称</span><em><span>做</span></em><span>（</span><em><span>安，做</span></em><span>（</span><em><span>安</span></em><span>1个</span><em><span>，……</span></em><span>（</span><em><span>一</span></em><span>一</span><em><span>的S</span></em><span>联合国在Levesque等人（1997年）中提出了一个基于Golog Interpreter的序言。</span></p><p><span>能够处理并发的GOROG的变体是COOGORG（并发GOOGO）（GIACOMO等人，2000）：它允许并发进程，从而通过组件进程中交织原子动作来建立并发性；它还支持中断（例如，当在电梯中敲击报警按钮时处理情况）和外生动作，即可能发生在与程序并行但没有解释器控制之下的动作。提出了一种基于PROLoG的COGORGOG解释器（GiAcMo等人，2000）。</span></p><p><span>在（McIlraith和儿子，2001； McIrrase＆Son，2002），一个修改版本的COGGORG解决方案Web服务组合的问题。在（纳拉亚南和McILRAITS，2002）中，指定了从OWL-S到态势演算和Golog的形式变换。在这种情况下，OWL-S过程可以作为执行所需求过程的规范以及对Web服务所提供的原子和复杂动作的描述。Web服务组合问题将是找到满足目标中定义的属性的GOOG程序的执行。</span></p><h3><a name="5.3%E8%A7%84%E5%88%92%E4%BD%9C%E4%B8%BA%E6%A8%A1%E5%9E%8B%E6%A3%80%E9%AA%8C" class="md-header-anchor"></a><span>5.3规划作为模型检验</span></h3><p><span>规划模型检查方法首次提出（CimaTi等人，1997； Giunchiglia和TravSO，1999），制定规划问题作为语义模型检查问题。模型检查是一种形式化的验证技术，它允许确定某些系统中的属性是否该技术用于硬件和软件系统的验证，以实现对系统行为的正式说明，例如系统从不达到某个不想要的状态（安全），或者保证在某个点（例如，自旋模型检查器被激活并验证NASA的深空1任务中的多线程计划执行模块，并发现多个先前未知的并发错误（Havunund等人，2001）。系统推理的模型检查更一般，详细的讨论可以在（哈尔彭和VADI）中找到，</span></p><p><span>1991）</span></p><p><span>通过模型检查（PBM）的规划是语义良好的基础，并能够处理非确定性，部分可观察性和扩展目标。在PBM中，规划域被形式化为一个非确定性状态转移系统，其中一个动作是一个过渡，它可以使系统从一个状态转变成可能的后续状态。何时在其他规划方法中，规划目标可以表示为期望目标状态的约束；从而，目标可以通过关于属性的声明来扩展。</span><em><span>计划本身</span></em><span>，例如通过CTL（计算树逻辑）时间公式（爱默生，1990）或使用最近提出的EAG（LaGo等人，2002）语言。</span></p><p><span>PBM方法的基本思想是通过确定目标公式在模型中是否成立来生成计划，从而通常将模型形式化为Kripke结构。由PBM生成的计划是“处境计划”（Georgeff和Lansky，1990），是由反应性代理执行的计划，在每个迭代循环中，反应性代理都会确定其所处的状态，然后应用计划为该州预见的行动。为了更正式地说明这一点，请考虑一个规划域Σ=（</span><em><span>S，A，γ</span></em><span> </span><em><span>γ</span></em><span>页：1</span><em><span>小号</span></em><span>是一组有限状态，</span><em><span>一</span></em><span>是一组有限的动作和：</span><em><span>小号</span></em><span>×</span><em><span>一</span></em><span>“ 2”</span><em><span>小号</span></em><span>是非确定性状态转移函数。现在，一个有效的PBM生成计划 </span><em><span>π</span></em><span>使得（ </span><em><span>π</span></em><span>也称为</span><em><span>政策</span></em><span>对于这个规划域，是一组对（</span><em><span>A，A</span></em><span>这样</span><em><span>小号</span></em><span>γ</span><em><span>小号</span></em><span>和</span><em><span>一</span></em><span>γ</span><em><span>一</span></em><span>（</span><em><span>小号</span></em><span>）需要任何状态</span><em><span>小号</span></em><span>（最多）一个动作</span><em><span>一**A，A</span></em><span>）。</span></p><p><span>由于PBM域中所允许的不确定性，解决方案的定义为经典规划假设下的解决方案的定义。根据解决方案固有的偶然性，它可能是</span><em><span>虚弱的</span></em><span>，</span><em><span>坚强的</span></em><span>或</span><em><span>强循环</span></em><span>一个强大的解决方案保证实现的目标，无论域的不确定性性质。强循环解是保证实现目标的一种方法。</span><em><span>信念</span></em><span>，该状态说明了解决方案所预期的循环最终将终止（Giunchiglia and Traverso，1999）。</span></p><p><span>类似地，已经提出了几种算法，它们能够构造弱的（例如（CimaTi等人，1997）），强的（例如（Daniele等人，2000）或强循环（例如（CimaTi等人，1998）） ）溶液。这些算法有一个共同点，即它们总是终止。</span></p><p><span>由于现实世界问题涉及可能包含大量状态的模型，这些算法的实际实现通常诉诸于</span><em><span>符号模型检验</span></em><span>（Burh等人，1990）。在符号模型中，检查克里普克结构的可能状态的集合和状态之间的转换关系。</span><em><span>象征性地</span></em><span>通常使用表示状态中命题的真值的变量向量，从而允许更简单，重复冗余的状态表示和集合理论和逻辑运算的有效应用。规划是通过搜索状态集，而不是单独的状态来执行的，符号模型检查的表示和推理技术的实际实现经常使用二元决策图（BDDS）来执行（布莱恩特，1986）。</span></p><p><span>模型检查方法的规划的一个实现是MIPS（EdelkAMP和赫尔默特，2000），它是基于BDDS的。MIPS的主要优点是其预编译阶段，它标识隐式领域知识，例如状态不变量，当状态，时，MIPS实现了许多新的技术来提高BDD遍历的效率（EdelkAMP和赫尔默特，2000）。</span></p><p><span>确定性域的其他PBM实现是PROPLAN（FROWMAN，2000）和BDDPLAY（H·OrdodoBER和ST South-ORR，2000）；而，这些MIPS类的预编译阶段，因此在某些的域中没有达到MIPS的高级。</span></p><p><span>而MIPS，PROPLAY和BDDPLan则是为</span><em><span>确定性的</span></em><span>域，系统如MBP（基于模型的规划师）（Btotoi等人，2001）和UMPP（通用多代理OBDD为基础的规划师）（延森和VeloSO，2000）已经被设计为利用模型检查的关键优势，这是要处理的。</span><em><span>非确定性</span></em><span>环境：MBP可以处理初始情况下的不确定性，动作效果和执行动作的状态。它使用自己的动作描述语言NUPDDL，PDDL 2.1的变体，它可以表示初始状态的不确定性，不确定性的动作效果和非完美的感知动作。</span></p><p><span>类似地，UMPP使用其自己的域描述语言NADL（非确定性代理域语言）； NADL问题和域规范被翻译成符号克里普克结构，由OBDDs（布莱恩特，1986）表示。</span></p><h3><a name="5.4%E6%97%B6%E9%97%B4%E8%A7%84%E5%88%92" class="md-header-anchor"></a><span>5.4时间规划</span></h3><p><span>“时间规划”一词并不一定指狭义上的特定规划技术，而是指规划师应对的能力。</span><em><span>时间方面</span></em><span>规划领域和问题。大多数规划范式已经在某种程度上被扩展以支持规划的一些时间方面。这样的时间方面的例子是：</span></p><p><span>持续行动：在经典的规划方法中，行动通常被形式化为没有时间扩展。然而，在许多领域中，行动的持续时间开始着一定的作用。因此，精确的时间和时间效率的计划是计划人员兴趣的。</span></p><p><span>命题的有效间隔：在经典规划中，一个命题保持不变，直到它被操作员明确地改变。在现实世界中，许多流依赖于时间；例如，访问Web服务的权限可能仅在定义的时间间隔内有效。</span></p><p><span>并发动作：经典规划通常假设只有一个动作立即执行。POP及其偏序计划看起来像是一个例外，但并非偶然地计划此类行动中的时间并发性；它只是意味着这些行动是独立的，并且没有识别出它们的并发性的约束。然而，有些问题，</span><em><span>要求</span></em><span>这两个动作必须同时执行，因为顺序操作不会产生期望的结果。</span></p><p><span>•时间延长目标的规范（酒神巴克斯和KabANZA，1996），它既表达了实现某些最终状态的经典目标，又表达了一个替代的目标。</span><em><span>状态序列</span></em><span>。时间延长的目标也可以延长时间期限，安全和维护目标（焊接和EtZoii，1994；彭伯西和焊接，1992）。</span></p><p><span>问题</span><em><span>持续性行动</span></em><span>已经由早期规划者解决，如偏序策划NoLin（TATE，1977）和分段SIPE（威尔金斯，1988）规划师，并且也由最近的规划者，如VHPOP（Youes和西蒙斯，2003） ，LPG（Gerevini和Serina，2002）和MIPS（EdelkAMP和赫尔默特，2000）来解决。</span></p><p><em><span>时间扩展目标</span></em><span>已经解决了TLPLAN（酒神巴克斯和KabANZA，1995； BACCHUS和ADY，2001）系统，它支持在间隔时态逻辑（MITL）的扩展版本中指定的目标（ALUR等人，1996）。基于前向链规划引擎的。通常，向前链规划者（或状态空间规划者一般）通过确定其启发式值来评估状态对期望目标的贡献（见SeCT）。4.1）。TPLan采取了不同的方法。首先，每个状态都考虑到一个数据库，它检查目标公式的逆向公式，以及是否每个满足该公式的状态，因为这意味着它违背了期望目标的属性。应该注意的是，时间扩展的目标公式的概念可以扩展到</span><em><span>领域控制知识</span></em><span>通过指定希望识别的状态或期望的状态来对规划者进行编码。</span></p><p><span>TLPLAN的继承者是TALPlanner（KvnnStrum和Haslum，2001），它是TLPLAN，基于前向搜索，但是使用TAL语言替代了MITL来指定规划目标和域控制知识。 ，则用于推理在不完全指定的动态环境中的动作和变化。一个TAL目标（或控制）公式输入到TALplanner，然后生成一个包含目标（或控制）公式的解决方案。</span></p><h2><a name="6%E8%AE%A8%E8%AE%BA%E4%B8%8E%E5%B1%95%E6%9C%9B" class="md-header-anchor"></a><span>6讨论与展望</span></h2><p><span>我们现在将回顾我们先前讨论过的最重要的要求，我们将把它们与其最先进的规划系统的选择进行对比。我们为我们的问题场景确定的核心要求（视为SeCT）。2）是：</span></p><p><span>1。这个</span><em><span>领域复杂性</span></em><span>应该支持ADL的一个重要子集：例如，需要通用量化的效果来描述处理多个对象的Web服务（例如，从虚拟购物车中移除所有项目的操作）。感测动作和非确定性服务结果的显式标记也是理想的。</span></p><p><span>2。支持</span><em><span>复杂目标</span></em><span>（见教派）。3.3），即“提示”告诉规划师行动应该先于其他行动。这是几乎所有复杂问题所需要的，例如在比较购物中，解决方案是多个不同阶段的序列（得到价格）报价，做出决定，执行购买）。</span></p><p><span>3。初步已经提到的，处理问题的能力</span><em><span>不完全信息</span></em><span>（见教派）。3.2），例如，查询Web购物领域中的目录，是大多数Web服务域的核心需求。这又需要支持。</span><em><span>传感</span></em><span>帮助代理获取所需数据的动作（例如，返回在线零售商销售的产品列表的方法）</span></p><p><span>4。与支持感知动作有关的问题是规划者的能力。</span><em><span>动态添加（或删除）对象</span></em><span>（或来自）域，例如，添加关于从感测动作查询的产品信息的知识，或适当地在文档处理域中建模文件复制功能。</span></p><p><span>5。最后，我们非常需要处理这个问题。</span><em><span>非确定性行为</span></em><span>服务：Web服务操作可能在执行期间失败，或者它们可能产生意想不到的或不期望的结果；例如，旅行领域中的位置可能突然替换位置（可能违反了IRP假设），或者电子邮件复制方案中的图像转换操作可能失败。</span></p><p><span>在表1和表2中，我们对比了具有公认的规划者实现的集合与WSC问题的核心需求的集合。规划者列出在选项卡中。1是新古典主义。</span><a href='https://ziyanliupb.github.io/#'><span>七</span><span>]</span></a><span>规划师基于我们所讨论的技术。4，以及在选项卡中列出的工具。2是在SCT中讨论的具有控制知识的计划的实现。5。</span></p><p><span>表1显示，我们列出的大多数新古典规划者允许必要的复杂性的域描述，即ADL的一个重要子集。然而，除了SGP之外，SGP为不完整的初始状态和感测操作提供支持，这些规划者中的任何一个都不支持WSC的其他要求。</span></p><p><span>例如，MBP允许定义在时间上扩展的目标，GOOGO表示在，同时，使用领域控制知识的规划者为我们的需求提供了更多广泛的支持：他们支持复杂的领域，他们也可以提供复杂的目标。一个程序中的目标，如分支和迭代。因此，不确定性域可以通过提供权变处理代码来解决（例如，非确定性互换，这意味着策划者继续循环单元，实现了某些操作的期望效果） 。</span></p><p><span>这是否意味着WSC问题已经由有控制知识的规划者解决，而新古典规划者不能被用作此任务？</span></p><p><span>我们认为情况并非如此：尽管很明显，领域知识是解决WSC问题的关键，但目前还不清楚。</span><em><span>哪一个</span></em><span>领域知识的形式最适合</span><em><span>怎样</span></em><span>它应该被收集和编码。在这里，“软需求”，如接受目标开发商社区也是相关的。将预先存在的过程描述（OWL-S）转换为域控制信息（HTN方法）的想法（如Hendler）等人，2003）似乎是一种合理的方法：它不要求开发人员采用一种新的基于逻辑的语言，而是允许其使用广泛的过程工程技能。然而，（Hendler等人，2003）使用受限制的HTN规划变型，即有序任务分解规划，它不支持声明性目标任务。这意味着，代理只依赖于它所引发的任务列表，而不是试图自己找到“创造”的解决方案。类似地，不调用感测动作，因为</span><em><span>代理</span></em><span>标识这是一个有用的和务实的方法，很多领域，我们认为它仍然是有趣的寻找替代方法，使更多的灵活性，在代理的一部分，例如，处理的情况下，没有预先定义的策略还存在。</span></p><p><span>此外，领域无关的新古典规划师选项卡。1的问题远不能适用于WSC问题。然而，所需要的是一个适当的体系结构，它允许将规划问题分解成与新古典规划者的能力相匹配的一个子问题。</span></p><p><span>一个例子是执行监控和重新规划体系结构（例如（HAHY，1998）），其中控制器组件将问题转化为一系列简单的规划问题，并使用来自计划执行的反馈来更好地告知嵌入式规划人员的启发式。由于规划问题被分解成一系列的规划问题，动态对象创建和销毁的问题消失（因为世界在每个步骤中被重新创建），甚至对于感知规划者的规划也成为可能的（如同行，2004年A）非正式描述的规划师。</span></p><p><span>最后，有很多未解决的问题，一旦解决了问题，无论规划方法如何，都可能是非常有帮助的。一个中心问题是</span><em><span>自动领域分析</span></em><span>在本次调查中，我们讨论了几个计划实现，其表现令人满意他们的直接竞争，因为</span><em><span>自动生成</span></em><span>因此，从Web服务域中收集有用的控制知识似乎是值得的。同样，应用在预先阶段收集的领域知识（例如STAN，MIPS）。</span><em><span>学习技巧</span></em><span>（例如，基于早期运行的反馈）可以被认为是改进代理的计划启发。</span></p><p><strong><span>致谢</span></strong></p><p><span>最初工作得到了欧洲委员会和瑞士联邦教育和科学办公室在第六框架计划项目ReWiSE 506779和瑞士国家科学基金会2000年1月1日至10400年的支持。 Vukovic的评论和宝贵的反馈。</span></p><p>&nbsp;</p><p>&nbsp;</p><hr /></div>
</body>
</html>