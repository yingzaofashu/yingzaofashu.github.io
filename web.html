<!DOCTYPE html>
<!-- saved from url=(0047)file:///E:/GitHub/ziyanliupb.github.io/web.html -->
<html class="translated-ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width initial-scale=1">
<title>空值</title><style type="text/css">html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none 0s ease 0s; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }


html { font-size: 19px; }
html, body { margin: auto; background: rgb(254, 254, 254); }
body { font-family: Vollkorn, Palatino, Times; color: rgb(51, 51, 51); line-height: 1.4; text-align: justify; }
#write { max-width: 960px; margin: 0px auto 2em; line-height: 1.53; padding-top: 40px; }
#write > h1:first-child, h1 { margin-top: 1.6em; font-weight: normal; }
h1 { font-size: 3em; }
h2 { margin-top: 2em; font-weight: normal; }
h3 { font-weight: normal; font-style: italic; margin-top: 3em; }
h1, h2, h3 { text-align: center; }
h2::after { border-bottom: 1px solid rgb(47, 47, 47); content: ""; width: 100px; display: block; margin: 0px auto; height: 1px; }
h1 + h2, h2 + h3 { margin-top: 0.83em; }
p, .mathjax-block { margin-top: 0px; }
ul { list-style: square; padding-left: 1.2em; }
ol { padding-left: 1.2em; }
blockquote { margin-left: 1em; padding-left: 1em; border-left: 1px solid rgb(221, 221, 221); }
code, pre { font-family: Consolas, Menlo, Monaco, monospace, serif; font-size: 0.9em; background: white; }
.md-fences { margin-left: 1em; padding-left: 1em; border: 1px solid rgb(221, 221, 221); padding-bottom: 8px; padding-top: 6px; margin-bottom: 1.5em; }
a { color: rgb(36, 132, 193); text-decoration: none; }
a:hover { text-decoration: underline; }
a img { border: none; }
h1 a, h1 a:hover { color: rgb(51, 51, 51); text-decoration: none; }
hr { color: rgb(221, 221, 221); height: 1px; margin: 2em 0px; border-top: 1px solid rgb(221, 221, 221); border-bottom: none; border-left: 0px; border-right: 0px; }
.ty-table-edit { background: rgb(237, 237, 237); padding-top: 4px; }
table { margin-bottom: 1.33333rem; }
table th, table td { padding: 8px; line-height: 1.33333rem; vertical-align: top; border-top: 1px solid rgb(221, 221, 221); }
table th { font-weight: bold; }
table thead th { vertical-align: bottom; }
table caption + thead tr:first-child th, table caption + thead tr:first-child td, table colgroup + thead tr:first-child th, table colgroup + thead tr:first-child td, table thead:first-child tr:first-child th, table thead:first-child tr:first-child td { border-top: 0px; }
table tbody + tbody { border-top: 2px solid rgb(221, 221, 221); }
.task-list { padding: 0px; }
.md-task-list-item { padding-left: 1.6rem; }
.md-task-list-item > input::before { content: "√"; display: inline-block; width: 1.33333rem; height: 1.6rem; vertical-align: middle; text-align: center; color: rgb(221, 221, 221); background-color: rgb(254, 254, 254); }
.md-task-list-item > input:checked::before, .md-task-list-item > input[checked]::before { color: inherit; }
.md-tag { color: inherit; font: inherit; }
#write pre.md-meta-block { min-height: 35px; padding: 0.5em 1em; }
#write pre.md-meta-block { white-space: pre; background: rgb(248, 248, 248); border-width: 0px 30px; border-top-style: initial; border-bottom-style: initial; border-top-color: initial; border-bottom-color: initial; border-image: initial; color: rgb(153, 153, 153); width: 100vw; max-width: calc(100% + 60px); margin-left: -30px; border-left-style: solid; border-left-color: rgb(248, 248, 248); border-right-style: solid; border-right-color: rgb(248, 248, 248); margin-bottom: 2em; margin-top: -1.33333rem; padding-top: 26px; padding-bottom: 10px; line-height: 1.8em; font-size: 0.76em; padding-left: 0px; }
.md-img-error.md-image > .md-meta { vertical-align: bottom; }
#write > h5.md-focus::before { top: 2px; }
.md-toc { margin-top: 40px; }
.md-toc-content { padding-bottom: 20px; }
.outline-expander::before { color: inherit; font-size: 14px; top: auto; content: ""; font-family: FontAwesome; }
.outline-expander:hover::before, .outline-item-open > .outline-item > .outline-expander::before { content: ""; }
#typora-source { font-family: Courier, monospace; color: rgb(106, 106, 106); }
.html-for-mac #typora-sidebar { box-shadow: rgba(0, 0, 0, 0.176) 0px 6px 12px; }
.cm-s-typora-default .cm-header, .cm-s-typora-default .cm-property, .CodeMirror.cm-s-typora-default div.CodeMirror-cursor { color: rgb(66, 139, 202); }
.cm-s-typora-default .cm-atom, .cm-s-typora-default .cm-number { color: rgb(119, 119, 119); }
.typora-node .file-list-item-parent-loc, .typora-node .file-list-item-time, .typora-node .file-list-item-summary { font-family: arial, sans-serif; }
.md-task-list-item > input { margin-left: -1.3em; margin-top: calc(1rem - 12px); }
.md-mathjax-midline { background: rgb(250, 250, 250); }
.md-fences .code-tooltip { bottom: -2em !important; }
.dropdown-menu .divider { border-color: rgb(229, 229, 229); }

 .typora-export li, .typora-export p, .typora-export,  .footnote-line {white-space: normal;} 
</style>
<link type="text/css" rel="stylesheet" charset="UTF-8" href="file:///E:/GitHub/ziyanliupb.github.io/web_files/translateelement.css"></head>
<body class="typora-export os-windows" style="position: relative; margin-top: 36px !important;"><div class="head-bar" id="translate-head" style="background-color: rgb(240, 240, 240) !important; z-index: 99999 !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; position: fixed; width: 100%; height: 36px; border-bottom: 1px solid rgb(193, 193, 193); border-top: 1px solid rgb(255, 255, 255);"><img id="baidu_fanyi_logo" src="chrome-extension://edhchknefojhifoiebpcbkhcjlkkklci/imgs/map/logo.png" style="position: absolute; left: 15px; top: 6px; height: 21px; width: 66px;"><div id="select-translate-box" style="position: absolute; background-color: rgb(255, 255, 255); width: 238px; height: 23px; left: 110px; top: 6px; border-radius: 3px;"><div id="translate-head-from" class="translate-head-retranslate" style="line-height: 23px !important; cursor: pointer !important; width: 97px; height: 23px; position: absolute; border-radius: 3px; background-color: rgb(255, 255, 255); margin-right: 12px; box-sizing: border-box; display: flex; justify-content: center; align-items: center; padding-left: 0px;" data-click="no-click"><span id="detect-from" value="en" style="cursor: pointer !important; font-size: 12px !important; white-space: nowrap !important; color: rgb(51, 51, 51) !important; position: relative; background: initial; width: auto; max-width: 73px; overflow: hidden; text-overflow: ellipsis;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检测到英语</font></font></span><img id="select-icon-img" src="chrome-extension://edhchknefojhifoiebpcbkhcjlkkklci/imgs/map/arrow_down_nomal.png" style="cursor: pointer !important; position: relative; left: 5px; width: 9px; height: 5px;"><div class="select-inner-box" id="select-inner-from" style="position: absolute; left: 1px; top: 23px; width: 97px; height: 300px; overflow: auto; border-top: none; border-right: 1px solid rgb(240, 240, 240); border-bottom: 1px solid rgb(240, 240, 240); border-left: 1px solid rgb(240, 240, 240); border-image: initial; border-radius: 0px 0px 3px 3px; display: none; box-sizing: border-box;"><div value="zh" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中文</font></font></div><div value="en" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(67, 149, 255) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">英文</font></font></div><div value="jp" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">日语</font></font></div><div value="ara" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阿拉伯语</font></font></div><div value="est" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">爱沙尼亚语</font></font></div><div value="bul" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保加利亚语</font></font></div><div value="pl" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">波兰语</font></font></div><div value="dan" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">丹麦语</font></font></div><div value="de" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">德国人</font></font></div><div value="ru" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">俄语</font></font></div><div value="fra" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">法语</font></font></div><div value="fin" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">芬兰语</font></font></div><div value="kor" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">韩语</font></font></div><div value="nl" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">荷兰语</font></font></div><div value="cs" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">捷克语</font></font></div><div value="rom" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平民语</font></font></div><div value="pt" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">腐败</font></font></div><div value="swe" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">瑞典语</font></font></div><div value="slo" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">斯洛文尼亚</font></font></div><div value="th" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">泰语</font></font></div><div value="wyw" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文言文</font></font></div><div value="spa" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排名</font></font></div><div value="el" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">希腊语</font></font></div><div value="hu" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乌克兰语</font></font></div><div value="it" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合理的</font></font></div><div value="yue" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">粤语</font></font></div><div value="cht" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中文繁体</font></font></div></div></div><div id="select-change" style="width: 8px; height: 100%; position: absolute; left: 50%; display: flex; justify-content: center; align-items: center;"><img id="translate-icon" src="chrome-extension://edhchknefojhifoiebpcbkhcjlkkklci/imgs/map/right-arrow.png"></div><div id="translate-head-to" class="translate-head-retranslate" style="line-height: 23px !important; cursor: pointer !important; width: 97px; height: 23px; position: absolute; border-radius: 3px; right: 0px; background-color: rgb(255, 255, 255); box-sizing: border-box; display: flex; justify-content: center; align-items: center; padding-left: 0px;" data-click="no-click"><span id="detect-to" value="zh" style="cursor: pointer !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; position: relative; background: initial;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中文</font></font></span><img id="select-icon-img" src="chrome-extension://edhchknefojhifoiebpcbkhcjlkkklci/imgs/map/arrow_down_nomal.png" style="cursor: pointer !important; position: relative; left: 5px; width: 9px; height: 5px;"><div class="select-inner-box" id="select-inner-to" style="position: absolute; left: 1px; top: 23px; width: 97px; height: 300px; overflow: auto; border-top: none; border-right: 1px solid rgb(240, 240, 240); border-bottom: 1px solid rgb(240, 240, 240); border-left: 1px solid rgb(240, 240, 240); border-image: initial; border-radius: 0px 0px 3px 3px; display: none; box-sizing: border-box;"><div value="zh" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(67, 149, 255) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中文</font></font></div><div value="en" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">英文</font></font></div><div value="jp" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">日语</font></font></div><div value="ara" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阿拉伯语</font></font></div><div value="est" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">爱沙尼亚语</font></font></div><div value="bul" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保加利亚语</font></font></div><div value="pl" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">波兰语</font></font></div><div value="dan" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">丹麦语</font></font></div><div value="de" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">德国人</font></font></div><div value="ru" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">俄语</font></font></div><div value="fra" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">法语</font></font></div><div value="fin" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">芬兰语</font></font></div><div value="kor" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">韩语</font></font></div><div value="nl" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">荷兰语</font></font></div><div value="cs" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">捷克语</font></font></div><div value="rom" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平民语</font></font></div><div value="pt" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">腐败</font></font></div><div value="swe" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">瑞典语</font></font></div><div value="slo" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">斯洛文尼亚</font></font></div><div value="th" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">泰语</font></font></div><div value="wyw" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文言文</font></font></div><div value="spa" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排名</font></font></div><div value="el" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">希腊语</font></font></div><div value="hu" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乌克兰语</font></font></div><div value="it" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合理的</font></font></div><div value="yue" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">粤语</font></font></div><div value="cht" style="cursor: pointer !important; line-height: 25px !important; font-size: 12px !important; color: rgb(51, 51, 51) !important; box-sizing: border-box; padding-left: 11px; height: 25px; background-color: rgb(255, 255, 255);"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中文繁体</font></font></div></div></div></div><pt id="translate-head-ing" style="font-size: 12px !important; color: rgb(51, 51, 51) !important; position: fixed; left: 370px; top: 12px;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻译中...</font></font></pt><pt id="translate-head-timeout" style="font-size: 12px !important; color: rgb(51, 51, 51) !important; position: fixed; left: 370px; top: 12px; display: none;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻译超时，请稍后</font></font><a id="translate-head-retry" href="javascript:void(0)" style="color:#4395FF !important"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重试</font></font></a></pt><div id="src-reload" style="cursor: pointer !important; color: white !important; text-align: center !important; border-radius: 3px !important; font-size: 12px !important; line-height: 23px !important; position: fixed; left: 350px; top: 7px; height: 23px; background-color: rgb(67, 149, 255); border: none; width: 100px; margin: 0px 0px 0px 19px;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示财经</font></font></div><div id="translate-head-cross"><img id="translate-head-cross-img" style="cursor: pointer !important; float: right; margin-right: 20px; margin-top: 8px; width: 18px;" src="chrome-extension://edhchknefojhifoiebpcbkhcjlkkklci/imgs/map/close.png"></div><a id="fanyi_baidu_com" href="javascript:void(0)" style="float:right;margin-right:15px;margin-top:11px;text-decoration: none;font-size:12px !important;color:#333 !important"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进入百度翻译</font></font></a><a id="tousu_baidu_com_fanyi_add" href="javascript:void(0)" style="float:right;margin-right:15px;margin-top:11px;text-decoration: none;font-size:12px !important;color:#333 !important"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提交建议与反馈</font></font></a></div><div id="write" class="is-node"><p><span><trans data-src="Web Service Composition as AI Planning – a Survey[" data-dst="作为AI规划的Web服务组合——一项调查"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为AI规划的Web服务组合-一项调查</font></font></trans></span><a href="https://ziyanliupb.github.io/#"><span><trans data-src="1" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span><span><trans data-src="]" data-dst="]"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]</font></font></trans></span></a></p><p><span><trans data-src="Joachim Peer" data-dst="约阿希姆同辈"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约阿希姆同辈</font></font></trans></span></p><p><span><trans data-src="March 22, 2005" data-dst="2005年3月22日"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2005年3月22日</font></font></trans></span></p><p><strong><span><trans data-src="Abstract" data-dst="摘要"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要</font></font></trans></span></strong></p><p><span><trans data-src="This article gives an overview of AI (Artificial Intelligence) planning techniques and discusses their application to the Web service composition problem." data-dst="本文概述了人工智能（AI）规划技术，并讨论了它们在Web服务组合问题中的应用。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本文概述了人工智能（AI）规划技术，并讨论了它们在Web服务组合问题中的应用。</font></font></trans></span><span></span></p><p><strong><span><trans data-src="Contents" data-dst="目录"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目录</font></font></trans></span></strong></p><p><strong><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1简介和动机.............................................. .................................... 3</font></font></span></strong></p><p><strong><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2种情况...................................................... ................................................... ............ 5</font></font></span></strong></p><p><strong><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3初稿................................................ ................................................... ..... 6</font></font></span></strong></p><p><a href="https://ziyanliupb.github.io/#"><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1规范规划领域.................................... ........................ 6</font></font></span></a></p><p><a href="https://ziyanliupb.github.io/#"><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2正式化初始世界.................................... ...................... 9</font></font></span></a></p><p><a href="https://ziyanliupb.github.io/#"><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3正式制定目标.............................................. ................................................... 11</font></font></span></a></p><p><a href="https://ziyanliupb.github.io/#"><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4代表计划............................................... .................................................... 13</font></font></span></a></p><p><strong><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4基本规划范式.............................................. ................................ 14</font></font></span></strong></p><p><a href="https://ziyanliupb.github.io/#"><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1基于状态空间的规划........................................... ................................. 14</font></font></span></a></p><p><a href="https://ziyanliupb.github.io/#"><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2基于图的计划..................................... ............................................................... 18</font></font></span></a></p><p><a href="https://ziyanliupb.github.io/#"><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3部分订单优化计划................................. ................... 22</font></font></span></a></p><p><a href="https://ziyanliupb.github.io/#"><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4规划为可满足性.................................... ................................... 26</font></font></span></a></p><p><a href="https://ziyanliupb.github.io/#"><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4.1作为命题可满足性进行规划........................................... ........... 27</font></font></span></a></p><p><a href="https://ziyanliupb.github.io/#"><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4.2规划描述逻辑可满足性.......................................... ..... 28</font></font></span></a></p><p><a href="https://ziyanliupb.github.io/#"><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4.3作为Petri网可达性进行规划..................................................... ..................... 29</font></font></span></a></p><p><a href="https://ziyanliupb.github.io/#"><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5作为逻辑编程进行规划.................................... ........................ 30</font></font></span></a></p><p><strong><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5具有控制知识的计划.................................... ................... 31</font></font></span></strong></p><p><a href="https://ziyanliupb.github.io/#"><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1分层任务网络规划.................................... ................................ 31</font></font></span></a></p><p><a href="https://ziyanliupb.github.io/#"><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2高级程序执行..................................................... ..................................... 33</font></font></span></a></p><p><a href="https://ziyanliupb.github.io/#"><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3计划作为模型检查.................................... ............................................. 36</font></font></span></a></p><p><a href="https://ziyanliupb.github.io/#"><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.4时间规划............................................... ..................................................... 39</font></font></span></a></p><p><strong><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6讨论与展望.............................................. .................................... 41</font></font></span></strong></p><p><span></span></p><h2><a name="1-introduction-and-motivation" class="md-header-anchor"></a><span><trans data-src="1 Introduction and Motivation" data-dst="1引言和动机"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1引言和动机</font></font></trans></span></h2><p><span><trans data-src="Web services are distributed software components that can be exposed and invoked over the internet using standard protocols. This concept was put forward by major IT companies like Microsoft, IBM and Sun as a Webcompatible solution for distributed computing, with the particularly attractive property of being an open, fully standardized and vendor neutral approach." data-dst="Web服务是可以使用标准协议在因特网上公开和调用的分布式软件组件。这一概念是由诸如微软、IBM和Sun这样的主要IT公司提出的，它是一种用于分布式计算的兼容Web的解决方案，具有特别开放的、完全标准化和供应商中立的特性。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Web服务是可以使用标准协议在内部上公开和调用的分布式软件组件。这一概念是由那种微软，IBM和Sun这样的主要IT公司提出的，它是一种用于分布式计算的兼容Web的解决方案，具有特别开放的，完全规范和供应商中立的特性。</font></font></trans></span></p><p><span><trans data-src="Web services communicate with their clients and with other Web services by sending XML based messages over the internet. The signatures of the operations a Web service offers and the message formats it supports form its" data-dst="Web服务通过在因特网上发送基于XML的消息来与客户端和其他Web服务进行通信。Web服务提供的操作的签名及其所支持的消息格式构成其"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Web服务通过在异步上发送基于XML的消息来与客户端和其他Web服务进行通信。Web服务提供的操作的签名及其所支持的消息格式构成其</font></font></trans></span><em><span><trans data-src="interface" data-dst="接口"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接口</font></font></trans></span></em><span><trans data-src=". Commonly, interface description languages (IDLs) such as the Web Service Description Language WSDL (W3C, 2002) are used to describe the service interface." data-dst=". 通常，使用诸如Web服务描述语言WSDL（W3C，2002）的接口描述语言（IDL）来描述服务接口。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">通常，使用某种Web服务描述语言WSDL（W3C，2002）的接口描述语言（IDL）来描述服务接口。</font></font></trans></span></p><p><span><trans data-src="WSDL allows for decoupling abstract descriptions of service types (called" data-dst="WSDL允许对服务类型的抽象描述进行解耦（称为"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WSDL允许对服务类型的抽象描述进行解定义（称为</font></font></trans></span><em><span><trans data-src="Port Types" data-dst="端口类型"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">港口类型</font></font></trans></span></em><span><trans data-src=") from concrete implementations of the services. Therefore, a single Port Type description can be used for multiple services of similar type. This allows for the definition of" data-dst="）从服务的具体实现。因此，单端口类型描述可用于类似类型的多个服务。这允许定义"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）从服务的具体实现。因此，单端口类型描述可用于类似类型的多个服务。这允许定义</font></font></trans></span><em><span><trans data-src="standardized" data-dst="标准化"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标准化</font></font></trans></span></em><span><trans data-src="service interfaces, and participants with a common interest can jointly reach agreements on the semantics of those descriptions. Based on such agreements, client applications may be crafted to use the Web services, and complex processes involving several services may be composed, for instance using the BPEL4WS (IBM et al., 2002) process description language." data-dst="服务接口和具有共同兴趣的参与者可以共同地对这些描述的语义达成协议。基于这样的协议，可以使用Web服务来编写客户端应用程序，并且可以使用涉及BPEL4WS（IBM等，2002）过程描述语言的复杂服务来处理涉及多个服务的复杂过程。" style="background: transparent;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务接口和具有共同兴趣的参与者可以共同地对这些描述的语义达成协议。基于这样的协议，可以使用Web服务来编写客户端应用程序，并且可以使用涉及BPEL4WS（IBM等，2002）过程描述语言的复杂服务来处理涉及多个服务的复杂过程。</font></font></trans></span></p><p><span><trans data-src="A problem of this approach becomes immanent when services diverge from the initial agreements. For instance, when a service changes its implementation (e.g. to refine its service offerings) its semantics and probably its syntactic interface will change. Since there is no formal machine interpretable connection defined between the semantics and the syntactic interface, human intervention is needed to decide whether the service is still compatible with the agreed semantics or not." data-dst="当服务与初始协议背离时，这种方法的问题就变成了内在的问题。例如，当服务改变其实现（例如，细化其服务提供）时，它的语义和句法接口可能会改变。由于在语义和句法接口之间没有定义形式的机器可解释连接，所以需要人为干预来决定服务是否仍然与约定的语义兼容。" style="background: transparent;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，当服务改变其实现（例如，细化其服务提供）时，它的语义和句法接口可能会改变。由于，当服务与初始协议背离时，这种方法的问题就变成了内在的问题。在语义和句法接口之间没有定义形式的机器可解释连接，所以需要人为干预来决定服务是否仍然与约定的语义兼容。</font></font></trans></span></p><p><span><trans data-src="A way of addressing this limitation is writing down a sufficiently large part of the semantics of a service in a" data-dst="解决这一限制的一种方法是将一个服务中的语义的一个足够大的部分写下来。" style="background: transparent;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决这一限制的一种方法是将一个服务中的语义的一个足够大的部分写下来。</font></font></trans></span><em><span><trans data-src="formal machine interpretable" data-dst="形式机器解释"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形式机器解释</font></font></trans></span></em><span><trans data-src="fashion, quite analogous to the syntactic interface. This reduces the dependency on external semantic agreements that are often difficult to reach, must be reached for each new service type, and must be re-evaluated after each modification of a Web service. Instead, the semantic descriptions provide software agents with a way to autonomically reason about the service’s semantics, i.e. the preconditions and consequences of its operations." data-dst="时尚，非常类似于句法界面。这减少了对外部语义协议的依赖性，这些语义协议通常难以达到，必须针对每个新的服务类型来实现，并且必须在Web服务的每次修改之后重新评估。相反，语义描述为软件代理提供了一种自主地推理服务的语义的方法，即其操作的前提和后果。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这减少了对外部语义协议的替代，这些语义协议通常难以达到，必须针对每个新的服务类型来实现，并且必须在Web服务的每次修改之后重新评估。相反，语义描述为软件代理提供了一种自主地推理服务的语义的方法，即其操作的本身和后果。</font></font></trans></span></p><p><span><trans data-src="In an environment of semantically annotated services, users who need to achieve certain goals could be assisted by software agents which automatically identify and, if necessary, dynamically compose services in order to accomplish the user’s goals, which may be either explicitly stated or derived from the situation the user is in." data-dst="在语义注释服务的环境中，需要实现某些目标的用户可以由软件代理来协助，该软件代理自动识别并在必要时动态地组成服务以完成用户的目标，其可以明确地陈述或衍生自用户所处的情况。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在语义注释服务的环境中，需要实现某些目标的用户可以由软件代理来协助，该软件代理自动识别并在必要时动态地构成服务以完成用户的目标，其可以明确地陈述或衍生自用户所处的情况。</font></font></trans></span></p><p><span><trans data-src="However, dynamic composition of services is a hard problem and it is not entirely clear which techniques serve the problem best. One family of techniques that has been proposed for this task is AI (Artifical Intelligence) planning. Planning is a complex problem which has been investigated extensively by AI research. (Russel and Norvig, 1995) characterize the problem of planning as follows : “Planning can be interpreted as a kind of problem solving, where an agent uses its beliefs about available actions and their consequences, in order to identify a solution over an abstract set of possible plans”." data-dst="然而，动态的服务组合是一个困难的问题，目前还不清楚哪些技术最好地服务于这个问题。一个家庭的技术已经提出了这个任务是人工智能（AI）规划。规划是一个复杂的问题，已被广泛研究的人工智能研究。（Russel和诺维格，1995）将规划问题描述如下：“规划可以被解释为一种解决问题的方法，其中一个代理使用其对可用行为及其后果的信念，以便在一组抽象的可能计划中识别出一个解决方案”。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然而，动态的服务组合是一个困难的问题，目前还不清楚什么技术最好地服务于这个问题。一个家庭的技术已经提出了这个任务是人工智能（AI）规划。规划是一个复杂的问题， （罗素和诺维格，1995）将规划问题描述如下：“规划可以被解释为一种解决问题的方法，其中一个代理使用其对可用行为及其后果的信念”。 ，盔甲在一个抽象的可能计划中识别出一个解决方案”。</font></font></trans></span></p><p><span><trans data-src="Recently, several papers, e.g. (McDermott, 2002; Srivastava and Koehler, 2003; Carman et al., 2003; Sirin and Parsia, 2004), have investigated the potentials and boundaries of applying" data-dst="最近，一些论文，例如（德莫特，2002；Sravasava和Koehler，2003；Carman等人，2003；SiRin和PARSIA，2004），已经研究了应用的潜力和边界。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最近，一些论文，例如（德莫特，2002； Sravasava和Koehler，2003； Carman等人，2003； SiRin和PARSIA，2004），已经研究了应用的潜力和边界。</font></font></trans></span><em><span><trans data-src="AI planning techniques" data-dst="人工智能规划技术"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人工智能规划技术</font></font></trans></span></em><span><trans data-src="to derive web service processes that achieve the desired goals. In this report we aim to extend this research by providing a survey of the most important planning techniques and by discussing their suitability for dynamic Web service composition." data-dst="导出实现预期目标的Web服务进程。在这份报告中，我们的目的是延长这项研究提供最重要的规划技术的调查，并讨论其适用于动态Web服务组合。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这份报告中，我们的目的是延长后续研究提供最重要的规划技术的调查，并讨论其适用于动态Web服务组合。</font></font></trans></span></p><p><span><trans data-src="The remainder of the article is organized as follows: in Sect. 2 we list the scenarios we gather our requirements from. In Sect. 3 we discuss the relevant conceptual frameworks of planning. We then proceed to the discussion of basic planning paradigms in Sect. 4 and knowledge oriented planning paradigms in Sect. 5. We then contrast a collection of representative planning engines against our identified core requirements and discuss the results and possible directions for future work." data-dst="文章的其余部分整理如下：2我们列出了我们收集需求的场景。在教派中。3，讨论规划的相关概念框架。然后，我们讨论的基本规划范式在教派。4、知识导向的规划范式。5。然后，我们对比一个有代表性的计划引擎的集合与我们所确定的核心要求，并讨论结果和未来工作的可能方向。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文章的其余部分整理如下：2我们列出了我们收集的需求的场景。在教派中。3，讨论规划的相关概念框架。然后，我们讨论的基本规划范式在教派。4，知识导向的规划范式。 5。然后，我们对比一个有预期的计划引擎的集合与我们所确定的核心要求，并讨论结果和未来工作的可能方向。</font></font></trans></span></p><h2><a name="2---scenarios" class="md-header-anchor"></a><span><trans data-src="2   Scenarios" data-dst="2个月"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2个月</font></font></trans></span></h2><p><span><trans data-src="To assess the importance of the various potential requirements we are confronted with, we consider the following collection of Web service domains:" data-dst="为了评估我们面临的各种潜在需求的重要性，我们考虑以下Web服务域的集合："><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了评估我们面临的各种潜在需求的潜力，我们考虑以下Web服务域的集合：</font></font></trans></span></p><p><span><trans data-src="•    The" data-dst="•The"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">•</font></font></trans></span><em><span><trans data-src="Web shopping" data-dst="网上购物"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网上购物</font></font></trans></span></em><span><trans data-src="domain (Peer, 2004b): A collection of services that offer capabilities to browse catalogs and purchase goods. Possible goals are to find and purchase one or more products, possibly at best price." data-dst="域名（Peer-No.44B）：提供浏览目录和购买商品的服务的集合。可能的目标是找到并购买一个或多个产品，可能以最好的价格。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">域名（Peer-No.44B）：提供浏览目录和购买商品的服务的集合。可能的目标是找到并购买一个或多个产品，可能以最好的价格。</font></font></trans></span></p><p><span><trans data-src="•    The" data-dst="•The"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">•</font></font></trans></span><em><span><trans data-src="document handling" data-dst="文件处理"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件处理</font></font></trans></span></em><span><trans data-src="domain (Peer, 2004b), which is similar to the Softbots domain in (Golden, 1997): The services offer functions to manipulate files, for instance to convert, compress or encrypt them. Possible goals are series of document transformations, e.g. to convert and package a collection of documents." data-dst="域（对等体，No.44b），类似于（金，1997）中的StftBOTS域：服务提供操作文件的功能，例如转换、压缩或加密文件。可能的目标是一系列文档转换，例如转换和打包文档集合。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">域（对等体，No.44b），尺寸（金，1997）中的StftBOTS域：服务提供操作文件的功能，例如转换，压缩或加密文件。可能的目标是多种文档转换，例如转换和打包文档集合。</font></font></trans></span></p><p><span><trans data-src="•    The" data-dst="•The"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">•</font></font></trans></span><em><span><trans data-src="mail replication" data-dst="邮件复制"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">邮件复制</font></font></trans></span></em><span><trans data-src="domain (Vukovic and Robinson, 2004): This domain combines electronic mail-related services, i.e. SOAP interfaces to SMTP and POP servers, with services in the document handling domain (cf. above). Typical goals in this domain are the sending and receiving of messages, and the context depended adaption of the behavior of the mail system, e.g. context- and user-dependent display, involving text translation and image conversion services." data-dst="域（Vukovic和鲁滨孙，2004）：该域将电子邮件相关服务（即SOAP接口与SMTP和POP服务器）结合在文档处理域中的服务（参见上文）。该领域中的典型目标是消息的发送和接收，以及上下文相关的邮件系统的行为适应，例如上下文和用户相关的显示，涉及文本翻译和图像转换服务。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">域（Vukovic和鲁滨孙，2004）：该域将电子邮件相关服务（即SOAP接口与SMTP和POP服务器）结合在文档处理域中的服务（见上文）。该领域中的典型目标是消息的发送和接收，以及其他相关的邮件系统的行为适应，例如某些和用户相关的显示，涉及文本翻译和图像转换服务。</font></font></trans></span></p><p><span><trans data-src="•    The" data-dst="•The"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">•</font></font></trans></span><em><span><trans data-src="traveling" data-dst="旅游"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旅游</font></font></trans></span></em><span><trans data-src="domain (McIlraith and Son, 2002): The services in this domain offer the capability to query and book air tickets and accommodation for travelers. A typical problem of this domain is to plan for a conference attendance, which often involves additional user-defined constraints to be satisfied (e.g. the date of the conference, preferences for certain hotels or airlines)." data-dst="域名（McIlraith和儿子，2002）：在这个领域的服务提供查询和预订机票和住宿旅客的能力。该领域的一个典型问题是计划会议出席，这通常涉及满足用户定义的额外约束（例如会议的日期、某些酒店或航空公司的偏好）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">域名（McIlraith和儿子，2002）：在这个领域的服务提供查询和预订机票和住宿旅客的能力。该领域的一个典型问题是计划会议出席，这通常涉及满足用户定义的额外约束（例如会议的日期） ，某些酒店或航空公司的偏好）。</font></font></trans></span></p><h2><a name="3-----------preliminaries" class="md-header-anchor"></a><span><trans data-src="3           Preliminaries" data-dst="3预赛"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3预赛</font></font></trans></span></h2><p><span><trans data-src="In general, a planning problem has the following components:" data-dst="一般来说，规划问题有以下几个组成部分："><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初步，规划问题有以下几个组成部分：</font></font></trans></span></p><p><span><trans data-src="•    a description of the possible actions which may be executed (a domain theory) in some formal language." data-dst="描述在某种形式语言中可能执行的可能的行为（域理论）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述在某种形式语言中可能执行的可能的行为（域理论）。</font></font></trans></span></p><p><span><trans data-src="•    a description of the initial state of the world" data-dst="描述世界的初始状态"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述世界的初始状态</font></font></trans></span></p><p><span><trans data-src="•    a description of the desired goal" data-dst="描述期望的目标"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述期望的目标</font></font></trans></span></p><p><span><trans data-src="In the following sections, we present the most important approaches to define the components of a planning problem and we will contrast them with the requirements of Web service composition problems." data-dst="在下面的部分中，我们提出了最重要的方法来定义规划问题的组成部分，并将它们与Web服务组合问题的要求进行对比。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在下面的部分中，我们提出了最重要的方法来定义规划问题的组成部分，相互之间与Web服务组合问题的要求进行对比。</font></font></trans></span></p><h3><a name="3.1---------formalizing-the-planning-domain" class="md-header-anchor"></a><span><trans data-src="3.1         Formalizing the planning domain" data-dst="3.1规划领域的形式化"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1规划领域的形式化</font></font></trans></span></h3><p><span><trans data-src="The aim of domain formalization is to provide a" data-dst="领域形式化的目的是提供一个"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">领域形式化的目的是提供一个</font></font></trans></span><em><span><trans data-src="domain theory" data-dst="领域理论"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">领域理论</font></font></trans></span></em><span><trans data-src=", i.e. a formal account of the semantics of the operations that are available or relevant to the agent. These operations can represent physical operations (e.g. defined by a robot’s physical environment) but can also represent more abstract actions (e.g. withdrawing money from a bank account)." data-dst="，即对代理可用或相关的操作的语义的正式解释。这些操作可以表示物理操作（例如由机器人的物理环境定义），但也可以表示更抽象的动作（例如从银行账户中取出钱）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，，即对代理可用或相关的操作的语义的正式解释。。这些操作可以表示物理操作（例如由机器人的物理环境定义），但也可以表示更抽象的动作（例如从银行帐户中取钱）。</font></font></trans></span></p><p><span><trans data-src="A domain theory must formally define the" data-dst="一个领域理论必须正式定义"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个领域理论必须正式定义</font></font></trans></span><em><span><trans data-src="causal laws" data-dst="因果律"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因果律</font></font></trans></span></em><span><trans data-src="of the operations, i.e. it must allow to axiomatize relevant aspects such as the preconditions of operations and their effects to the world. Usually, domain theories follow some state-transition model, i.e. they introduce a notion of" data-dst="的操作，即它必须允许公理化相关的方面，如操作的先决条件及其对世界的影响。通常，领域理论遵循某种状态转移模型，即他们引入了一个概念。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的操作，即它必须允许公理化相关的方面，如操作的先决条件及其对世界的影响。通常，领域理论上以某种状态转移模型，即他们约会了一个概念。</font></font></trans></span><em><span><trans data-src="state" data-dst="状态"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态</font></font></trans></span></em><span><trans data-src="(or situation), which is a snapshot that describes the world at a certain point in time and they relate actions to transitions between such states. Most approaches define a state extensionally as a set of ground atomic formulas (atoms), where atoms that may change their value over time are called" data-dst="（或情境），它是在某个时间点描述世界的快照，它们将动作与这些状态之间的转换联系起来。大多数方法将一个状态定义为一组地面原子公式（原子），其中原子随时间变化的值称为原子。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（或情境），它是在某个时间点描述世界的快照，它们将动作与这些状态之间的转换联系起来。大多数方法将一个状态定义为一组地面原子公式（原子），其中原子随时间变化的值称为原子。</font></font></trans></span><em><span><trans data-src="fluents" data-dst="氟离子"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">氟离子</font></font></trans></span></em><span><trans data-src="and those that do not change are called" data-dst="那些不改变的叫做"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那些不改变的叫做</font></font></trans></span><em><span><trans data-src="state invariants" data-dst="状态不变量"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态不变量</font></font></trans></span></em><span><trans data-src="." data-dst="."><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></trans></span></p><p><span><trans data-src="Regarding the epistemological principles domain theories are based on, we can distinguish two variants: domain theories based on classical logics and extra-logical domain theories." data-dst="关于领域理论的认识论原则，我们可以区分两种变体：基于经典逻辑的领域理论和超逻辑域理论。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于领域理论的认识论原则，我们可以区分两种变体：基于经典逻辑的领域理论和超逻辑域理论。</font></font></trans></span></p><p><span><trans data-src="Among the logical approaches is the situation calculus, which was introduced by (McCarthy, 1963) and later refined by (Levesque et al., 1998; Pirri and Reiter, 1999), who define the situation calculus as a second-order framework designed for representing dynamically changing worlds in classical first-order language. The situation calculus represents the world and its change as sequence of situations, where each situation is a term that represents a state and is obtained by executing an action[" data-dst="在逻辑方法中，情境演算是由（麦卡锡，1963）引入的，后来被（LaveSK等人，1998；Pirri和赖特，1999）精炼，他们把情境演算定义为一个二阶框架，被设计用于代表经典的一阶语言中的动态变化的世界。情形演算代表世界和它作为情形序列的变化，其中每种情况都是表示状态的术语，通过执行一个动作而获得。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在逻辑方法中，情境演算是由（麦卡锡，1963）约会的，后来被（LaveSK等人，1998； Pirri和赖特，1999）精炼，他们把情境演算定义为一个二阶框架，被设计用作代表算术的代表世界和它作为一系列序列的变化，其中某些情况都是表示状态的术语，通过执行一个动作而获得。</font></font></trans></span><a href="https://ziyanliupb.github.io/#"><span><trans data-src="2" data-dst="二"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二</font></font></trans></span><span><trans data-src="]" data-dst="]"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]</font></font></trans></span></a><span><trans data-src="." data-dst="."><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></trans></span></p><p><span><trans data-src="Another approach for encoding operations into first order predicate logics is the" data-dst="将操作编码成一阶谓词逻辑的另一种方法是"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将操作编码成一阶谓词逻辑的另一种方法是</font></font></trans></span><em><span><trans data-src="event calculus" data-dst="事件演算"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件演算</font></font></trans></span></em><span><trans data-src="(Kowalski and Sergot, 1989). In the event calculus, events initiate periods during which certain properties hold. A property is initiated by an event and continues to hold until some event occurs that terminates it. The events, their effects and durations are expressed in Horn logic." data-dst="（科瓦尔斯基和塞尔格，1989）。在事件演算中，事件启动某些属性保持的周期。一个属性由一个事件启动并继续保持直到一些事件终止。事件，它们的影响和持续时间用喇叭逻辑来表示。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（科瓦尔斯基和塞尔格，1989）。在事件演算中，事件启动某些属性保持的周期。一个属性由一个事件启动并继续保持直到一些事件终止。事件，它们的影响和持续时间用喇叭逻辑来表示。</font></font></trans></span></p><p><span><trans data-src="Yet another approach based on logic are action theories based on modal logics, as discussed by (Giacomo and Lenzerini, 1995; Castilho et al., 1999; Giordano et al., 1998). Like the situation calculus, the modal approaches define a system of world states where the actions are modeled as transitions between those states. Modal logic approaches allow for a very natural modeling of actions as state transitions, by conceptualizing them as" data-dst="另一种基于逻辑的方法是基于模态逻辑的行动理论，如（Giacomo和LeZrRiNi，1995；CasTiHo等人，1999；佐丹奴等人，1998）所讨论的。与情形演算一样，模态方法定义了世界状态系统，其中行为被建模为这些状态之间的转换。模态逻辑的方法允许一个非常自然的行为建模作为状态转换，通过概念化为"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一种基于逻辑的方法是基于模态逻辑的行动理论，如（Giacomo和LeZrRiNi，1995； CasTiHo等人，1999；佐丹奴等人，1998）所讨论的。世界状态系统，其中行为被建模为这些状态之间的转换。模态逻辑的方法允许一个非常自然的行为建模作为状态转换，通过概念化为</font></font></trans></span><em><span><trans data-src="accessibility relations" data-dst="可达性关系"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可达性关系</font></font></trans></span></em><span><trans data-src="in Kripke structures. As we will see later in Sect. 5.3, Kripke structures are indeed practically used to represent nondeterministic domains." data-dst="在克里普克结构中。正如我们稍后将看到的宗派。5.3，克里普克结构确实被用来表示非确定性域。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3，克里普克结构确实被称为表示非确定性域。</font></font></trans></span></p><p><span><trans data-src="Despite the advantages of these pure logic based approaches, such as the precise semantics and the ability to prove certain properties of domain theories, the AI planning community largely uses different formalisms to express planning domains. These formalisms are largely rooted in the STRIPS (Fikes and Nilsson, 1971) notation, which was used in the 1970ies to describe planning domains for a robot system called “Shakey”. STRIPS allows to define operators directly by specifying a precondition, an ADD-list and a DELETElist, all represented as conjunctions of atoms. Intuitively, the semantics of such an operator description is that an operation is only applicable if the precondition is satisfied by the current world state (represented as a database), and that after execution of the operation the atoms of the ADD-list will be added to the world state and the atoms of the DELETE-list will be removed. However, the precise logical semantics of STRIPS has been a subject of debate for long time, with different proposals put forward, e.g. (Lifschitz, 1986; Reiter, 2001)." data-dst="尽管这些基于纯逻辑的方法的优点，如精确语义和证明领域理论的某些性质的能力，人工智能规划社区在很大程度上使用不同的形式主义来表示规划域。这些形式主义主要植根于条带（Fikes and尼尔森，1971）符号中，用于1970ES描述机器人系统的规划域，称为“SaKEY”。条带允许通过指定预条件、添加列表和删除符直接定义运算符，所有这些都表示为原子的连接。直观地说，这样的操作符描述的语义是：如果当前世界状态（表示为数据库）满足了前提条件，则只适用于操作，并且在执行操作之后，将添加列表的原子添加到世界状态，并且删除列表的原子将被移除。然而，条带的精确逻辑语义一直是一个争论的话题，提出了不同的建议，例如（LIFSCIZ，1986；ReITER，2001）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管这些基于纯逻辑的方法的优点，如精确语义和证明领域理论的某些性质的能力，人工智能规划社区在使用不同的形式主义来表示规划域。这些形式主义主要植根于条带允许通过指定预条件，添加列表和删除符号直接定义运算符，所有这些都表示为原子的连接。直观而言，这样的操作符描述的语义是：如果当前世界状态（表示为数据库）满足了条件，则只适用于操作，并且在执行操作之后，将添加列表的原子添加然而，条带的精确逻辑语义一直是一个争议的话题，提出了不同的建议，例如（LIFSCIZ，1986； ReITER，2001）。</font></font></trans></span></p><p><span><trans data-src="The ADL language (Pednault, 1989; Pednault, 1994) provides support for more expressive operator descriptions and narrows the gap between the semantically ambiguous STRIPS and the declarative situation calculus: ADL allows the definition of context dependent effects, universally quantified effects (for instance needed to model the transportation of goods using a truck), negation and disjunction." data-dst="ADL语言（PotoNuLTE，1989；PitoNaLUT，1994）为更具表现力的操作符描述提供了支持，并缩小了语义歧义条带和声明性情境演算之间的差距：ADL允许定义上下文相关效应、普遍量化的效果（例如，需要使用卡车运输货物的模型）、否定和析取。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADL语言（PotoNuLTE，1989； PitoNaLUT，1994）为表达表现力的操作符号描述提供了支持，并缩小了语义歧义条带和声明性情境演算之间的差异：的效果（例如，需要使用卡车运输货物的模型），否定和析取。</font></font></trans></span></p><p><span><trans data-src="Over the time, many AI planning systems have been developed, supporting different levels of expressivity, in many cases in a middle ground between ADL and STRIPS, sometimes even beyond, e.g. to express temporal reasoning, metrics, task networks, etc. This resulted in a wide range of “ad-hoc” formats, whose semantics have often been ambiguous. To address this problem, the Planning Domain Definition Language (PDDL) (Ghallab et al., 1998) was developed to serve as a standard domain (and problem) specification language, to ease the comparison of the various systems. PDDL allows to define domains of the expressivity of ADL, including metric fluents, and defines rules for standard-compliant extensions. Successor versions of the original PDDL version are PDDL 2.1 (Fox and Long, 2003) which added a notion of time and PDDL 2.2 which adds derived predicates and timed initial literals. Several other extensions have been proposed, for instance (Bertoli et al., 2003) which extends PDDL to express nondeterminism, limited sensing and iterative conditional plans." data-dst="随着时间的推移，许多人工智能规划系统已经被开发出来，支持不同的表达水平，在许多情况下，在ADL和条带之间的中间位置，有时甚至超出，例如表达时间推理、度量、任务网络等。这导致了广泛的“ad-hoc”格式，其语义通常是模糊的。为了解决这个问题，规划域定义语言（PDDL）（GHALAB等，1998）被开发为标准域（和问题）规范语言，以缓解各种系统的比较。PDDL允许定义ADL的表现力域，包括度量流，并定义标准兼容扩展的规则。原始PDDL版本的后继版本是PDDL 2.1（Fox and Lon，2003），它增加了时间概念和PDDL 2.2，它增加了派生谓词和定时初始文字。已经提出了几个其他扩展，例如（Bertoli等人，2003），它扩展PDDL来表示非确定性、有限感知和迭代条件计划。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随着时间的推移，许多人工智能规划系统已经被开发出来，支持不同的表达水平，在许多情况下，在ADL和条带之间的中间位置，有时甚至超过，例如表达时间推理，尺度，任务为了解决这个问题，规划域定义语言（PDDL）（GHALAB等，1998）被开发为标准域（和问题）规范PDDL定义了ADL的表现力域，包括尺度流，并定义了标准的扩展扩展规则。原始PDDL版本的后继版本是PDDL 2.1（Fox and Lon，2003），它增加了时间概念和PDDL 2.2，它增加了派生名词词和定时初始文字。已经提出了几个其他扩展，例如（Bertoli等人，2003），它扩展了PDDL来表示非确定性，有限感知和迭代条件计划。</font></font></trans></span></p><h3><a name="3.2---------formalizing-the-initial-world" class="md-header-anchor"></a><span><trans data-src="3.2         Formalizing the Initial World" data-dst="3.2初始世界的形式化"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2初始世界的形式化</font></font></trans></span></h3><p><span><trans data-src="A planning agent must take the initial world state into account, because it must provide a plan that, when executed in the initial world, will lead to the specified goal." data-dst="规划代理必须考虑到最初的世界状态，因为它必须提供一个计划，当在初始世界中执行时，它将导致指定的目标。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规划代理必须考虑到最初的世界状态，因为它必须提供一个计划，当在初始世界中执行时，从而导致指定的目标。</font></font></trans></span></p><p><span><trans data-src="The conceptualizations discussed in the last section not only define the conceptual models of actions, they also define the conceptual models of the initial world description a planning agent is given. In fact, the initial world is just another world state (or situation) defined by the domain theory." data-dst="在最后一节中讨论的概念化不仅定义了行动的概念模型，还定义了规划代理的初始世界描述的概念模型。事实上，初始世界只是域理论所定义的另一个世界状态（或情境）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在最后一级中讨论的概念化完全定义了行动的概念模型，还定义了规划代理的初始世界描述的概念模型。事实上，初始世界只是域理论所定义的另一个世界状态（或情境）。</font></font></trans></span></p><p><span><trans data-src="The central element that constitutes a world state in practically all approaches are the atoms that are known to be true in the initial world state. Classical AI planning approaches assume that the extensional definition of the initial world state provides a" data-dst="在几乎所有的方法中构成世界状态的中心元素是已知的在初始世界状态中是真实的原子。经典的人工智能规划方法假定初始世界状态的外延定义提供了"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在几乎所有的方法中构成世界状态的中心元素是已知的在初始世界状态中是真实的原子。经典的人工智能规划方法替代初始世界状态的外延定义提供了</font></font></trans></span><em><span><trans data-src="complete" data-dst="完成"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成</font></font></trans></span></em><span><trans data-src="description. This allows to employ the closed world assumption, which means that any fact that is not explicitly listed in the state database is false." data-dst="描述这允许采用封闭世界假设，这意味着在状态数据库中未明确列出的任何事实都是假的。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述这允许采用封闭世界假设，这意味着在状态数据库中未明确列出的任何事实都是假的。</font></font></trans></span></p><p><span><trans data-src="For real world applications, such as in robotics or in our domains of Web service computing, these simplifying assumptions are unrealistic. In fact, we are confronted with the following problems:" data-dst="对于现实世界的应用，如机器人技术或我们的Web服务计算领域，这些简化的假设是不现实的。事实上，我们面临以下问题："><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于现实世界的应用，如机器人技术或我们的Web服务计算领域，这些简化的假设是不现实的。事实，我们面临以下问题：</font></font></trans></span></p><p><span><trans data-src="•    Incomplete information: the extensional definition of the initial world does not specify all knowledge relevant to the planning task. For instance, in an e-commerce application, the agent may not know which online retailer offers which products, but it needs this information to achieve its goal of" data-dst="不完整的信息：初始世界的外延定义不指定与规划任务相关的所有知识。例如，在电子商务应用中，代理可能不知道哪一个在线零售商提供哪些产品，但它需要这些信息来实现其目标。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不完整的信息：初始世界的外延定义不指定与规划任务相关的所有知识。例如，在电子商务应用中，代理可能不知道哪一个在线零售商提供某种产品，但它需要这些信息来实现其目标。</font></font></trans></span><em><span><trans data-src="buying" data-dst="购买"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">购买</font></font></trans></span></em><span><trans data-src="a product." data-dst="一种产品。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一种产品</font></font></trans></span></p><p><span><trans data-src="•    Wrong information: some of the atoms that are defined as true may be false in reality (and vice versa). This happens when the" data-dst="错误的信息：一些被定义为真的原子在现实中可能是错误的（反之亦然）。这种情况发生在"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">错误的信息：一些被定义为真的原子在现实中可能是错误的（反之亦然）。这种情况发生在</font></font></trans></span><em><span><trans data-src="invocation and reasonable persistence (IRP)" data-dst="调用与合理持久性（IRP）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引发与合理持久性（IRP）</font></font></trans></span></em><span><trans data-src="assumption (McIlraith and Son, 2001) is violated, i.e. when facts are changed after the agent has acquired knowledge about those facts and when the agent wrongly believes its knowledge is accurate." data-dst="假设（McIlraith和儿子，2001）被违反，即当事实改变后，代理人已获得有关这些事实的知识，当代理人错误地认为其知识是准确的。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设（McIlraith和儿子，2001）被违反，即当事实改变后，代理人已获得有关这些事实的知识，当代理人错误地认为其知识是准确的。</font></font></trans></span></p><p><span><trans data-src="•    Fuzzy information: for each known fluent value there might exist a certain probability that it is not correct (e.g. because of fuzzy sensors). Again, this problem does not appear frequently in our domains." data-dst="Fuzzy信息：对于每个已知的FLUENT值，可能存在某种不正确的概率（例如，由于模糊传感器）。同样，这个问题在我们的领域中并不经常出现。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模糊信息：对于每个已知的FLUENT值，可能存在某种不正确的概率（例如，由于模糊传感器）。同样，这个问题在我们的领域中并不经常出现。</font></font></trans></span></p><p><span><trans data-src="The conceptual models of planners have been extended over the time to better deal with the difficulties listed above. Since the world view of an agent may divert from the reality of the world, it is useful to explicitly represent the knowledge an agent has. The agent’s knowledge can be constituted by the knowledge of atomic facts and also certain axioms and functions. Along these lines, alternatives to the widely used closed world assumption have been investigated, for instance the" data-dst="规划师的概念模型已经被延长，以便更好地处理上面列出的困难。由于代理的世界观可能偏离世界的真实性，因此明确地表示代理具有的知识是有用的。Agent的知识可以由原子事实知识和某些公理和函数构成。沿着这条线，已经研究了广泛使用的封闭世界假设的替代物，例如"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规划师的概念模型已经被延长，刹车更好地处理上面列出的困难。由于代理的世界观可能替换世界的真实性，因此明确地表示代理具有的知识是有用的。Agent的知识可以由原子事实知识和某些公理和函数构成。交替这条线，已经研究了广泛使用的封闭世界假设的替代物，例如</font></font></trans></span><em><span><trans data-src="Local Closed World Assumption" data-dst="本地封闭世界假设"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本地封闭世界假设</font></font></trans></span></em><span><trans data-src="(LCA), which allows to represent Local Closed World (LCW) knowledge (Golden, 1997). LCW knowledge is usually organized in two databases M and L, where the database M contains a collection of all known facts and the database L contains LCW formulas that describe the contents of M, i.e. they state for which parts of the world the agent’s knowledge can be safely assumed to be complete. For instance, when an agent queries the list of all products an online retailer" data-dst="（LCA），它允许代表局部封闭世界（LCW）知识（黄金，1997）。LCW知识通常组织在两个数据库M和L中，其中数据库M包含所有已知事实的集合，并且数据库L包含描述M的内容的LCW公式，即它们的状态，对于世界的哪些部分，代理的知识可以被安全地假定为完整的。例如，当代理查询所有产品的列表时，在线零售商。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（LCA），它允许代表局部封闭世界（LCW）知识（黄金，1997）。LCW知识通常组织在两个数据库M和L中，其中数据库M包含所有已知事实的集合，并且数据库L包含描述M的内容的LCW公式，即它们的状态，对于世界的哪些部分，代理的知识可以被安全地假定为完整的。例如，当代理查询所有产品的列表时，在线零售商。</font></font></trans></span><em><span><trans data-src="A" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src="sells, it may assume to know all products that are available from" data-dst="出售，它可以假定知道所有的产品，可从"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出售，它可以预先知道所有的产品，可从</font></font></trans></span><em><span><trans data-src="A" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src="(when the IRP assumption holds)." data-dst="（“When the IRP Assemption Holds”）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（“ IRP豁免成立时”）</font></font></trans></span></p><p><span><trans data-src="When knowledge of agents is expressed explicitly, the necessity arises to define the influence some of the domain’s operators have on the agent’s knowledge. In other words, it is useful to distinguish operators (or effects) that change the" data-dst="当代理的知识被明确地表达时，必然需要定义域的某些操作员对代理知识的影响。换句话说，区分改变的操作符（或效果）是有用的。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当代理的知识被明确地表达时，必然需要定义域的某些操作员对代理知识的影响。换句话说，区分改变的操作符（或效果）是有用的。</font></font></trans></span><em><span><trans data-src="world" data-dst="全球"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全球</font></font></trans></span></em><span><trans data-src="from operators (or effects) that only affect the agent’s" data-dst="从只影响代理的操作员（或影响）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从只影响代理的操作员（或影响）</font></font></trans></span><em><span><trans data-src="knowledge" data-dst="知识"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">知识点</font></font></trans></span></em><span><trans data-src=". The latter are called sensing operations (or sensing effects). An extension to STRIPS that accounts for incomplete knowledge and sensing actions is UWL (Etzioni et al., 1992). Similarly, SADL (Golden, 1997) adds support for incomplete information and sensing to ADL, and NPDDL (Bertoli et al., 2003) proposes similar extensions to PDDL. An other proposed extension to PDDL is Opt (McDermott, 2002), which adds knowledge effects and" data-dst=". 后者被称为感测操作（或感测效果）。对不完全知识和感测动作的扩展的扩展是UWL（EtZoii等人，1992）。类似地，SADL（金，1997）增加了对不完整信息的支持和对ADL的感测，NPDDL（Beltoi等人，2003）提出了对PDDL的类似扩展。另一个建议的PDDL扩展是OPT（德莫特，2002），它增加了知识效应和"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">对不完全知识和感测动作的扩展的扩展是UWL（EtZoii等人，1992）。类似地，SAD​​L（金，1997）增加了对不完整信息的支持和对ADL的感测，NPDDL（Beltoi等人，2003）提出了对PDDL的类似扩展。另一个建议的PDDL扩展是OPT（德莫特，2002），它增加了知识效应和</font></font></trans></span><em><span><trans data-src="learnable terms" data-dst="可学习术语"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可学习术语</font></font></trans></span></em><span><trans data-src="to the PDDL framework." data-dst="到PDDL框架。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到PDDL框架</font></font></trans></span></p><p><span><trans data-src="A formal situation calculus based account of the incomplete knowledge of agents and sensing actions was given in (Moore, 1985), which also introduced the notion of knowledge preconditions, which are conditions the agent’s knowledge base must fulfill to successfully apply an operator." data-dst="在穆尔（1985）中给出了一个基于形式情景演算的不完全知识的代理和感测动作，这也引入了知识前提的概念，这是代理的知识库必须满足的条件来成功地应用操作员。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在穆尔（1985）中提出了一个基于形式上下文演算的不完全知识的代理和感测动作，这也约会了知识的概念，这是代理的必须满足条件的成功地应用操作员。</font></font></trans></span></p><h3><a name="3.3---------formalizing-goals" class="md-header-anchor"></a><span><trans data-src="3.3         Formalizing Goals" data-dst="3.3个形式化目标"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3个形式化目标</font></font></trans></span></h3><p><span><trans data-src="In most classical approaches to AI planning, goals are expressed as properties that need to hold in a desired world state (the" data-dst="在大多数经典的人工智能规划方法中，目标被表示为需要在所需的世界状态中保持的属性。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在大多数经典的人工智能规划方法中，目标被表示为需要在所需的世界状态中保持的属性。</font></font></trans></span><em><span><trans data-src="goal state" data-dst="目标状态"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目标状态</font></font></trans></span></em><span><trans data-src="), usually in the form of conjunctions and disjunctions of literals (positive or negative atoms) and whereby variables are treated with existential quantification." data-dst="（通常是以连词和析取的形式（正或负原子）的形式，从而用生存量化来处理变量。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（通常以连词和析取的形式（正或负原子）的形式，从而用生存量化来处理变量。</font></font></trans></span></p><p><span><trans data-src="The planner needs to identify a solution (a plan), which, when executed in the initial world state, will result in a world state that satisfies the goal. For instance a goal" data-dst="规划人员需要识别一个解决方案（一个计划），当它在初始世界状态下执行时，将产生满足目标的世界状态。例如一个目标"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规划人员需要识别一个解决方案（一个计划），当它在初始世界状态下执行时，将产生满足目标的世界状态。例如一个目标</font></font></trans></span><em><span><trans data-src="(color Door1 Red)" data-dst="（彩色门一红）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（彩色门一红）</font></font></trans></span></em><span><trans data-src="specifies a condition that says that the fluent" data-dst="指定一个条件，表示流畅。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定一个条件，表示流畅。</font></font></trans></span><em><span><trans data-src="color" data-dst="颜色"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">颜色</font></font></trans></span></em><span><trans data-src="of" data-dst="属于"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属于</font></font></trans></span><em><span><trans data-src="Door1" data-dst="门1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">门1</font></font></trans></span></em><span><trans data-src="must have the value" data-dst="必须有价值"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须肯定</font></font></trans></span><em><span><trans data-src="Red" data-dst="红色"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">红色</font></font></trans></span></em><span><trans data-src="after plan execution, and a goal" data-dst="计划执行之后，还有一个目标"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计划执行之后，还有一个目标</font></font></trans></span><em><span><trans data-src="(have-door House1 ?d)" data-dst="有门屋吗？d）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有门屋吗？d）</font></font></trans></span></em><span><trans data-src="would require the existence of an constant" data-dst="需要常数的存在"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要常数的存在</font></font></trans></span><em><span><trans data-src="c" data-dst="C"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></trans></span></em><span><trans data-src=", that when bound to variable ?" data-dst="，当绑定到变量时？"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，当绑定到变量时？</font></font></trans></span><em><span><trans data-src="d" data-dst="D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></trans></span></em><span><trans data-src=", would make the formula" data-dst="将公式化"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将公式化</font></font></trans></span><em><span><trans data-src="(have-door House1 ?d)" data-dst="有门屋吗？d）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有门屋吗？d）</font></font></trans></span></em><span><trans data-src="true." data-dst="真的。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真的</font></font></trans></span></p><p><span><trans data-src="For automated Web service composition (and many other domains) these goals specifications are not sufficient enough. Requirements listed in the literature are:" data-dst="对于自动化的Web服务组合（和许多其他领域），这些目标规范是不够的。文献中列出的要求是："><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于自动化的Web服务组合（和许多其他领域），这些目标规范是不够的。文献中列出的要求是：</font></font></trans></span></p><p><span><trans data-src="•    Need for temporal structures: Certain complex goals can not be expressed simply as properties of a final state. For instance, the planning of a round-trip from Vienna to Zurich and back can not be expressed as a condition on the goal state because the goal state would equal the initial state (i.e. the agent being in Vienna[" data-dst="需要时间结构：某些复杂的目标不能简单地表示为最终状态的属性。例如，从维也纳到苏黎世和往返的往返行程的规划不能被表示为目标状态的条件，因为目标状态将等于初始状态（即在维也纳的代理）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要时间结构：某些复杂的目标不能简单地表示为最终状态的属性。例如，从维也纳到苏黎世和运送的往返行程的规划不能被表示为目标状态的条件，因为目标状态将等于初始状态（即在维也纳的代理）。</font></font></trans></span><a href="https://ziyanliupb.github.io/#"><span><trans data-src="3" data-dst="三"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三</font></font></trans></span><span><trans data-src="]" data-dst="]"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]</font></font></trans></span></a><span><trans data-src="). Therefore, certain structures need to be added to split the planning goal into several distinct, consecutive phases. In some cases, a valid plan may even have to include looping and branching, as noted by (Srivastava and Koehler, 2003)." data-dst="）因此，需要增加某些结构来将规划目标分成几个不同的、连续的阶段。在某些情况下，一个有效的计划甚至可能包括循环和分支，如Sristava和Koehler，2003所指出的。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）因此，需要增加某些结构来将规划目标分成几个不同的，连续的阶段。在某些情况下，一个有效的计划甚至可能包括循环和分支，如Sristava和Koehler，2003年指出的。</font></font></trans></span></p><p><span><trans data-src="•    Strategies for dealing with nondeterminism, i.e. how to behave if the execution of an operation does not achieve the expected or desired result (e.g. by defining BPEL-like" data-dst="•处理非确定性的策略，即，如果操作的执行未达到预期或期望的结果（例如，通过定义BPEL），则如何表现"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">•处理非确定性的策略，即，如果操作的执行未达到预期或期望的结果（例如，通过定义BPEL），则如何表现</font></font></trans></span><em><span><trans data-src="compensation actions" data-dst="补偿行动"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">补偿行动</font></font></trans></span></em><span><trans data-src=")." data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span></p><p><span><trans data-src="•    Safety properties: not all" data-dst="安全属性：不是全部"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全属性：不是全部</font></font></trans></span><em><span><trans data-src="possible" data-dst="可能的"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能的</font></font></trans></span></em><span><trans data-src="solutions to achieve a goal are" data-dst="实现目标的解决方案是"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现目标的解决方案是</font></font></trans></span><em><span><trans data-src="desired" data-dst="渴望的"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渴望的</font></font></trans></span></em><span><trans data-src="ones. For instance, there may be certain fluents whose values should not or only moderately be changed (e.g. the credit-card balance); these protected fluents are sometimes called" data-dst="那些。例如，可能存在某些不应该或仅仅适度地改变（例如信用卡余额）的某些通量；有时这些被保护的熔剂被称为"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那些。例如，可能存在某些不应该或仅适度地改变（例如信用卡余额）的某些通量；有时这些被保护的熔剂被称为</font></font></trans></span><em><span><trans data-src="maintenance goals" data-dst="维护目标"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">维护目标</font></font></trans></span></em><span><trans data-src="or" data-dst="或"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font></trans></span><em><span><trans data-src="resource constraints" data-dst="资源约束"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源约束</font></font></trans></span></em><span><trans data-src=". Further, in many domains there are certain situations an agent may stumble into, which need to be avoided altogether, and constraints on the goal can help to evade them." data-dst=". 此外，在许多领域中，有一定的情况下，代理人可能绊倒，这需要完全避免，和约束的目标可以帮助逃避他们。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此外，在许多领域中，有一定的情况下，代理人可能绊倒，这需要完全避免，和约束的目标可以帮助逃避他们。</font></font></trans></span></p><p><span><trans data-src="•    Distinction between" data-dst="区别"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">区别</font></font></trans></span><em><span><trans data-src="information goals" data-dst="信息目标"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信息目标</font></font></trans></span></em><span><trans data-src="and" data-dst="和"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font></trans></span><em><span><trans data-src="achievement goals" data-dst="成就目标"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成就目标</font></font></trans></span></em><span><trans data-src=": Many problems require such a distinction because information goals should be achieved exclusively by" data-dst="许多问题需要这样的区别，因为信息目标应该完全由"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">许多问题需要这样的区别，因为信息目标应该完全由</font></font></trans></span><em><span><trans data-src="sensing actions" data-dst="感知动作"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">感知动作</font></font></trans></span></em><span><trans data-src=". As an example, a goal to find out the current color of an item may only use operations that do" data-dst=". 作为一个例子，查找项目当前颜色的目标只能使用"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">作为一个例子，查找项目当前颜色的目标只能使用</font></font></trans></span><em><span><trans data-src="not" data-dst="不"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></trans></span></em><span><trans data-src="actively affect its color; we would not want the agent to use an operation that sets the color to some new value and then reports that newly assigned color (Golden, 1997). Instead, the value should be gathered through a" data-dst="积极地影响其颜色；我们不希望代理使用将颜色设置为某个新值的操作，然后报告新分配的颜色（金，1997）。取而代之的是，应该通过"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">积极地影响其颜色；我们不希望代理使用将颜色设置为某个新值的操作，然后报告新分配的颜色（金，1997）。取而代之的是，应该通过</font></font></trans></span><em><span><trans data-src="sensing operation" data-dst="传感操作"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传感操作</font></font></trans></span></em><span><trans data-src="." data-dst="."><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></trans></span></p><p><span><trans data-src="•    Preferences of users over possible solutions (e.g. preferring air travel over traveling by train, payment via credit card over e-cash) and other user-provided constraints on the solution (e.g. buying airline ticket only if driving would take longer than 3 hours) (McIlraith and Son, 2001)" data-dst="·用户对可能的解决方案的偏好（例如，宁愿乘飞机旅行超过火车，通过信用卡支付电子现金）和其他用户提供的解决方案的限制（例如，仅在驾驶时购买机票将需要3小时以上）（McIlraith和儿子，2001）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">·用户对可能的解决方案的替代（例如，宁愿乘飞机旅行超过火车，通过信用卡支付电子现金）和其他用户提供的解决方案的限制（例如，仅在驾驶时购买机票将需要3小时以上）（ McIlraith和儿子，2001）</font></font></trans></span></p><p><span><trans data-src="Since these difficulties are relevant to many real world planning domains, not only to Web service composition, there exist several approaches to address these problems, which will be discussed in Sect. 5." data-dst="由于这些困难与许多真实世界规划领域相关，不仅是Web服务组合，还存在多种方法来解决这些问题，这将在SECT中讨论。5。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于这些困难与许多真实世界规划领域相关，既是Web服务组合，还存在多种方法来解决这些问题，这将在SECT中讨论。5。</font></font></trans></span></p><h3><a name="3.4---------representing-plans" class="md-header-anchor"></a><span><trans data-src="3.4         Representing Plans" data-dst="3.4个代表计划"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4个代表计划</font></font></trans></span></h3><p><span><trans data-src="The classical view of a plan as a solution to a planning problem is a" data-dst="计划作为解决规划问题的经典观点是"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计划作为解决规划问题的经典观点是</font></font></trans></span><em><span><trans data-src="sequence of operator instances" data-dst="算子实例序列"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算子实例序列</font></font></trans></span></em><span><trans data-src=", which, when executed leads to a state that satisfies the given goal. Given the discussion of goals in the last section, especially the problem of nondeterminism, it is not surprising that this classical view of plans is not always sufficient to capture the solutions to complex planning problems." data-dst="，当被执行时导致满足给定目标的状态。由于讨论了最后一节的目标，特别是非确定性问题，因此，这种经典的计划观点并不总是足以捕捉复杂规划问题的解决方案。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，由于讨论了最后一段的目标，特别是非确定性问题，因此，这种经典的计划观点并不总是捕捉复杂规划问题的解决方案。</font></font></trans></span></p><p><span><trans data-src="The required complexity of a plan does not only depend on the domain and goal complexity, it also depends on the execution model foreseen for the plan: if an operation does not yield the desired result, will the agent have the opportunity to re-generate the plan (as in replanning/reactive planning architectures, e.g. (Firby, 1987)), or will the agent have to rely on the predefined plan? In the latter case, a" data-dst="计划的所需复杂性不仅取决于域和目标复杂度，而且还取决于计划预见的执行模型：如果一个操作没有产生期望的结果，代理将有机会重新生成计划（如在重新规划/无功规划架构中，例如（FiBuy，1987）），或者代理必须依赖预定义的计划吗？在后一种情况下，A"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计划的所需复杂性超出预定范围和目标复杂度，而且还取决于计划预见的执行模型：如果一个操作没有产生期望的结果，代理将有机会重新生成计划（如在重新规划/无功规划架构中，例如（FiBuy，1987）），或代理必须依赖预定义的计划吗？在后一种情况下，A</font></font></trans></span><em><span><trans data-src="conditional" data-dst="有条件的"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有条件的</font></font></trans></span></em><span><trans data-src="plan is required that deals with the nondeterminism and incomplete information by constructing a plan that accounts for the possible contingencies that could arise. At runtime, the agent has to determine the situation it is in and then chose the appropriate plan branch that is prepared for that situation. Planners that adopt that strategy are also called contingency planners." data-dst="计划是通过处理可能出现的突发事件的计划来处理非确定性和不完全信息的。在运行时，代理必须确定其所在的情况，然后选择为该情况准备的适当计划分支。采用这种策略的规划者也被称为应急规划师。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计划是通过处理可能出现的突发事件的计划来处理非确定性和不完全信息的。在运行时，代理必须确定其所在的情况，然后选择为该情况准备的适当计划分支。采用这种策略的规划者也被称为应急规划师。</font></font></trans></span></p><p><span><trans data-src="Beside contingency planners, there exist several other extensions to plans as simple sequences. As we will discuss later in Sect. 4.3, partial order planners allow for plans whose actions are partially ordered, i.e. some of the actions can be executed in parallel rather than sequentially, which often increases the efficiency of the system. Even more feature-rich plans can be created using the planning as model-checking (MC) approach described in Sect. 5.3, where the planner synthesizes plans that may contain loops and branches." data-dst="除了应急规划师之外，还有其他几个扩展计划作为简单的序列。我们将在后面讨论。4.3，偏序规划者允许计划的行动是部分有序的，即一些行动可以并行执行，而不是顺序，这往往提高了系统的效率。甚至更多的功能丰富的计划可以使用规划作为模型检查（MC）的方法在SECT中创建。5.3，规划师综合可能包含回路和分支的计划。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将在后面讨论。4.3，偏序规划者允许计划的行动是部分有序的，即一些行动可以并行执行，而不是5.3，规划师综合可能包含回路和分支的计划。顺序，这经常提高了系统的效率。甚至更多的功能丰富的计划可以使用规划作为模型检查（MC）的方法在SECT中创建。</font></font></trans></span></p><h2><a name="4-----------basic-planning-paradigms" class="md-header-anchor"></a><span><trans data-src="4           Basic Planning Paradigms" data-dst="4种基本规划范式"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4种基本规划范式</font></font></trans></span></h2><p><span><trans data-src="In the following we will give an overview of the basic planning paradigms and some representative implementations of these concepts." data-dst="在下文中，我们将概述基本规划范式和一些代表性的实现这些概念。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在总体中，我们将概述基本规划范式和一些预期的实现这些概念。</font></font></trans></span></p><h3><a name="4.1---------state-space-based-planning" class="md-header-anchor"></a><span><trans data-src="4.1         State-Space based Planning" data-dst="4.1状态空间规划"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1状态空间规划</font></font></trans></span></h3><p><span><trans data-src="A state space consists of a finite set of states" data-dst="状态空间由有限状态集组成。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态空间由有限状态集组成。</font></font></trans></span><em><span><trans data-src="S" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src=", a finite set of actions" data-dst="一个有限的动作集合"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个有限的动作集合</font></font></trans></span><em><span><trans data-src="A" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src=", a state transition function" data-dst="一个状态转移函数"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个状态转移函数</font></font></trans></span><em><span><trans data-src="f" data-dst="f"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F</font></font></trans></span></em><span><trans data-src="that describes how actions map one state into another, and a cost function" data-dst="描述操作如何将一个状态映射到另一个状态，以及成本函数。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述操作如何将一个状态映射到另一个状态，以及成本函数。</font></font></trans></span><em><span><trans data-src="c" data-dst="C"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="a,s" data-dst="A、S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如</font></font></trans></span></em><span><trans data-src=")" data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span><em><span><trans data-src="&gt;" data-dst="&amp;#62;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＆＃62;</font></font></trans></span></em><span><trans data-src="0 that measures the cost of performing action" data-dst="0衡量执行行为的成本"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0规范执行行为的成本</font></font></trans></span><em><span><trans data-src="a" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src="in state" data-dst="处于状态"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处于状态</font></font></trans></span><em><span><trans data-src="s" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="(Fikes and Nilsson, 1971). A state space extended with a given initial state" data-dst="（Fikes和尼尔森，1971）。用给定初始状态扩展的状态空间"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Fikes和尼尔森，1971）。用给定初始状态扩展的状态空间</font></font></trans></span><em><span><trans data-src="s" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="0 and a set" data-dst="0和一组"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0和一组</font></font></trans></span><em><span><trans data-src="SG" data-dst="SG"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SG</font></font></trans></span></em><span><trans data-src="of goals is also called a" data-dst="目标也被称为"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目标也被称为</font></font></trans></span><em><span><trans data-src="state model" data-dst="状态模型"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态模型</font></font></trans></span></em><span><trans data-src="(Bonet and Geffner, 2001b)." data-dst="（博内特和Geffner，2001年B）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（博内特和Geffner，2001年B）。</font></font></trans></span></p><p><span><trans data-src="State based planners aim to solve a planning problem by searching for useful operator instantiations that achieve the desired state. Depending on the starting point of the search, we distinguish forward state search (also called progression) and backward state search (also called regression): A progressive state based planner starts with the initial state and searches action instances that bring the planner closer to the goal. A regression planner starts with a state satisfying the goal and searches for action instances that bring the planner closer to the initial state." data-dst="基于状态的规划者旨在通过搜索实现期望状态的有用的算子实例化来解决规划问题。根据搜索的起点，我们区分正向状态搜索（也称为渐进）和向后状态搜索（也称为回归）：基于状态的计划器从初始状态开始，并搜索使规划人员更接近目标的动作实例。回归规划器从满足目标的状态开始，并搜索使规划人员更接近初始状态的动作实例。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据状态的规划者逐步通过搜索实现期望状态的有用的算子实例化来解决规划问题。根据搜索的起点，我们区分正向状态搜索（也称为渐进）和向后状态搜索（也称为回归）：基于状态的计划器从初始状态开始，并搜索使规划人员更接近目标的动作实例。回归规划器从满足目标的状态开始，并搜索使规划人员更接近初始状态的动作实例。</font></font></trans></span></p><p><span><trans data-src="In both cases, the goal is to find a sequence of actions that, when applied beginning in the initial state, will lead to the goal state. More formally, a solution of a state model is a sequence of actions" data-dst="在这两种情况下，目标是找到一系列动作，当在初始状态开始应用时，将导致目标状态。更正式地说，状态模型的解决方案是一系列动作。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这两种情况下，目标是找到的动作，当在初始状态开始应用时，将导致目标状态。更正式地说，状态模型的解决方案是一系列动作。</font></font></trans></span><em><span><trans data-src="a" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src="0" data-dst="零"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">零</font></font></trans></span><em><span><trans data-src=",a" data-dst="A"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一种</font></font></trans></span></em><span><trans data-src="1" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span><em><span><trans data-src=",...,an" data-dst="……"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">……</font></font></trans></span></em><span><trans data-src="that generates a state trajectory" data-dst="生成状态轨迹的"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成状态轨迹的</font></font></trans></span><em><span><trans data-src="s" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="0" data-dst="零"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">零</font></font></trans></span><em><span><trans data-src=",s" data-dst="的S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的S</font></font></trans></span></em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 =</font></font></span><font style="vertical-align: inherit;"><span><font style="vertical-align: inherit;"> +1 =</font></span></font><em><span><trans data-src="f" data-dst="f"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="s" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="0)" data-dst="0）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0）</font></font></trans></span><em><span><trans data-src=",...,sn" data-dst="，…，锡"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，…，锡</font></font></trans></span></em><span></span><em><span><trans data-src="f" data-dst="f"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="an,sn" data-dst="安，锡"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安，锡</font></font></trans></span></em><span><trans data-src=") such that each action" data-dst="）每个动作"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）每个动作</font></font></trans></span><em><span><trans data-src="ai" data-dst="人工智能"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人工智能</font></font></trans></span></em><span><trans data-src="is applicable in" data-dst="适用于"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">适用于</font></font></trans></span><em><span><trans data-src="si" data-dst="硅"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硅</font></font></trans></span></em><span><trans data-src="and" data-dst="和"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font></trans></span><em><span><trans data-src="sn" data-dst="锡"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锡</font></font></trans></span></em><span><trans data-src="+1 is a goal state, i.e.," data-dst="1是目标状态，即"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1是目标状态，即</font></font></trans></span><em><span><trans data-src="ai" data-dst="人工智能"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人工智能</font></font></trans></span></em><span><trans data-src="∈" data-dst="γ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">γ</font></font></trans></span><em><span><trans data-src="A" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="si" data-dst="硅"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硅</font></font></trans></span></em><span><trans data-src=") and" data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span><em><span><trans data-src="sn" data-dst="锡"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锡</font></font></trans></span></em><span><trans data-src="+1 ∈" data-dst="1℃"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1℃</font></font></trans></span><em><span><trans data-src="G" data-dst="G"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></trans></span></em><span><trans data-src="(Bonet and Geffner, 2001b)." data-dst="（博内特和Geffner，2001年B）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（博内特和Geffner，2001年B）。</font></font></trans></span></p><p><span><trans data-src="In principal, any search algorithm can be used to perform state based search, and the discipline of means-end-analysis has a long tradition with roots in the 1950s since GPS (Newell and Simon, 1963). However, the usually vast number of different branches of actions a planner has to chose from calls for methods that reduce the search space or help discriminating fruitful vs. useless branches of the search tree. An early attempt for reducing the search space was the STRIPS algorithm. It uses backward search, i.e. it starts with the goal, searches an action that achieves the goal or one of its subgoals and then goes on to search actions that achieve the precondition of the actions, and so forth. STRIPS enhances this search by only considering the preconditions of the last operator added to the plan and by committing to operators whose preconditions are satisfied by the current state. This reduces the plan space significantly, but it makes STRIPS incomplete, i.e. there is no guarantee that a solution for a problem will be found even if there exists one." data-dst="原则上，任何搜索算法都可以用来执行基于状态的搜索，而手段终结分析的学科有着悠久的传统，起源于20世纪50年代以来的GPS（纽厄尔和西蒙，1963）。然而，通常需要大量的不同分支行动，规划者必须从调用减少搜索空间的方法中选择，或者帮助区分搜索树的有价值的无用分支。减少搜索空间的早期尝试是条带算法。它使用反向搜索，即从目标开始，搜索实现目标或其子目标之一的动作，然后继续搜索实现动作的前提条件的动作，等等。条带仅通过考虑添加到计划中的最后一个操作员的先决条件和提交到由当前状态满足其先决条件的运算符来增强该搜索。这显著地减少了计划空间，但它使得条带不完整，即不能保证即使存在一个问题也会找到解决方案。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原则上，任何搜索算法都可以执行执行状态的搜索，而手段终结分析的学科有着悠久的传统，起源于20世纪50年代以来的GPS（纽厄尔和西蒙，1963）。然而，通常需要大量的不同分支行动，规划者必须从调用减少搜索空间的方法中选择，或者帮助区分搜索树的所有权的无用分支。减少搜索空间的早期尝试是条带算法。它使用反向搜索，即从目标开始，搜索实现目标目标子目标之一的动作，然后继续搜索实现动作的替代条件的动作，等等。条带仅通过考虑添加到计划中的最后一个操作员的先决条件和提交到由当前状态满足其先决条件的运算符来增强该搜索。这显着地减少了计划空间，但它造成条带不完整，即不能保证甚至存在一个问题也会找到解决方案。</font></font></trans></span></p><p><span><trans data-src="A different way of dealing with the vastness of the plan space is to employ" data-dst="处理规划空间浩瀚的另一种方法是使用。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理规划空间浩瀚的另一种方法是使用。</font></font></trans></span><em><span><trans data-src="heuristic functions" data-dst="启发式功能"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启发式功能</font></font></trans></span></em><span><trans data-src="which estimate the usefulness of the alternative actions a planner can chose from, thus" data-dst="它估计计划者可以选择的替代行动的有用性，从而"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它估计计划者可以选择的替代行动的有用性，从而</font></font></trans></span><em><span><trans data-src="guiding" data-dst="指导"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指导</font></font></trans></span></em><span><trans data-src="the planner to chose fruitful search paths and ignore branches that will lead to dead ends or solutions of low quality. Truly automatic domain independent planners have no other choice than gathering these heuristics from the domain and the problem descriptions they are confronted with, in contrast to specialized algorithms, e.g. the algorithm solving the 8-puzzle discussed in AI textbooks like (Nilsson, 1980)." data-dst="规划师选择富有成效的搜索路径，忽略分支将导致死胡同或低质量的解决方案。真正的自动领域无关规划者除了收集来自领域的启发式和他们所面临的问题描述外，没有其他选择，与专门算法相反，例如在AI教科书中讨论的解决8个难题的算法（尼尔森，1980）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规划师选择富有成效的搜索路径，忽略分区将导致死胡同或低质量的解决方案。真正的自动领域无关规划者除了收集来自领域的启发式和他们所面临的问题描述外，没有其他选择，与专门算法相反，例如在AI教科书中讨论的解决8个难题的算法（尼尔森，1980）。</font></font></trans></span></p><p><span><trans data-src="A planner adopting such a domain-independent heuristic is UNPOP (McDermott, 1996), which employs a regression-match graph. The construction of this graph starts with the goal, which is matched to the current situation, yielding a set of literals to be achieved. In the next level of the graph, actions are considered that achieve some of those subgoals, which yields another set of subgoals, needed to carry out those actions. Those subgoals are added to the next level of the graph and the process repeats. To enhance the graph traversal, the notion of" data-dst="采用这种独立于域的启发的规划者是UNPOP（德莫特，1996），它采用回归匹配图。该图的构造从目标开始，该目标与当前情况匹配，产生一组要实现的文字。在图的下一级，动作被认为实现这些子目标中的一些，这些子目标产生另一组子目标，需要执行这些动作。这些子目标被添加到图的下一级，并且过程重复。为了加强图的遍历，提出了"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">采用这种独立于域的启发的规划者是UNPOP（德莫特，1996），它采用回归匹配图。该图的构造从目标开始，该目标与当前情况匹配，产生一组要实现的文字。在图的下一级，动作被认为实现了这些子目标中的一些，这些子目标产生另一组子目标，需要执行这些动作。这些子目标被添加到图的下一级，并且过程重复。加强图的遍历，提出了</font></font></trans></span><em><span><trans data-src="estimated effort" data-dst="估计努力"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">估计努力</font></font></trans></span></em><span><trans data-src="is used, i.e. an estimate of how many actions it will take to achieve the main goal, whereby the effort of a goal that is already given in the current situation is 0 and the effort of a goal that can not be achieved by any operator in the domain is ∞. When traversing the regression graph, UNPOP chooses branches first whose effort estimations seem favorable, which leads to an improvement in planning speed compared to “blind” unguided searches." data-dst="被使用，即估计要达到主目标需要多少动作，由此在当前情况下已经给出的目标的努力是0，并且域中的任何操作员所不能达到的目标的努力是无穷的。当遍历回归图时，UNPOP首先选择其工作估计似乎有利的分支，这导致与“盲”非引导搜索相比，计划速度的提高。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">被使用，即估计要达到主目标需要多少动作，在当前情况下已经已经被通知的目标的努力是0，并且域中的任何操作员所不能达到的目标的努力是无穷的。图时，UNPOP首先选择其工作估计似乎有利的分支，这导致与“盲”非引导搜索排名，计划速度的提高。</font></font></trans></span></p><p><span><trans data-src="In related work, the forward planner HSP (Heuristic search planner) was presented, which is based on the" data-dst="在相关工作中，提出了基于启发式算法的正向规划HSP（启发式搜索规划器）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在相关工作中，提出了基于启发式算法的正向规划HSP（启发式搜索规划器）。</font></font></trans></span><em><span><trans data-src="additive heuristic hadd" data-dst="加性启发式HADD"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加性启发式HADD</font></font></trans></span></em><span><trans data-src=". This heuristic defines the cost of a set" data-dst=". 这个启发式定义了集合的成本。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这个启发式定义了集合的成本。</font></font></trans></span><em><span><trans data-src="C" data-dst="C"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></trans></span></em><span><trans data-src="of atoms as the sum of the cost of the elements of" data-dst="原子作为元素的成本之和。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原子作为元素的成本之和。</font></font></trans></span><em><span><trans data-src="C" data-dst="C"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></trans></span></em><span><trans data-src=". This assumes that subgoals are independent of each other, which is not always true because some goals can become less (or even more) difficult once other goals are fulfilled. The HSP system uses" data-dst=". 这假定子目标是相互独立的，这并不总是正确的，因为一旦实现其他目标，某些目标就可能变得更少（甚至更多）。HSP系统使用"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这预先子目标是相互独立的，这并不总是正确的，因为一旦实现其他目标，某些目标就可能变得越来越（甚至更多）。HSP系统使用</font></font></trans></span><em><span><trans data-src="hadd" data-dst="哈德"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈德</font></font></trans></span></em><span><trans data-src="to guide a" data-dst="指导一个"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指导一个</font></font></trans></span><em><span><trans data-src="hill-climbing search" data-dst="爬山搜索"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">爬山搜索</font></font></trans></span></em><span><trans data-src="from the initial state to the goal. At each step, one of the best child nodes (i.e. nodes whose" data-dst="从初始状态到目标。在每个步骤中，最好的子节点之一（即节点）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从初始状态到目标。在每个步骤中，最好的子节点之一（即计数器）</font></font></trans></span><em><span><trans data-src="hadd" data-dst="哈德"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈德</font></font></trans></span></em><span><trans data-src="value is minimal) is selected for expansion and the same process is repeated until the goal is reached. The costs are calculated as" data-dst="选择扩展值，重复相同的过程直到达到目标为止。成本计算为"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择扩展值，重复相同的过程直到达到目标为止。</font></font></trans></span><em><span><trans data-src="estimations" data-dst="估计"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">估计</font></font></trans></span></em><span><trans data-src=", which are extracted from a relaxed planning problem" data-dst="这是从一个轻松的规划问题中提取出来的。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是从一个轻松的规划问题中提取出来的。</font></font></trans></span><em><span><trans data-src="P" data-dst="磷"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">磷</font></font></trans></span></em><span><trans data-src="0, where the negative effects of operators are ignored. The estimations are generated by iteratively applying the positive effects of a number of operations whose preconditions are applicable in the current state (negative effects are ignored) and by tracking for each atom that is achieved in that process after how many steps it was achieved (Bonet and Geffner, 1998). Empirical data shows that the idea of using a relaxed problem to harvest heuristic estimation as well as the assumption of goal independence yields preferable results, as documented in the results of the international planning competition IPC1998 (McDermott, 2000; Bonet and Geffner, 2001b)." data-dst="0，忽略运营商的负面影响。通过迭代应用其预条件适用于当前状态的多个操作（负效应被忽略）和跟踪在该过程中实现的每一个原子在其实现了多少步骤之后产生的估计（博内特和GffnER，1998）生成。经验数据表明，使用宽松的问题来收获启发式估计以及假设的目标独立性产生更好的结果，如国际规划竞赛IPC1998（德莫特，2000；博内特和Geffner，2001年B）的结果所记载。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0，忽略运营商的倾斜影响。通过继承应用其预条件适用于当前状态的多个操作（负效应被忽略）和跟踪在该过程中实现的每个一个原子在其实现了多少步骤之后产生的估计（博内特和GffnER，1998）生成。经验数据表明，使用宽松的问题来收获启发式估计以及假设的目标独立性产生更好的结果，如国际规划竞赛IPC1998（德莫特，2000；博内特和Geffner，2001年B）的结果所记载。</font></font></trans></span></p><p><span><trans data-src="In successive work, the planner HSP2 (Bonet and Geffner, 2001a) was developed, which employs the same heuristic function" data-dst="在连续的工作中，开发了计划员HSP2（博内特和Geffner，2001年A），其采用相同的启发函数。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在连续的工作中，开发了计划员HSP2（博内特和Geffner，2001年A），其采用相同的启发函数。</font></font></trans></span><em><span><trans data-src="hadd" data-dst="哈德"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈德</font></font></trans></span></em><span><trans data-src=", but uses" data-dst="但使用"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但使用</font></font></trans></span><em><span><trans data-src="bestfirst search" data-dst="最佳优先搜索"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最佳优先搜索</font></font></trans></span></em><span><trans data-src="(Pearl, 1985) instead of hill-climbing. The best-first search weighs nodes by an evaluation function" data-dst="（珠儿，1985）而不是爬山。最佳的第一次搜索通过评价函数对节点进行加权"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（珠儿，1985）而不是爬山。最佳的第一次搜索通过评估函数对路由器进行重新</font></font></trans></span><em><span><trans data-src="f" data-dst="f"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="n" data-dst="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></trans></span></em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）=</font></font></span><em><span><trans data-src="g" data-dst="G"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="n" data-dst="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></trans></span></em><span><trans data-src=") +" data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span><em><span><trans data-src="W" data-dst="W"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w ^</font></font></trans></span></em><span><trans data-src="∗" data-dst="*"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></trans></span><em><span><trans data-src="h" data-dst="H"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="n" data-dst="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></trans></span></em><span><trans data-src="), where" data-dst="页：1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">页：1</font></font></trans></span><em><span><trans data-src="g" data-dst="G"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="n" data-dst="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></trans></span></em><span><trans data-src=") is the accumulated cost," data-dst="是累计成本，"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是进步成本，</font></font></trans></span><em><span><trans data-src="h" data-dst="H"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="n" data-dst="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></trans></span></em><span><trans data-src=") the estimated cost of the goal, and" data-dst="）目标的估计成本，以及"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）目标的估计成本，以及</font></font></trans></span><em><span><trans data-src="W" data-dst="W"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w ^</font></font></trans></span></em><span><trans data-src="is a constant. Higher values of" data-dst="是常数。更高的值"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是常数。更高的值</font></font></trans></span><em><span><trans data-src="W" data-dst="W"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w ^</font></font></trans></span></em><span><trans data-src="are associated with faster plan search, but also with lower plan quality (Korf, 1993). HSP2 evaluates the" data-dst="与更快的计划搜索相关，但也具有较低的计划质量（KORF，1993）。HSP2评价"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与重启的计划搜索相关，但也具有完全的计划质量（KORF，1993）。HSP2评价</font></font></trans></span><em><span><trans data-src="hadd" data-dst="哈德"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈德</font></font></trans></span></em><span><trans data-src="heuristic from the scratch in every new state generated in HSP." data-dst="从HSP中产生的每个新状态的划痕启发式。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从HSP中产生的每个每个状态的划痕启发式。</font></font></trans></span></p><p><span><trans data-src="The re-generation of" data-dst="重生"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重生</font></font></trans></span><em><span><trans data-src="hadd" data-dst="哈德"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈德</font></font></trans></span></em><span><trans data-src="is an obvious performance issue, which is a bottle neck of the HSP planners as well as related planners like UNPOP. An attempt to address this problem is HSPr (Bonet and Geffner, 1999), a variant of HSP which uses backward search from the goal rather than forward search from the initial state. The estimates are computed only once from the initial state, and the heuristic function" data-dst="是一个明显的性能问题，这是一个瓶颈的HSP规划师，以及相关的规划师，如UNPOP。解决这个问题的尝试是HSPr（博内特和GffnER，1999），HSP的变体，它使用从目标向后搜索而不是从初始状态向前搜索。估计仅从初始状态计算一次，并且启发式函数。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个明显的性能问题，这是一个必须的HSP规划师，以及相关的规划师，如UNPOP。解决这个问题的尝试是HSPr（博内特和GffnER，1999），HSP的变体，它使用从目标向后搜索而不是从初始状态向前搜索。估计仅从初始状态计算一次，和启发式函数。</font></font></trans></span><em><span><trans data-src="hadd" data-dst="哈德"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈德</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="s" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src=") is always calculated as sum of costs to achieve goals from the initial state (Bonet and Geffner, 1999). This combination of forward propagation to derive estimations and the backward search for plans is reminiscent of Graphplan (Blum and Furst, 1995), which is discussed in Sect. 4.2. While HSPr turned out to substantially improve performance in some domains, the new algorithm is inferior to HSP in others (Bonet and Geffner, 1999)." data-dst="总是被计算为从初始状态达到目标的成本之和（博内特和GffnER，1999）。这种向前传播的结合来导出估计和向后搜索计划，这让我们联想到Cop-Prand（Blum和FurST，1995），这是在SeCT中讨论的。4.2。虽然HSPr在一些领域中显著地改进了性能，但是新算法在其他方面不如HSP（博内特和GffnER，1999）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总是被计算为从初始状态达到目标的成本之和（博内特和GffnER，1999）。这种向前传播的结合来转化估计和向后搜索计划，这让我们联想到Cop-Prand（百隆和。，FurST，1995），这是在SeCT中讨论的。4.2。虽然HSPr在一些领域中显着地地改进了性能，但是新算法在其他方面不如HSP（博内特和GffnER，1999）。</font></font></trans></span></p><p><span><trans data-src="Planning as heuristic search was further advanced by the Fast Forward (FF) planner (Hoffmann, 2001), which was among the winners of the ICP2000 competition, outperforming HSP2 and others. Like HSP, FF relies on forward search in the state space, guided by a heuristic that estimates goal distances using a relaxed problem. However, FF uses a more sophisticated method of extracting heuristic values, based on a Graphplan-style algorithm (cf. Sect. 4.2). The number of actions in the relaxed solution is used as a goal distance estimate; among the advantages of Graphplan-like solution extraction is that it takes positive interactions between facts into account. The estimates are used to guide a novel kind of local search strategy, called" data-dst="规划作为启发式搜索进一步推进的快进（FF）规划师（霍夫曼，2001），这是在ICP2000竞争的赢家，表现优于HSP2和其他。与HSP一样，FF依赖于状态空间中的向前搜索，由启发式算法指导，使用一个放松的问题来估计目标距离。然而，FF使用一种更复杂的提取启发式值的方法，基于图形计划风格算法（参见SCT）。4.2）。在宽松的解决方案中的行动的数量被用作目标距离估计；图形计划式的解决方案的优点之一是考虑到事实之间的积极交互。估计被用来指导一种新的局部搜索策略，称为"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规划作为启发式搜索进一步推进的快进（FF）规划师（霍夫曼，2001），这是在ICP2000竞争的赢家，表现为HSP2和其他。与HSP一样，FF依赖于状态空间中的向向前搜索，由启发式算法指导，使用一个放松的问题来估计目标距离。然而，FF使用一种更复杂的提取启发式值的方法，基于图形计划风格算法（视为SCT）。4.2）。在宽松的解决方案中的行动的数量被采用目标距离估计；图形计划式的解决方案的优点之一是考虑到事实之间的积极相互作用。估计被用来指导一种新的局部搜索策略，称为</font></font></trans></span><em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">强制爬山</font></font></span></em><span><trans data-src=". In contrast to HSP, which randomly chooses the best successor to each intermediate state, FF evaluates all of a state’s successors (and, if necessary, the successors of the successors etc.), looking for a state with better heuristic value than the current state. In short, at each search iteration a breadth first search for a state with strictly better evaluation is performed. This strategy allows the planner to escape plateaus and local minima. A third advantageous feature of FF is its concept of" data-dst=". 与随机选择最佳中间接受者的HSP相反，FF评估所有状态的继承者（如果必要的话，继任者等的继承者），寻找具有比当前状态更好的启发式值的状态。简而言之，在每个搜索迭代中，对具有严格更好评价的状态进行广度优先搜索。这种策略允许规划师逃逸平台和局部极小值。FF的第三个优点是它的概念。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">与随机选择最佳中间接受者的HSP相反，FF评估所有状态的继承者（如果必要的话，继任者等的继承者），寻找具有比当前状态更好的启发式值的状态。 ，在每个搜索迭代中，对具有严格更好的评价的状态进行广度优先搜索。这种策略允许规划师逃逸平台和局部极小值。FF的第三个优点是它的概念。</font></font></trans></span><em><span><trans data-src="helpful actions" data-dst="有益的行动"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有益的行动</font></font></trans></span></em><span><trans data-src=", i.e. it uses the information from the planning graph to identify at each state those actions that appear most useful in terms of the effects they achieve and it prefers those actions over the operators that seem superfluous (Hoffmann, 2001; Hoffmann and Nebel, 2001)." data-dst="也就是说，它使用规划图中的信息来识别在每一状态下那些在它们所达到的效果方面看起来最有用的动作，并且它更喜欢那些看起来多余的操作符的动作（霍夫曼，2001；霍夫曼和内伯尔，2001）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，它使用规划图中的信息来识别在每个状态下那些在其所达到的效果方面看起来最有用的动作，并且它更喜欢那些看起来多余的操作符的动作（霍夫曼，2001；霍夫曼和内伯尔，2001）。</font></font></trans></span></p><p><span><trans data-src="An extension to FF, called Metric-FF, was presented in (Hoffmann, 2003; Hoffmann, 2002); it handles numerical variables, constraints and effects as captured in PDDL 2.1 level 2. Metric-FF supports numerical state variables which can be used in numerical constraints in preconditions (e.g." data-dst="FF的扩展，称为度量FF，在（霍夫曼，2003；霍夫曼，2002）中提出；它处理PDDL 2.1级2中捕获的数值变量、约束和效果。度量FF支持数值状态变量，其可用于前提条件下的数值约束（例如）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF的扩展，称为变量FF，在（霍夫曼，2003；霍夫曼，2002）中提出；它处理PDDL 2.1级2中捕获的数值变量，约束和效果。变量FF支持数值状态变量，其可用于预期条件下的数值约束（例如）。</font></font></trans></span><em><span><trans data-src="cash &gt;" data-dst="现金&amp;#62;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现金＆＃62;</font></font></trans></span></em><span><trans data-src="100) and in arithmetic operations in effects (e.g." data-dst="100）和在算术运算中的效果（例如）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100）和在算术运算中的效果（例如）</font></font></trans></span><em><span><trans data-src="cash" data-dst="现金"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现金</font></font></trans></span></em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> − = 10） ）。</font></font></span></p><p><span><trans data-src="While the heuristics using a relaxed planning graph has had remarkable success in recent years, in some domains the FF and HSP families of planners perform poorly, because their relaxation method of ignoring negative effects loses too much vital information. A recent heuristic search planner which addresses this problem is Fast Downward (Helmert and Richter, 2004). In contrast to the previous planners like HSP and FF, it does not use a relaxed planning graph but it uses Causal Graph (CG) data structures (Helmert, 2004) instead." data-dst="虽然近年来使用放松规划图的启发式算法已经取得了令人瞩目的成功，但在某些领域，规划师的FF和HSP家庭表现不佳，因为他们忽略负面效应的松弛方法失去了太多的重要信息。最近的启发式搜索规划解决这个问题是快速下降（赫尔默特和李希特，2004）。与以前的规划师，如HSP和FF相比，它不使用一个轻松的规划图，而是使用因果图（CG）数据结构（赫尔默特，2004）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虽然有时使用校正规划图的启发式算法已经取得了惊人的目的成功，但在某些领域，规划师的FF和HSP家庭表现不佳，因为他们忽略了效应的替代方法失去了太多的重要信息。最近的启发式搜索规划解决这个问题是快速下降（赫尔默特和李希特，2004）。与以前的规划师，如HSP和FF分类，它不使用一个轻松的规划图，而是使用因果图（CG）数据结构（赫尔默特，2004）。</font></font></trans></span></p><h3><a name="4.2---------graph-based-planning" class="md-header-anchor"></a><span><trans data-src="4.2         Graph Based Planning" data-dst="4.2图规划"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2图规划</font></font></trans></span></h3><p><span><trans data-src="Several planners discussed so far utilize graph structures for the extraction of heuristics. In this section, we will discuss the graph planning framework introduced in (Blum and Furst, 1995), which formalizes the construction, annotation and analysis of a compact structure called Planning Graph. Despite some similarity, Planning Graphs are not space graphs such as those used in UNPOP. In fact, unlike the state-space graph, in which a plan is a path through the graph, in a Planning Graph, a plan is a" data-dst="迄今为止讨论的几个规划者利用图结构来提取启发式算法。在本节中，我们将讨论在（Blum和FurST，1995）中引入的图形规划框架，它将紧凑的结构称为规划图的构造、注释和分析进行了形式化。尽管有一些相似性，规划图不是空间图，如在UNPOP使用的。事实上，不同于状态空间图，其中计划是通过图的路径，在计划图中，计划是"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本节中，我们将讨论在（Blum和FurST，1995）中的图形规划框架，并采用尺寸较小的结构称为规划图的。构造，注释和分析进行了形式化。尽管有一些相似性，规划图不是空间图，如在UNPOP使用的。事实上，相互状态空间图，其中计划是通过图的路径，在计划图中，计划是</font></font></trans></span><em><span><trans data-src="flow" data-dst="流"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流</font></font></trans></span></em><span><trans data-src="in the network flow sense (Blum and Furst, 1997)." data-dst="在网络流意义上（Blum和FurST，1997）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在网络流意义上（Blum和FurST，1997）。</font></font></trans></span></p><p><span><trans data-src="A Planning Graph is a directed leveled graph. It consists of two types of nodes, namely" data-dst="规划图是有向水平图。它由两种类型的节点组成，即"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规划图是有向水平图。它由两种类型的例程组成，即</font></font></trans></span><em><span><trans data-src="action nodes" data-dst="动作节点"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动作例程</font></font></trans></span></em><span><trans data-src="and" data-dst="和"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font></trans></span><em><span><trans data-src="proposition nodes" data-dst="命题节点"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命题推理</font></font></trans></span></em><span><trans data-src=". These nodes are arranged in alternating" data-dst=". 这些节点是交替排列的。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这些二进制是交替排列的。</font></font></trans></span><em><span><trans data-src="levels" data-dst="水平"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水平</font></font></trans></span></em><span><trans data-src="consisting of proposition nodes followed by layers of action nodes, and so forth. Each level is associated with a time step. The first level of a Planning Graph is a proposition level which consists of one node for each proposition of the initial situation. The second level is an action level which contains all actions whose preconditions are satisfied by the proposition nodes of the first level. The third level is again a proposition level, containing the proposition nodes from the first level and proposition nodes that represent the effects of the actions of the preceding action layer. The construction of the Planning Graph stops when two consecutive propositional layers are identical; it has been shown that this always occurs, guaranteeing the termination of the process. The complexity of creating a Planning Graph is low-order polynomial in the number of actions and propositions (Blum and Furst, 1997)." data-dst="由命题节点后面跟着动作节点的层组成的，等等。每个级别与时间步长相关联。规划图的第一层是一个命题级，它由初始条件的每个命题的一个节点组成。第二级是包含第一级命题节点满足其前提条件的所有动作的动作级。第三级又是命题级，包含来自第一级的命题节点和表示先前动作层动作效果的命题节点。当两个连续的命题层是相同的时，规划图的构造停止；已经表明，这总是发生，保证过程的终止。创建计划图的复杂性是动作数和命题数的低阶多项式（Blum和FurST，1997）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个等级与时间步长相关联。规划图的第一层是一个命题级，它由初始条件的每个命题的一个分组组成。第三级又是命题级，包含来自第一级的命题中断和表示先前动作层动作效果的命中题队列。当两个连续时的命题层是相同的时，规划图的构造停止；已经表明，这总是发生，保证过程的终止。创建计划图的复杂性是动作数和命题数的低阶多重式（Blum和Furst，1997） 。</font></font></trans></span></p><p><span><trans data-src="All actions at some level" data-dst="在某种程度上的所有行动"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在某种程度上的所有行动</font></font></trans></span><em><span><trans data-src="i" data-dst="I"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一世</font></font></trans></span></em><span><trans data-src="are connected to the preconditions at level" data-dst="在水平上连接到先决条件"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在水平上连接到先决条件</font></font></trans></span><em><span><trans data-src="i" data-dst="I"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一世</font></font></trans></span></em><span><trans data-src="−1 and its effects at level" data-dst="1及其在水平上的作用"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1及其在水平上的作用</font></font></trans></span><em><span><trans data-src="i" data-dst="I"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一世</font></font></trans></span></em><span><trans data-src="+1, introducing or negating proposition in" data-dst="1，引入或否定命题。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1，日期或否定命题</font></font></trans></span><em><span><trans data-src="i" data-dst="I"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一世</font></font></trans></span></em><span><trans data-src="+1. For literals that persist from layers" data-dst="1。对于从层持久化的文字"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1。对于从层持久化的文字</font></font></trans></span><em><span><trans data-src="i" data-dst="I"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一世</font></font></trans></span></em><span><trans data-src="−1 to" data-dst="1至"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1至</font></font></trans></span><em><span><trans data-src="i" data-dst="I"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一世</font></font></trans></span></em><span><trans data-src="+1 and are not connected to action nodes, persistence action nodes are added. Further, (Blum and Furst, 1995) defines mutual exclusions (“mutex”) relations for actions and literals. The possible mutex relations between actions are" data-dst="1，并且没有连接到动作节点，持久化动作节点被添加。此外，（Blum和FurST，1995）定义了动作和文字的相互排斥（“互斥”）关系。动作之间可能互斥的关系是"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1，并且没有连接到动作节点，持久化动作的被添加。。（Blum和FurST，1995）定义了动作和文字的相互区别（“互斥”）关系。动作之间可能互斥的关系是</font></font></trans></span><em><span><trans data-src="inconsistent effects" data-dst="不一致效应"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绝对效应</font></font></trans></span></em><span><trans data-src=", where one action negates an effect of the other," data-dst="一个动作否定另一个动作的效果，"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个动作否定另一个动作的效果，</font></font></trans></span><em><span><trans data-src="inference" data-dst="推论"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推论</font></font></trans></span></em><span><trans data-src=", where one of the effects of one actions is the negation of a precondition of the other and" data-dst="其中一个动作的效果之一是否定另一个动作的前提条件。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中一个动作的效果之一是否定另一个动作的适用条件。</font></font></trans></span><em><span><trans data-src="competing needs" data-dst="竞争需要"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">竞争需要</font></font></trans></span></em><span><trans data-src=", where one of the preconditions of one action is mutually exclusive with a precondition of the other. A mutual relation holds between two propositions on the same level if one is the negation of the other or if each possible pair of actions that could achieve the two propositions is mutually exclusive (Russel and Norvig, 2002)." data-dst="一个动作的前提条件是相互排斥的前提条件。如果一个命题是对另一个命题的否定，或者如果能实现这两个命题的每一对可能的动作是互斥的（RuSSEL和Nordvig，2002），那么在同一水平上的两个命题之间存在相互关系。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果一个命题是对另一个命题的否定，或者如果能实现这两个命题的每一对可能的动作是互斥的（RuSSEL和Nordvig，2002），那么在同一水平上的两个命题之间存在相互关系。</font></font></trans></span></p><p><span><trans data-src="The information captured in such a Planning Graph, especially the exclusion relations propagate a variety of intuitively useful facts about the problem. This information can be used by planners to guide their search. The first planner using this technique was Graphplan, which was introduced in (Blum and Furst, 1995). The Graphplan algorithm operates in two main steps which alternate within a loop:" data-dst="在这样的规划图中捕获的信息，特别是排除关系传播关于问题的各种直观有用的事实。这些信息可以被规划者用来指导他们的搜索。使用这种技术的第一个计划是图形计划，这是在（Blum和FurST，1995）中引入的。图形计划算法运行在两个主要步骤中，在一个循环中交替："><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这样的规划图中捕获的信息，特别是排除关系传播关于问题的各种直观有用的事实。这些信息可以被规划者用来指导他们的搜索。使用这种技术的第一个计划是图形计划，这是在（Blum和FurST，1995）中约会的。图形计划算法运行在两个主要步骤中，在一个循环中交替：</font></font></trans></span><em><span><trans data-src="graph expansion" data-dst="图展开"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图展开</font></font></trans></span></em><span><trans data-src="and" data-dst="和"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font></trans></span><em><span><trans data-src="solution extraction" data-dst="溶液萃取"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">溶液萃取</font></font></trans></span></em><span><trans data-src=". Graph expansion grows the Planning Graph as sketched above, until a propositional level is reached where all goal propositions are present with no mutex links between any pair of them. This is a necessary (but insufficient) condition for plan existence. To look for potential plans, the solution extraction phase is then started. The Graphplan algorithm uses a backward-chaining strategy, using a level-by-level approach in order to make best use of the mutual exclusion constraints (Blum and Furst, 1997). Given a set of goals at a time (level)" data-dst=". 图形扩展增长规划图如上所述，直到达到命题水平，其中所有目标命题是存在的，没有互斥链接之间的任何一对。这是计划存在的必要条件（但不充分）。为了寻找潜在的计划，然后开始解决方案提取阶段。图形计划算法使用反向链接策略，使用逐级的方法来最好地利用互斥约束（Blum和FurST，1997）。一次给定一组目标（水平）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">图形扩展增长规划指标缩小，直到达到命题水平，其中所有目标命题是存在的，没有互斥链接之间的任何一对。这是计划存在的必要条件（但不充分）。为了寻找潜在的计划，然后开始解决方案提取阶段。图形计划算法使用反向链接策略，使用逐级的方法来最好地利用互斥约束（Blum和Furst，1997）。一次给定一个目标（水平）</font></font></trans></span><em><span><trans data-src="t" data-dst="T"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ť</font></font></trans></span></em><span><trans data-src=", Graphplan aims to determine a set of actions at time" data-dst="图形计划旨在及时确定一组动作。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图形计划提前及时确定一组动作。</font></font></trans></span><em><span><trans data-src="t" data-dst="T"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ť</font></font></trans></span></em><span><trans data-src="−1 which have these goals as effects. At each step, only actions that are not mutually exclusive with existing actions in the plan are considered. On failure, Graphplan tracks back and tries different action sets. If no plan is found and the Planning Graph is not leveled off yet, then Graphplan resumes graph expansion until another promising propositional layer is reached. The solution extraction can be formulated as a constraint solving problem[" data-dst="1有这些目标作为效果。在每个步骤中，只考虑与计划中的现有动作不互斥的动作。失败后，Graphplan回溯并尝试不同的动作集。如果没有找到计划和规划图尚未平平，那么图形计划恢复图形扩展，直到达到另一个有前途的命题层。可将解的提取归结为约束求解问题。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1有这些目标作为效果。在每个步骤中，只考虑与计划中的现有动作不互斥的动作。失败后，Graphplan回溯并尝试不同的动作集。如果没有找到计划和规划图尚未平，那么图形计划恢复图形扩展，直到达到另一个有前途的命题层。可将解的提取归结为约束转化问题。</font></font></trans></span><a href="https://ziyanliupb.github.io/#"><span><trans data-src="4" data-dst="四"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">四</font></font></trans></span><span><trans data-src="]" data-dst="]"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]</font></font></trans></span></a><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Do和Kambhampati，2001）或搜索问题（Russel和Norvig，2002）。</font></font></span></p><p><span><trans data-src="Graphplan’s advantages are besides its good performance its theoretical properties such as soundness, completeness, generation of shortest plans and termination on unsolvable problems. However, the original Graphplan algorithm has some limitations: first, its representation language is restricted to pure STRIPS operators, no conditional or universally quantified effects are allowed; and second, the performance can decrease drastically if too much irrelevant information is contained in the specification of a planning task (Nebel et al., 1997)." data-dst="图形计划的优点除了其良好的性能，它的理论性质，如健全性，完整性，生成最短计划和终止在不可解的问题。然而，原始的图形规划算法有一些局限性：首先，它的表示语言被限制为纯的条带操作符，不允许有条件或普遍量化的效果；第二，如果在规划任务的规范中包含太多不相关的信息，则性能会急剧下降（Nebelet等人，1997）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图形计划的优点除了其良好的性能，它的理论性质，如健全性，本身，生成最短计划和终止在不可解的问题。然而，原始的图形规划算法有一些局限性：首先，它的表示语言被限制为纯的条带操作符，允许有条件或普遍量化的效果；第二，如果在规划任务的规范中包含太多不相关的信息，则性能会急剧下降（Nebelet等人，1997） 。</font></font></trans></span></p><p><span><trans data-src="In (Koehler et al., 1997), an early version of the Ipp planner is presented, which extends Graphplan to handling conditional and universally quantified effects. The authors show that this extension comes with negligible computational overhead and competes well with other planners that support ADL subsets (e.g. UCPOP and Prodigy). In additional work, the RIFO (Removing Irrelevant Operators and Initial Facts from Planning Problems) strategy (Koehler et al., 1997) was added to Ipp, addressing Graphplan’s problem with irrelevant information. Further, a Goal Agenda Manager (GAM) to order sets of subgoals and incrementally plan for subproblems (Koehler and Hoffmann, 2000) has been added to Ipp, and more recently to the FF planner." data-dst="在（Koehler等人，1997）中，提出了IPP规划师的早期版本，它扩展了图形计划来处理条件和普遍量化的效果。作者指出，这种扩展具有可忽略的计算开销，并且与支持ADL子集的其他规划者（例如UCPP和神童）竞争良好。在另外的工作中，将RIFO（去除无关的操作符和从规划问题中得到的初始事实）策略（Koehler等人，1997）添加到IPP中，用不相关的信息来解决Graphplan的问题。此外，目标议程管理器（GAM）来订购子目标集和增量计划子问题（Koehler和霍夫曼，2000）已被添加到IPP，以及最近的FF规划。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在（Koehler等人，1997）中，提出了IPP规划师的早期版本，它扩展了图形计划来处理条件和普遍转变的效果。作者指出，这种扩展具有可忽略的计算开销，并且与支持ADL子集的其他规划者（例如UCPP和神童）竞争良好。在另外的工作中，将RIFO（除去无关的操作符和从规划问题中得到的初始事实）策略（Koehler等人，1997）添加到IPP中，用不相关的信息来解决Graphplan的问题。最终，目标议程管理器（GAM）来订购子目标集和增量计划子问题（Koehler和霍夫曼，2000）已被添加到IPP，以及最近的FF规划。</font></font></trans></span></p><p><span><trans data-src="Another planner based on Graphplan that has evolved over time is Stan (Long and Fox, 1999). It improves Graphplan in several ways. First, Stan performs a number of preprocessing analyses, or STate ANalyses, on the planning domain before planning, using the Type Inference Module (TIM) described in (Fox and Long, 1998). Further, Stan uses an efficient internal representation of preconditions and effects (as bit vectors), which allows for resource-efficient representations of the planning graph (called" data-dst="另一个基于图形计划的规划师，随着时间的推移，是Stan（龙和狐狸，1999）。它在几个方面改进了Graphplan。首先，Stan使用规划中的类型推断模块（提姆）（Fox and Load，1998）在规划之前对规划域执行若干预处理分析或状态分析。此外，Stan使用预条件和效应的有效内部表示（作为位向量），这允许规划图的资源有效表示（称为"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个基于图形计划的规划师，通过时间的过渡，是Stan（龙和狐狸，1999）。它在几个方面进行了改进。和负载，1998）在规划之前对规划域执行多个预先分析或状态分析。转换，Stan使用预条件和效应的有效内部表示（作为位向量），这允许规划图的资源有效表示（称为</font></font></trans></span><em><span><trans data-src="spike" data-dst="道钉"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">道钉</font></font></trans></span></em><span><trans data-src=") and allows to carry out the mutex-checks between actions and facts using efficient bit manipulating operations[" data-dst="并且允许使用有效的位操作操作执行动作和事实之间的互斥检查。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且允许使用有效的位操作操作执行动作和事实之间的互斥检查。</font></font></trans></span><a href="https://ziyanliupb.github.io/#"><span><trans data-src="5" data-dst="五"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">五</font></font></trans></span><span><trans data-src="]" data-dst="]"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]</font></font></trans></span></a><span><trans data-src=". Further, redundant information is avoided in the spike structure, using a technique called" data-dst=". 此外，在尖峰结构中避免冗余信息，使用所谓的技术。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此外，在尖峰结构中避免多余信息，使用所谓的技术。</font></font></trans></span><em><span><trans data-src="wave front" data-dst="波前"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">波前</font></font></trans></span></em><span><trans data-src="(Long and Fox, 1999), which results in advantageous space requirements over Graphplan." data-dst="（long和狐，1999），这对图形计划产生了有利的空间需求。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（long和狐，1999），这对图形计划产生了有利的空间需求。</font></font></trans></span></p><p><span><trans data-src="Sensory Graphplan SGP (Weld et al., 1998) is an extension to Graphplan that not only supports conditional effects in the way described in (Gazen and Knoblock, 1997), but also deals with uncertain effects (Smith and Weld, 1998) and uncertainty in the initial situation. The idea presented in (Smith and Weld, 1998) is to extend a separate planning graph for each possible world, keeping track of mutual exclusion across the worlds, and then to search backwards for a plan that works in all possible worlds. SGP introduces observational effects of the form" data-dst="感官图形计划SGP（CURE等人，1998）是图形计划的扩展，不仅支持在条件（Gazen和KNOBRON，1997）中描述的条件效应，而且还处理不确定的影响（史米斯和焊缝，1998）和初始情况下的不确定性。（史米斯和Curn，1998）中提出的想法是为每个可能的世界扩展一个单独的规划图，跟踪世界上的相互排斥，然后向后搜索一个在所有可能的世界中工作的计划。SGP介绍了表单的观察效果"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">感官图形计划SGP（CURE等人，1998）是图形计划的扩展，既支持在条件（Gazen和KNOBRON，1997）中描述的条件效应，而且还处理不确定的影响（史米斯和焊缝，1998 ）和初始情况下的不确定性。（史米斯和Curn，1998）中提出的想法是为每个可能的世界扩展一个单独的规划图，跟踪世界上的相互关联，然后向后搜索一个在所有可能的世界中工作的计划。SGP介绍了表单的观察效果</font></font></trans></span><em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（swwf）</font></font></span></em><span><trans data-src=", where" data-dst="在哪里"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在哪里</font></font></trans></span><em><span><trans data-src="wwf" data-dst="世界自然基金会"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">世界自然基金会</font></font></trans></span></em><span><trans data-src="denotes an arbitrary logical expression composed of propositions. Operators in SGP may have zero or more such observational effects, which, when executed at runtime, deliver the truth value of the specified expression" data-dst="表示由命题组成的任意逻辑表达式。SGP的操作员可能有零个或多个这样的观察效果，当在运行时执行时，传递指定表达式的真值。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示由命题组成的任意逻辑表达式。SGP的操作员可能有零个或多个这样的观察效果，​​当在运行时执行时，传递指定表达式的真值。</font></font></trans></span><em><span><trans data-src="wwf" data-dst="世界自然基金会"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">世界自然基金会</font></font></trans></span></em><span><trans data-src=". To accomplish this extension of Graphplan, SGP modifies the graph expansion phase, such that it derives knowledge propositions from the sensor definitions and the previous planning-graph proposition layer. In addition, it incorporates a conditioning threat resolution method into the solution extraction phase. Furthermore, SGP generates contingent plans with branches that can rejoin." data-dst=". 为了完成图形扩展的这种扩展，SGP修改了图形扩展阶段，使得它从传感器定义和先前的规划图命题层导出知识命题。此外，它结合了一个条件威胁解决方法进入解决方案提取阶段。此外，SGP生成具有可重新加入的分支的应急计划。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了完成图形扩展的这种扩展，SGP修改了图形扩展阶段，并使其从传感器定义和先前的规划图命题层转换为知识命题。 SGP生成具有可重新加入的分支的应急计划。</font></font></trans></span></p><h3><a name="4.3---------partial-order-refinement-planning" class="md-header-anchor"></a><span><trans data-src="4.3         Partial Order Refinement Planning" data-dst="4.3偏序细化规划"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3偏序细化规划</font></font></trans></span></h3><p><span><trans data-src="In contrast to the techniques discussed so far, Partial Order Refinement Planners – also called Partial Order Causal Link Planners (POCL) or Partial Order Planners (POP) – formulate the planning problem not as search through the space of" data-dst="与迄今所讨论的技术相反，偏序细化规划者（也称为偏序因果链接规划者（POCL）或偏序规划师（POP））制定规划问题而不是搜索空间。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与完善今所讨论的技术相反，偏序细化规划者（也称为偏序因果链接规划者（POCL）或偏序规划师（POP））制定规划问题而不是搜索空间。</font></font></trans></span><em><span><trans data-src="world states" data-dst="世界各国"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">世界各国</font></font></trans></span></em><span><trans data-src=", but rather as a search in the space of" data-dst="而是作为一种在空间中的搜索"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是作为一种在空间中的搜索</font></font></trans></span><em><span><trans data-src="partiallyspecified plans" data-dst="局部指定方案"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">局部指定方案</font></font></trans></span></em><span><trans data-src=", i.e. the nodes of the search space are not states but" data-dst="，即搜索空间的节点不是状态，而是"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即搜索空间的基线不是状态，甚至</font></font></trans></span><em><span><trans data-src="plans" data-dst="计划"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计划</font></font></trans></span></em><span><trans data-src=", and the arcs between the nodes are not action executions but" data-dst="节点之间的弧不是动作执行，而是"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">报表之间的弧不是动作执行，又</font></font></trans></span><em><span><trans data-src="plan refinements" data-dst="计划细化"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计划细化</font></font></trans></span></em><span><trans data-src="." data-dst="."><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></trans></span></p><p><span><trans data-src="POCL planners usually produce partially ordered plans, i.e. not all actions have a fixed order in the plan, and a plan may have several different linearizations, which all achieve the identical result." data-dst="POCL规划师通常会产生部分有序的计划，即不是所有的行动都有一个固定的顺序在计划中，一个计划可以有几个不同的线性化，这都实现了相同的结果。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POCL规划师通常会产生部分有序的计划，即不是所有的动作都有一个固定的顺序在计划中，一个计划可以有几个不同的线性化，这都实现了相同的结果。</font></font></trans></span></p><p><span><trans data-src="A partially ordered plan, in older literature also called task network, can be represented as a quadruple" data-dst="偏序计划在旧文献中也被称为任务网络，可以表示为四元组。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偏序计划在旧文献中也被称为任务网络，可以表示为四元组。</font></font></trans></span><em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> π</font></font></span></em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = hS</font></font></span><font style="vertical-align: inherit;"><em><span><font style="vertical-align: inherit;"> π</font></span></em></font><em><span><trans data-src="," data-dst="，"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></trans></span></em><span><trans data-src="O" data-dst="o"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ø</font></font></trans></span><em><span><trans data-src="," data-dst="，"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></trans></span></em><span><trans data-src="B" data-dst="乙"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乙</font></font></trans></span><em><span><trans data-src="," data-dst="，"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></trans></span></em><span><trans data-src="Li, which consists of the following components: S is a set of plan steps, i.e. instances of operations. O is a set of ordering constraints. Each ordering constraint is of the form" data-dst="李，它由以下组件组成：S是一组计划步骤，即操作实例。O是一组有序约束。每个排序约束都是形式约束。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">李，它由以下组件组成：S是一组计划步骤，即操作实例。O是一组有序约束。每个排序约束都是形式约束。</font></font></trans></span><em><span><trans data-src="si" data-dst="硅"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硅</font></font></trans></span></em><span><trans data-src="≺" data-dst="γ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">γ</font></font></trans></span><em><span><trans data-src="sj" data-dst="SJ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></trans></span></em><span><trans data-src=", which means that the step" data-dst="这意味着这一步骤"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这意味着这一步骤</font></font></trans></span><em><span><trans data-src="si" data-dst="硅"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硅</font></font></trans></span></em><span><trans data-src="must be executed" data-dst="必须执行"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须执行</font></font></trans></span><em><span><trans data-src="before" data-dst="之前"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之前</font></font></trans></span></em><span><trans data-src="step" data-dst="步"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">步</font></font></trans></span><em><span><trans data-src="sj" data-dst="SJ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></trans></span></em><span><trans data-src=". If the set S of some plan" data-dst=". 如果某个计划的集合S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果某个计划的集合S</font></font></trans></span><em><span></span></em><span><trans data-src="has at least two steps" data-dst="至少有两个步骤"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">至少有两个步骤</font></font></trans></span><em><span><trans data-src="sa" data-dst="SA"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">南非</font></font></trans></span></em><span><trans data-src="and" data-dst="和"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font></trans></span><em><span><trans data-src="sb" data-dst="某人"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">某人</font></font></trans></span></em><span><trans data-src="where O neither contains" data-dst="哪里都不包含"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哪里都不包含</font></font></trans></span><em><span><trans data-src="sa" data-dst="SA"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">南非</font></font></trans></span></em><span><trans data-src="≺" data-dst="γ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">γ</font></font></trans></span><em><span><trans data-src="sb" data-dst="某人"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">某人</font></font></trans></span></em><span><trans data-src="nor" data-dst="也不"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也不</font></font></trans></span><em><span><trans data-src="sa" data-dst="SA"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">南非</font></font></trans></span></em><span><trans data-src="≺" data-dst="γ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">γ</font></font></trans></span><em><span><trans data-src="sb" data-dst="某人"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">某人</font></font></trans></span></em><span><trans data-src=", then" data-dst="然后"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后</font></font></trans></span><em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> π</font></font></span></em><font style="vertical-align: inherit;"><span><font style="vertical-align: inherit;"> =</font></span><span><font style="vertical-align: inherit;"> 6 =</font></span><span><font style="vertical-align: inherit;">是常数值或引用到其他计划步骤的变量。</font></span><span><font style="vertical-align: inherit;">如果仅使用平面图步骤，则B =∅。</font></span><span><font style="vertical-align: inherit;">L是一组因果关系。</font></span><span><font style="vertical-align: inherit;">因果链接用于跟踪计划中引入步骤的原因，并防止其他步骤干扰该目的。</font></span><span><font style="vertical-align: inherit;">如果步骤</font></span></font><span><trans data-src="is a" data-dst="是一个"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个</font></font></trans></span><em><span><trans data-src="partially ordered" data-dst="偏序"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偏序</font></font></trans></span></em><span><trans data-src="plan. B is a set of variable binding constraints on the parameters of action instances: Each variable constraint is of the form" data-dst="计划B是动作实例参数的一组变量绑定约束：每个变量约束都是形式的。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计划B是动作实例参数的每个变量绑定约束：每个变量约束都是形式的。</font></font></trans></span><em><span><trans data-src="var" data-dst="var"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变种</font></font></trans></span></em><span></span><em><span><trans data-src="x" data-dst="X"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></trans></span></em><span><trans data-src="or" data-dst="或"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font></trans></span><em><span><trans data-src="var" data-dst="var"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变种</font></font></trans></span></em><span></span><em><span><trans data-src="x" data-dst="X"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></trans></span></em><span><trans data-src=", where" data-dst="在哪里"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在哪里</font></font></trans></span><em><span><trans data-src="var" data-dst="var"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变种</font></font></trans></span></em><span><trans data-src="is a variable of some plan step and" data-dst="是一些计划步骤的变量"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一些计划步骤的变量</font></font></trans></span><em><span><trans data-src="x" data-dst="X"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></trans></span></em><span></span><em><span><trans data-src="si" data-dst="硅"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硅</font></font></trans></span></em><span><trans data-src="achieves a proposition" data-dst="实现命题"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现命题</font></font></trans></span><em><span><trans data-src="p" data-dst="磷"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">磷</font></font></trans></span></em><span><trans data-src="to satisfy a precondition of step" data-dst="满足步骤的先决条件"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">满足步骤的先决条件</font></font></trans></span><em><span><trans data-src="sj" data-dst="SJ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></trans></span></em><span><trans data-src=", the causal link" data-dst="因果联系"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因果联系</font></font></trans></span><em><span><trans data-src="si" data-dst="硅"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硅</font></font></trans></span></em><span><trans data-src="→" data-dst="渐次"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渐次</font></font></trans></span><em><span><trans data-src="p sj" data-dst="P-SJ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></trans></span></em><span><trans data-src="is added to L." data-dst="被添加到L。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">被添加到L</font></font></trans></span></p><p><span><trans data-src="Further, the following derived sets are considered in partial order planning: OC is the set of open conditions of a plan. An open condition →" data-dst="此外，在部分顺序规划中考虑以下派生集：OC是计划的开放条件集。开放条件"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，在部分顺序规划中考虑以下派生集：OC是计划的开放条件集。开放条件</font></font></trans></span><em><span><trans data-src="p s" data-dst="Ps"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">聚苯乙烯</font></font></trans></span></em><span><trans data-src="emerges when" data-dst="出现时"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出现时</font></font></trans></span><em><span><trans data-src="p" data-dst="磷"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">磷</font></font></trans></span></em><span><trans data-src="is a literal that is part of" data-dst="是文字的一部分"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是文字的一部分</font></font></trans></span><em><span><trans data-src="Prec(s)" data-dst="前S（S）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前S（S）</font></font></trans></span></em><span><trans data-src="and when there is no causal link" data-dst="当没有因果联系时"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当没有因果联系时</font></font></trans></span><em><span><trans data-src="sx" data-dst="SX"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SX</font></font></trans></span></em><span><trans data-src="→" data-dst="渐次"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渐次</font></font></trans></span><em><span><trans data-src="p s" data-dst="Ps"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">聚苯乙烯</font></font></trans></span></em><span><trans data-src="in L. In other words, open conditions are preconditions of plan steps which have not yet been addressed by the current plan. UL is the set of unsafe links. A causal link" data-dst="换句话说，在L.，开放条件是计划步骤的先决条件，目前的计划尚未解决。UL是一组不安全的链接。因果联系"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原因，在L.，开放条件是计划步骤的先决条件，目前的计划尚未解决。UL是一组不安全的链接。</font></font></trans></span><em><span><trans data-src="si" data-dst="硅"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硅</font></font></trans></span></em><span><trans data-src="→" data-dst="渐次"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渐次</font></font></trans></span><em><span><trans data-src="p sj" data-dst="P-SJ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></trans></span></em><span><trans data-src="is called" data-dst="被称为"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">被称为</font></font></trans></span><em><span><trans data-src="unsafe" data-dst="不安全的"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不安全的</font></font></trans></span></em><span><trans data-src="if there exists a step" data-dst="如果存在一个步骤"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果存在一个步骤</font></font></trans></span><em><span><trans data-src="sk" data-dst="SK"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SK</font></font></trans></span></em><span><trans data-src="∈ S such that (i) ¬" data-dst="这样（我）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样（我）</font></font></trans></span><em><span><trans data-src="p" data-dst="磷"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">磷</font></font></trans></span></em><span><trans data-src="is part of the effect of (" data-dst="是影响的一部分"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是影响的一部分</font></font></trans></span><em><span><trans data-src="sk" data-dst="SK"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SK</font></font></trans></span></em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和（ii）O是含{一致</font></font></span><em><span><trans data-src="si" data-dst="硅"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硅</font></font></trans></span></em><span><trans data-src="≺" data-dst="γ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">γ</font></font></trans></span><em><span><trans data-src="sk" data-dst="SK"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SK</font></font></trans></span></em><span><trans data-src="≺" data-dst="γ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">γ</font></font></trans></span><em><span><trans data-src="sj" data-dst="SJ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></trans></span></em><span><trans data-src="}. In such a case," data-dst="}。在这种情况下，"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">}。在这种情况下，</font></font></trans></span><em><span><trans data-src="sk" data-dst="SK"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SK</font></font></trans></span></em><span><trans data-src="is said to" data-dst="据说"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以说</font></font></trans></span><em><span><trans data-src="threaten" data-dst="威胁"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">威胁</font></font></trans></span></em><span><trans data-src="the causal link" data-dst="因果联系"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因果联系</font></font></trans></span><em><span><trans data-src="si" data-dst="硅"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硅</font></font></trans></span></em><span><trans data-src="→" data-dst="渐次"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渐次</font></font></trans></span><em><span><trans data-src="p sj" data-dst="P-SJ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></trans></span></em><span><trans data-src=". The union of a plan’s open conditions and unsafe links is called the set F of" data-dst=". 计划的开放条件和不安全链接的结合称为集合F。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">计划的开放条件和不安全链接的结合称为集合F。</font></font></trans></span><em><span><trans data-src="flaws" data-dst="瑕疵"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">瑕疵</font></font></trans></span></em><span><trans data-src="of" data-dst="属于"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属于</font></font></trans></span><em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> π</font></font></span></em><font style="vertical-align: inherit;"><em><span><font style="vertical-align: inherit;"> π</font></span></em><span><font style="vertical-align: inherit;">）= OC（</font></span><em><span><font style="vertical-align: inherit;">π</font></span></em><span><font style="vertical-align: inherit;">）∪UL（</font></span><em><span><font style="vertical-align: inherit;">π</font></span></em><span><font style="vertical-align: inherit;">）。</font></span><span><font style="vertical-align: inherit;">计划</font></span><em><span><font style="vertical-align: inherit;">π</font></span></em></font><span><trans data-src=", i.e. F(" data-dst="页：1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">页：1</font></font></trans></span><em><span></span></em><span></span><em><span></span></em><span></span><em><span></span></em><span></span><em><span></span></em><span><trans data-src="that has no flaws is called" data-dst="没有瑕疵的叫做"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有瑕疵的叫做</font></font></trans></span><em><span><trans data-src="complete" data-dst="完成"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成</font></font></trans></span></em><span><trans data-src="." data-dst="."><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></trans></span></p><p><span><trans data-src="An open condition →" data-dst="开放条件"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开放条件</font></font></trans></span><em><span><trans data-src="p s" data-dst="Ps"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">聚苯乙烯</font></font></trans></span></em><span><trans data-src="can be resolved by introducing or reusing a plan step that has an effect achieving" data-dst="可以通过引入或重用具有实现效果的计划步骤来解决。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以通过约会或重用具有实现效果的计划步骤来解决。</font></font></trans></span><em><span><trans data-src="p" data-dst="磷"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">磷</font></font></trans></span></em><span><trans data-src=". On the other hand, a" data-dst=". 另一方面，A"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">另外，A</font></font></trans></span><em><span><trans data-src="threat" data-dst="威胁"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">威胁</font></font></trans></span></em><span><trans data-src="of a causal link" data-dst="因果联系的"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因果联系的</font></font></trans></span><img src="./空值_files/clip_image002.gif" alt="img" referrerpolicy="no-referrer"><span><trans data-src="by a step" data-dst="一步一步"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一步一步</font></font></trans></span><em><span><trans data-src="sk" data-dst="SK"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SK</font></font></trans></span></em><span><trans data-src="can be possibly resolved either by" data-dst="也可以通过"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也可以通过</font></font></trans></span><em><span><trans data-src="promotion" data-dst="促销"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">促销</font></font></trans></span></em><span><trans data-src=", i.e. by adding an ordering constraint" data-dst="，即通过添加排序约束"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即通过添加排序约束</font></font></trans></span><em><span><trans data-src="sk" data-dst="SK"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SK</font></font></trans></span></em><span><trans data-src="≺" data-dst="γ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">γ</font></font></trans></span><em><span><trans data-src="si" data-dst="硅"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硅</font></font></trans></span></em><span><trans data-src="to O or by" data-dst="o或通过"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o或通过</font></font></trans></span><em><span><trans data-src="demotion" data-dst="降级"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">降级</font></font></trans></span></em><span><trans data-src=", i.e. by adding" data-dst="，即增加"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即增加</font></font></trans></span><em><span><trans data-src="sj" data-dst="SJ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></trans></span></em><span><trans data-src="≺" data-dst="γ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">γ</font></font></trans></span><em><span><trans data-src="sk" data-dst="SK"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SK</font></font></trans></span></em><span><trans data-src="to O. If the planner uses lifted actions, i.e. if it allows action instances with variables in their parameter lists, a threat can also possibly be resolved by" data-dst="如果规划人员使用提升的动作，即如果允许在其参数列表中具有变量的动作实例，则威胁也可能通过"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果规划人员使用提升的动作，即如果允许在其参数列表中具有变量的动作实例，则威胁也可能通过</font></font></trans></span><em><span><trans data-src="separation" data-dst="分离"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分离</font></font></trans></span></em><span><trans data-src=", that is by adding binding constraints such that" data-dst="，就是添加绑定约束，这样"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，就是添加绑定约束，这样</font></font></trans></span><em><span><trans data-src="p" data-dst="磷"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">磷</font></font></trans></span></em><span><trans data-src="and ¬" data-dst="和"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font></trans></span><em><span><trans data-src="p" data-dst="磷"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">磷</font></font></trans></span></em><span><trans data-src="cannot be unified. The way a planner navigates through plan space, i.e. the strategy it employs to chose the plans to refine and the flaws to remove determines the efficiency of the planner." data-dst="不能统一。规划人员通过计划空间的方式，即它采用的策略来选择计划细化和删除缺陷决定了规划师的效率。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能统一。规划人员通过计划空间的方式，即它采用的策略来选择计划细化和删除缺陷决定了规划师的效率。</font></font></trans></span></p><p><span><trans data-src="The inception of partially ordered planning in 1975 with NOAH (Sacerdoti, ) sparked research and development activities during nearly three decades. In 1977, the NONLIN system (Tate, 1977) was presented, which introduced the concept of causal links. A formal account of partial order planning was given in (Chapman, 1987), which presented the TWEAK system, which could handle conjunctive and disjunctive preconditions as well as conjunctive effects. (Chapman, 1987) also provides proofs of TWEAKS soundness and completeness, whereby the latter is given using the" data-dst="在1975与NOAH（SaCaldodoi）的部分计划的制定中，在近三年中引发了研究和开发活动。在1977，提出了非林系统（TATE，1977），引入因果链接的概念。在Chapman（1987）中给出了部分顺序规划的一个形式化的描述，它给出了TWMID系统，它可以处理连接和析取的先决条件以及连接效应。（Chapman，1987）还提供了调整稳健性和完备性的证明，其中后者使用"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在查普曼（1987年）中，在1975年与NOAH（SaCaldodoi）的部分计划的制定中，在近三年中引发了研究和开发活动。在1977年，提出了非林系统（TATE，1977）， ）中指定了部分顺序规划的一个形式化的描述，它称为了TWMID系统，它可以处理连接和析取的先决条件以及连接效应。（Chapman，1987）还提供了调整稳健性和完备性的调整的证明，其中其余使用</font></font></trans></span><em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模态真值准则</font></font></span></em><span><trans data-src="(MTC) to explicitly check that all the safe ground linearizations correspond to solutions. More recent planners, however, depend on" data-dst="（MTC）明确地检查所有的安全接地线性对应于解决方案。然而，最近的规划者们则依赖于"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（MTC）明确地检查所有的安全接地线性对应于解决方案。然而，最近的规划者们则依赖于</font></font></trans></span><em><span><trans data-src="protection strategies" data-dst="保护策略"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保护策略</font></font></trans></span></em><span><trans data-src="and" data-dst="和"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font></trans></span><em><span><trans data-src="conflict resolution" data-dst="冲突解决"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">冲突解决</font></font></trans></span></em><span><trans data-src="to indirectly guarantee the safety and necessary correctness of the solution: SNLP (McAllester and Rosenblitt, 1991) introduces the notion of threats and safety conditions, and UCPOP (Penberthy and Weld, 1992) extends the complexity of domain and problem descriptions to actions that have conditional effects and universally quantified preconditions and effects and universally quantified goals. Much work has followed to scale up SNLP and UCPOP, most importantly involving heuristics for efficient flaw selection which was improved in (Peot and Smith, 1993; Williamson and Hanks, 1996; Schubert and Gerevini, 1995; Pollack et al., 1997). Despite those gradual improvements, partial order planning was outperformed by the new Planning Graph-, SAT- and heuristic state space planners which have emerged in the second half of the 1990ies." data-dst="为了间接保证解决方案的安全性和必要的正确性：SNLP（McAllester和RoShanBLITT，1991）引入威胁和安全条件的概念，UCPOP（彭伯西和CURE，1992）将域和问题描述的复杂性扩展到具有条件效应和普遍量化的前提和效果以及普遍量化的目标的动作。许多工作已经跟进，以扩大SNLP和UCPUP，最重要的是涉及启发式的有效缺陷选择，改进了（Poot和史米斯，1993；威廉姆森和Hanks，1996；舒伯特和Gerevini，1995；波拉克等，1997）。尽管这些渐进的改进，部分顺序规划优于新计划图，SAT和启发式状态空间规划者，已经出现在1990年下半年。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了间接保证解决方案的安全性和必要的正确性：SNLP（McAllester和RoShanBLITT，1991）约会威胁和安全条件的概念，UCPOP（彭伯西和CURE，1992）将域和问题描述为复杂性扩展到具有条件许多工作已经跟进，以扩大SNLP和UCPUP，最重要的是涉及启发式的有效缺陷选择，改进了（Poot和史米斯，1993年）。 ；威廉姆森和汉克斯，1996；舒伯特和杰里维尼，1995；波拉克等，1997）。这些这些渐进的改进，部分按顺序规划新计划图，SAT和启发式状态空间规划者，已经出现在1990年下半年。</font></font></trans></span></p><p><span><trans data-src="In recent years (since around 2001) several promising attempts have been carried out to reclaim some of the repudation of POCL planning: in (Nguyen and Kambhampati, 2001) it was noted that the techniques responsible for the efficiency of Graphplan and heuristic state planners can be adapted to dramatically improve the efficiency of partial order planning. (Nguyen and Kambhampati, 2001) introduce RePOP, a POP implementation that incorporates several enhancements: it uses a Planning Graph to compute an estimation of the cost of achieving a set of (sub-) goals. Further, it uses a novel technique of handling unsafe links: An unsafe link" data-dst="近年来（自2001以来）已经进行了一些有前途的尝试来收回一些PoCL规划的忏悔：在（Nguyen和KAMBHAMPATI，2001）中注意到，负责图形计划和启发式状态规划的效率的技术可以适于显著地提高偏序规划的效率。（Nguyen和KAMBHAMPATI，2001）介绍了RePOP，一个POP实现，它包含了几个增强：它使用一个规划图来计算实现一组（子）目标的成本的估计。此外，它使用了一种处理不安全链接的新技术：不安全链接。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一直以来（自2001年以来）已经进行了一些有前途的尝试来替换一些PoCL规划的忏悔：在（Nguyen和KAMBHAMPATI，2001年）中注意到，负责图形计划和启发式状态规划的效率的技术可以调整（Nguyen和KAMBHAMPATI，2001）介绍了RePOP，一个POP实现，它包含了几个增强：它使用一个规划图来实现单个（子）目标的成本的估计。此外，它使用了一种处理不安全链接的新技术：不安全链接。</font></font></trans></span><img src="./空值_files/clip_image004.gif" alt="img" referrerpolicy="no-referrer"><span><trans data-src="that is in conflict with an action" data-dst="这与行动冲突。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这与行动冲突</font></font></trans></span><em><span><trans data-src="ak" data-dst="阿克"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阿克</font></font></trans></span></em><span><trans data-src="is not automatically solved by promotion or demotion, which would result in new partial plans, eventually blowing up the plan space and decreasing performance; instead, RePOP uses" data-dst="不是自动升级或降级解决，这将导致新的部分计划，最终炸毁计划空间和降低性能；相反，RePoP使用"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是自动升级或降级解决，这将导致新的部分计划，最终炸毁计划空间和降低性能；相反，RePoP使用</font></font></trans></span><em><span><trans data-src="disjunctive constraint handling" data-dst="析取约束处理"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">析取约束处理</font></font></trans></span></em><span><trans data-src=", proposed in (Kambhampati and Yang, 1996), which is to resolve the unsafe link by posting a disjunctive ordering constraint that captures the promotion and demotion possibilities, and incrementally simplifies these constraints by propagation techniques, which results in the detection of many failing plans before they get selected for refinement. Further, RePOP improves the consistency enforcement of partial order planning. POP considers the causal link" data-dst="，提出（KAMBHAMPATI和杨，1996），这是解决不安全链接通过张贴一个析取排序约束捕捉促销和降级的可能性，并逐步简化这些约束的传播技术，这导致在检测到许多失败的计划之前，他们选择精化。此外，RePoP改进了偏序规划的一致性执行。POP考虑因果链接"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，提出（KAMBHAMPATI和杨，1996），这是解决不安全链接通过放置一个析取分解约束捆绑促销和降级的问题，并逐步简化这些约束的传播技术，这导致在检测到很多失败的计划之前，他们选择精化。最终，RePoP改进了偏序规划的一致性执行。POP考虑因果链接</font></font></trans></span><em><span><trans data-src="ai" data-dst="人工智能"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人工智能</font></font></trans></span></em><span><trans data-src="→" data-dst="渐次"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渐次</font></font></trans></span><em><span><trans data-src="p aj" data-dst="P AJ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">帕杰</font></font></trans></span></em><span><trans data-src="only threatened by an action" data-dst="只受行动威胁"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只受行动威胁</font></font></trans></span><em><span><trans data-src="a" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src=", if it has an effect ¬" data-dst="如果有效果的话"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果有效果的话</font></font></trans></span><em><span><trans data-src="p" data-dst="磷"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">磷</font></font></trans></span></em><span><trans data-src=". Often" data-dst=". 经常"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">经常</font></font></trans></span><em><span><trans data-src="a" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src="might have an effect" data-dst="可能有效果"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能有效果</font></font></trans></span><em><span><trans data-src="q" data-dst="Q"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问</font></font></trans></span></em><span><trans data-src="such that no legal state can have" data-dst="没有合法的国家"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有合法的国家</font></font></trans></span><em><span><trans data-src="p" data-dst="磷"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">磷</font></font></trans></span></em><span><trans data-src="and" data-dst="和"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font></trans></span><em><span><trans data-src="q" data-dst="Q"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问</font></font></trans></span></em><span><trans data-src="true together. In order to detect such implicit conflicts, information about reachable states is required. Again, a Planning Graph is employed to generate this information. The reachable states are then contrasted with pre- and post-" data-dst="真的在一起。为了检测这种隐式冲突，需要关于可达状态的信息。再次，使用规划图来生成该信息。然后将可达状态与前后进行对比。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真的在一起。为了检测这种隐式冲突，需要关于可达状态的信息。再次，使用规划图生成该信息。然后将可达状态与前后进行对比。</font></font></trans></span><em><span><trans data-src="cutsets" data-dst="割集"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">割集</font></font></trans></span></em><span><trans data-src=", which are unions of pre- and post-conditions derived from the chains of plan steps defined by causal link and ordering constraints. If these cutsets violate the properties of the reachable states, i.e. if a mutex is detected (cf. Sect. 4.2), then the partial plan is discarded. The result of these enhancements is that RePOP is able to demonstrate equal and sometimes better performance than the CSP and state based planners it has borrowed the powerful conflict detection techniques from. At the same time, it is able to generate more compact solutions in many cases and it retained the openness and flexibility of the POP framework, which is considered one of the advantages of that framework (Smith et al., 2000)." data-dst="这是由因果链接和排序约束所定义的计划步骤链所衍生的前后条件的联合。如果这些割集违反了可达状态的性质，即如果检测到互斥（参见SeCT）。4.2）然后放弃部分计划。这些增强的结果是，RePoP能够表现出比CSP和基于状态的规划者平等和有时更好的性能，它借用了强大的冲突检测技术。同时，它能够在许多情况下生成更紧凑的解决方案，并且保留POP框架的开放性和灵活性，这被认为是该框架的优点之一（史米斯等人，2000）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果这些割集违反了可达状态的性质，即如果检测到互斥（视为SeCT）。4.2）然后放弃部分计划。这些增强的结果是，RePoP能表现出比CSP和基于状态的规划者平等和有时更好的性能，它借用了强大的冲突检测技术。同时，它能够在许多情况下生成更适合的解决方案方案，并且保留POP框架的开放性和合并，这被认为是该框架的优点之一（史米斯等人，2000）。</font></font></trans></span></p><p><span><trans data-src="Another recent advancement of partially ordered planning was achieved by the Versatile Heuristic Partial Order Planner (VHPOP), presented in (Younes and Simmons, 2002; Younes and Simmons, 2003), which competed successfully at the 3rd International Planning Competition IPC-3." data-dst="偏序规划的另一个最新进展是通过通用启发式偏序规划（VHPOP）实现的，在（Yunes和西蒙斯，2002；Yunes and西蒙斯，2003）中提出，这在第三国际规划竞赛IPC-3中成功地进行了竞争。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偏序规划的另一个最新进展是通过通用启发式偏序规划（VHPOP）实现的，在（Yunes和西蒙斯，2002； Yunes和西蒙斯，2003）中提出，这在第三国际规划竞赛3中成功地进行了竞争。</font></font></trans></span></p><p><span><trans data-src="Like SNLP and UCPOP, VHPOP uses the" data-dst="像SNLP和UCPOP一样，VHPOP使用"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像SNLP和UCPOP一样，VHPOP使用</font></font></trans></span><em><span><trans data-src="A" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src="∗ algorithm (Hart et al., 1968) to search through the plan space. The" data-dst="算法（HART等人，1968）通过规划空间搜索。这个"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法（HART等人，1968）通过规划空间搜索。这个</font></font></trans></span><em><span><trans data-src="A" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src="∗ algorithm requires a search node evaluation function" data-dst="算法要求搜索节点的评价函数"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法要求搜索例程的评价函数</font></font></trans></span><em><span><trans data-src="f" data-dst="f"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="n" data-dst="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></trans></span></em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）=</font></font></span><em><span><trans data-src="g" data-dst="G"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="n" data-dst="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></trans></span></em><span><trans data-src=") +" data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span><em><span><trans data-src="h" data-dst="H"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="n" data-dst="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></trans></span></em><span><trans data-src="), where" data-dst="页：1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">页：1</font></font></trans></span><em><span><trans data-src="g" data-dst="G"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="n" data-dst="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></trans></span></em><span><trans data-src=") is the cost of getting to" data-dst="是到达的成本吗？"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是到达的成本吗？</font></font></trans></span><em><span><trans data-src="n" data-dst="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></trans></span></em><span><trans data-src="from the start node (i.e. the initial plan) and" data-dst="从开始节点（即初始计划）和"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从开始摘要（即初始计划）和</font></font></trans></span><em><span><trans data-src="h" data-dst="H"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="n" data-dst="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></trans></span></em><span><trans data-src=") is the estimated remaining cost of reaching the goal node (i.e. the complete plan). To encourage search for minimal plans, the cost of a plan is the number of actions in it; while SNLP and UCPOP use the number of open flaws F(" data-dst="是到达目标节点的估计剩余成本（即完整计划）。为了鼓励搜索最小的计划，计划的成本是在其中的行动数量；而SNLP和UCPP使用开放缺陷F的数目（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是达到目标目标的估计剩余成本（即完整计划）。为了鼓励搜索最小的计划，计划的成本是在其中的行动数量；而SNLP和UCPP使用开放性缺陷的数量（</font></font></trans></span><em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">π</font></font></span></em><font style="vertical-align: inherit;"><em><span><font style="vertical-align: inherit;"> π</font></span></em></font><span><trans data-src=") of a plan to give an estimation of" data-dst="）一个估计的计划"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）一个估计的计划</font></font></trans></span><em><span><trans data-src="h" data-dst="H"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span></span></em><span><trans data-src="), the VHPOP planner adapts the additive heuristic" data-dst="），VHPOP规划师采用了附加启发式算法。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），VHPOP规划师采用了附加启发式算法。</font></font></trans></span><em><span><trans data-src="hadd" data-dst="哈德"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈德</font></font></trans></span></em><span><trans data-src="of HSP (cf. Sect. 4.1) to achieve a better informed heuristic, which takes into account positive interactions between goals. Like the state space planner FF, VHPOP utilizes a relaxed Planning Graph to extract the data for" data-dst="HSP（CFS）。4.1）实现更明智的启发式，其中考虑到目标之间的良性互动。与状态空间规划者FF一样，VHPOP利用松弛规划图来提取数据。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HSP（CFS）。4.1）实现更明智的启发式，其中考虑到目标之间的良性互动。与状态空间规划者FF一样，VHPOP利用替代规划图来提取数据。</font></font></trans></span><em><span><trans data-src="hadd" data-dst="哈德"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈德</font></font></trans></span></em><span><trans data-src="." data-dst="."><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></trans></span></p><p><span><trans data-src="While these heuristics inform" data-dst="虽然这些启发式通知"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虽然这些启发式通知</font></font></trans></span><em><span><trans data-src="plan selection" data-dst="方案选择"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方案选择</font></font></trans></span></em><span><trans data-src=", VHPOP also provides powerful heuristics for" data-dst="VHPOP还提供了强大的启发式算法。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VHPOP还提供了强大的启发式算法。</font></font></trans></span><em><span><trans data-src="flaw selection" data-dst="缺陷选择"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺陷选择</font></font></trans></span></em><span><trans data-src=": Besides implementations of existing strategies such as DUnf and DSep (Peot and Smith, 1993), LCFR (Joslin and Pollack, 1994), and ZLFIO (Schubert and Gerevini, 1995), VHPOP introduces novel flaw selection strategies:" data-dst="除了现有策略的实施，如Dunf和DSep（Poot和史米斯，1993），LCFR（Joslin和波拉克，1994），ZLFIO（舒伯特和Gerevini，1995），VHPOP引入了新的缺陷选择策略："><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了现有策略的实施，如Dunf和DSep（Poot和史米斯，1993），LCFR（Joslin和波拉克，1994），ZLFIO（舒伯特和Gerevini，1995），VHPOP上了新的缺陷选择策略：</font></font></trans></span><em><span><trans data-src="Static-first" data-dst="静态优先"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静态优先</font></font></trans></span></em><span><trans data-src="deals efficiently with static open conditions," data-dst="有效地处理静态开放条件，"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有效地处理静态开放条件，</font></font></trans></span><em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LCFF-Loc</font></font></span></em><span><trans data-src="allows for local flaw selection, which makes the planner less sensitive to precondition order in operator specifications, and several conflict-driven flaw section strategies are introduced which build on the assumption that those open conditions which would be threatened when closed, should be treated with higher priority (Younes and Simmons, 2003)." data-dst="允许局部缺陷选择，这使得规划师对操作者规范中的预条件次序不太敏感，并且引入了几个冲突驱动的缺陷区段策略，这些假设是建立在那些被关闭时受到威胁的开放条件下，应该以更高的优先级来处理（尤尼斯和西蒙斯，2003）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许局部缺陷选择，这使规划师对操作者规范中的预条件条件不太敏感，并且约会了几个冲突驱动的缺陷分段策略，这些假设是建立在那些被关闭时受到威胁的开放条件下，应该以更高的优先级来处理（尤尼斯和西蒙斯，2003）。</font></font></trans></span></p><p><span><trans data-src="Furthermore, VHPOP extends the POP framework to handle durative actions as specified by PDDL 2.1 level 3, attaching temporal annotations to open conditions which tell the planner at which time step the condition must hold." data-dst="此外，VHPOP扩展了POP框架来处理PDDL 2.1级3所指定的持续性动作，并将时间注释附加到开放条件，该条件告诉规划师该条件必须保持的时间步长。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，VHPOP扩展了POP框架来处理PDDL 2.1级3所指定的持续性动作，同时时间注释附加到开放条件，该条件告诉规划师该条件必须保持的时间步长。</font></font></trans></span></p><h3><a name="4.4---------planning-as-satisfiability" class="md-header-anchor"></a><span><trans data-src="4.4         Planning as Satisfiability" data-dst="4.4规划作为可满足性"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4规划作为可满足性</font></font></trans></span></h3><p><span><trans data-src="The idea behind the" data-dst="背后的想法"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背后的想法</font></font></trans></span><em><span><trans data-src="planning as satisfiability" data-dst="规划作为可满足性"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规划作为可满足性</font></font></trans></span></em><span><trans data-src="-approach is to express the planning problem as a reasoning problem for which powerful problem solving algorithms exist." data-dst="方法是将规划问题表示为一个推理问题，其中存在强大的问题求解算法。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法是将规划问题表示为一个推理问题，其中存在强大的问题替代算法。</font></font></trans></span></p><h4><a name="4.4.1--------planning-as-propositional-satisfiability" class="md-header-anchor"></a><span><trans data-src="4.4.1        Planning as Propositional Satisfiability" data-dst="4.4.1作为命题可满足性的规划"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4.1作为命题可满足性的规划</font></font></trans></span></h4><p><span><trans data-src="The logical approach to planning has traditionally been" data-dst="规划的逻辑方法历来是"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规划的逻辑方法历来是</font></font></trans></span><em><span><trans data-src="deduction" data-dst="演绎"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演绎</font></font></trans></span></em><span><trans data-src="(e.g. (Green, 1969; McCarthy and Hayes, 1987; Rosenschein, 1990)), that is, to find a proof that the initial conditions together with the domain axioms (which define the semantics of the operators) and some sequence of actions imply the goal situation (expressed as logical formula). The proof for such a theorem is any valid instantiation of the logical theorem, and the action sequences can be extracted from such an instantiation." data-dst="（例如，Green，1969；麦卡锡和海因斯，1987；RoSoxein，1990），也就是说，找到一个证明，初始条件与域公理（定义操作符的语义）和一些动作序列意味着目标情况（表示为逻辑公式）。这种定理的证明是逻辑定理的任何有效实例化，并且可以从这样的实例化中提取动作序列。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（例如，Green，1969；麦卡锡和海因斯，1987； RoSoxein，1990），从而，找到一个证明，初始条件与域公理（定义操作符的语义）和一些动作序列意味着目标情况（表示为逻辑公式）。这种定理的证明是逻辑定理的任何有效实例化，并且可以从这样的实例化中提取动作序列。</font></font></trans></span></p><p><span><trans data-src="However, in (Kautz and Selman, 1992) planning through" data-dst="然而，在（考茨和塞尔曼，1992）规划通过"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然而，在（考茨和塞尔曼，1992）规划通过</font></font></trans></span><em><span><trans data-src="satisfiability" data-dst="可满足性"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可满足性</font></font></trans></span></em><span><trans data-src="checking was presented. In that approach, a planning problem is not a theorem to be proved, instead it is formulated as a set of axioms with the property that" data-dst="检查。在这种方法中，规划问题不是一个有待证明的定理，相反，它被设计成具有属性的一组公理。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查。在这种方法中，规划问题不是一个有待证明的定理，相反，它被设计成具有属性的一组公理。</font></font></trans></span><em><span><trans data-src="any" data-dst="任何"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任何</font></font></trans></span></em><span><trans data-src="model of the axioms correspond to a valid plan. This property is achieved by crafting axioms that rule out unintended (anomalous) models, for instance axioms are needed to explicitly rule out the possibility of executing an action while its precondition is not fulfilled." data-dst="公理的模型对应于一个有效的计划。此属性是通过编写排除非预期（异常）模型的公理来实现的，例如公理需要明确地排除在不满足其前提条件的情况下执行动作的可能性。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公理的模型对应于一个有效的计划。此属性是通过编写排除非预期（异常）模型的公理来实现的，例如公理需要明确地排除在不满足其条件的情况下执行动作的可能性。</font></font></trans></span></p><p><span><trans data-src="Further, the axioms do not contain quantification or terms, and all predicates have a trailing argument that takes a time step. For instance[" data-dst="此外，公理不包含量化或术语，并且所有谓词都有一个需要时间步长的尾随参数。例如"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，公理不包含量化或术语，并且所有谓词都有一个需要时间步长的尾随参数。例如</font></font></trans></span><a href="https://ziyanliupb.github.io/#"><span><trans data-src="6" data-dst="六"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">六</font></font></trans></span><span><trans data-src="]" data-dst="]"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]</font></font></trans></span></a><span><trans data-src=", in the well known blocks world (Gupta and Nau, 1992), the planning problem of achieving" data-dst="在著名的街区世界（Gupta和NAU，1992）中，实现规划问题。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在著名的街区世界（Gupta和NAU，1992）中，实现规划问题。</font></font></trans></span><em><span><trans data-src="on" data-dst="打开（放）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：（放）</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="B,A" data-dst="B"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乙</font></font></trans></span></em><span><trans data-src=") from an initial situation" data-dst="）从最初的情况"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）从最初的情况</font></font></trans></span><em><span><trans data-src="on" data-dst="打开（放）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：（放）</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="A,B" data-dst="甲、乙"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">甲，乙</font></font></trans></span></em><span><trans data-src=") ∧" data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span><em><span><trans data-src="on" data-dst="打开（放）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：（放）</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="B,Table" data-dst="B表"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B表</font></font></trans></span></em><span><trans data-src=") would be expressed as:" data-dst="）将表示为："><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）将表示为：</font></font></trans></span></p><p><em><span><trans data-src="on" data-dst="打开（放）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：（放）</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="A,B," data-dst="甲、乙、"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">甲，乙，</font></font></trans></span></em><span><trans data-src="1) ∧" data-dst="1）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1）</font></font></trans></span><em><span><trans data-src="on" data-dst="打开（放）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：（放）</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="B,Table," data-dst="B，表，"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B，表，</font></font></trans></span></em><span><trans data-src="1) ∧" data-dst="1）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1）</font></font></trans></span><em><span><trans data-src="clear" data-dst="清空"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清空</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="A," data-dst="A"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一种</font></font></trans></span></em><span><trans data-src="1) ∧" data-dst="1）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1）</font></font></trans></span><em><span><trans data-src="on" data-dst="打开（放）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：（放）</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="B,A," data-dst="B，A，"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B，A，</font></font></trans></span></em><span><trans data-src="3)" data-dst="3）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3）</font></font></trans></span></p><p><span><trans data-src="Further, the semantics (preconditions and effects) of the" data-dst="此外，语义（前提和效果）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，语义（倾向于和效果）</font></font></trans></span><em><span><trans data-src="move" data-dst="移动"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动</font></font></trans></span></em><span><trans data-src="operator would be formalized as:" data-dst="操作员将被正式化为："><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作员将被正式化为：</font></font></trans></span></p><p><span><trans data-src="∀" data-dst="γ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">γ</font></font></trans></span><em><span><trans data-src="x,y,z,i.move" data-dst="x，y，z，i移动"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x，y，z，i移动</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="x,y,z,i" data-dst="x，y，z，i"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x，y，z，i</font></font></trans></span></em><span><trans data-src=") ⊃ (" data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span><em><span><trans data-src="clear" data-dst="清空"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清空</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="x,i" data-dst="X，I"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X，I</font></font></trans></span></em><span><trans data-src=") ∧" data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span><em><span><trans data-src="clear" data-dst="清空"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清空</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="z,i" data-dst="我是"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我是</font></font></trans></span></em><span><trans data-src=") ∧" data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span><em><span><trans data-src="on" data-dst="打开（放）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：（放）</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="x,y,i" data-dst="x，y，i"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x，y，i</font></font></trans></span></em><span><trans data-src="))" data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span></p><p><span><trans data-src="Additional axioms are needed to make sure that exactly one action is taken at one time step. In this example, the only model that satisfies the axiomatized planning problem is:" data-dst="需要额外的公理，以确保在一个时间步采取一个精确的动作。在这个例子中，唯一满足公理化规划问题的模型是："><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要额外的公理，以确保在一个时间步采取一个精确的动作。在这个例子中，唯一满足公理化规划问题的模型是：</font></font></trans></span></p><p><span><trans data-src="{" data-dst="{"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{</font></font></trans></span><em><span><trans data-src="move" data-dst="移动"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="A,B,Table," data-dst="A，B，表，"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A，B，表，</font></font></trans></span></em><span><trans data-src="1)" data-dst="1）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1）</font></font></trans></span><em><span><trans data-src=",move" data-dst="移动"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="B,Table,A," data-dst="B，表，A，"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B，表，A，</font></font></trans></span></em><span><trans data-src="2)}" data-dst="2）}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2）}</font></font></trans></span></p><p><span><trans data-src="which is the intended model and which can serve as a plan for an agent. The models can be constructed using satisfiability decision procedures such as the Davis-Putnam procedure or stochastic procedures such as GSAT (Selman et al., 1992); another example is WalkSAT, also called WSAT (Selman et al., 1993)." data-dst="这是预期的模型，它可以作为一个代理的计划。该模型可以使用可满足性决策过程，如Davis Putnam过程或随机过程，如GSAT（SELMAN等，1992），另一个例子是WalkSAT，也称为WSAT（SELMAN等，1993）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是预期的模型，它可以作为一个代理的计划。该模型可以使用可满足性决策过程，如Davis Putnam过程或随机过程，如GSAT（SELMAN等，1992），另一个例子是WalkSAT，也称为WSAT（SELMAN等，1993）。</font></font></trans></span></p><p><span><trans data-src="This approach to planning turned out to be highly competitive (Kautz and Selman, 1996). Planning procedures based on this techniques are Satplan (Kautz and Selman, 1992) and the successor Blackbox (Kautz and Selman, 1998a) which combines Satplan with ideas from Graphplan. Both systems competed well in the international planning competitions." data-dst="这种方法的规划结果是非常有竞争力的（考茨和塞尔曼，1996）。基于这一技术的规划程序是Satplan（考茨和塞尔曼，1992）和继任者黑匣子（考茨和Selman，1998年A），它结合SATPLAY和图形计划的想法。这两个系统在国际规划竞赛中都有很好的竞争。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种方法的规划结果是非常有竞争力的（考茨和塞尔曼，1996）。基于这一技术的规划程序是Satplan（考茨和塞尔曼，1992）和继任者黑匣子（考茨和Selman，1998年A），它结合了SATPLAY和图形计划的想法。这两个系统在国际规划竞赛中都有很好的竞争。</font></font></trans></span></p><p><span><trans data-src="A similar approach is taken by the LGP system (Gerevini and Serina, 2002) and its successor LGP-td (Gerevini et al., 2004). Both are based on WalkSAT, but incorporate a best-first search algorithm and use a Planning Graph for search heuristics." data-dst="LGP系统（Gerevini和Serina，2002）和它的继任者LGP TD（Gerevini等人，2004）采取了类似的方法。两者都是基于WalkSAT，但结合了最佳的第一搜索算法，并使用规划图搜索启发式。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LGP系统（Gerevini和Serina，2002）和它的继任者LGP TD（Gerevini等人，2004）采用了类似的方法。它们都是基于WalkSAT，但结合了最佳的第一搜索算法，并使用规划图搜索启发式。</font></font></trans></span></p><p><span><trans data-src="Beside the good performance, SAT based planning has another advantage: since states are modeled explicitly in this framework (the trailing arguments of the atoms), it is easy to formulate requirements on states, as discussed in (Huang et al., 1999; Kautz and Selman, 1998b). This, in turn is useful for expressing the complex goals discussed in Sect. 3.3." data-dst="除了良好的性能外，基于SAT的规划还有另一个优点：由于状态在该框架中被明确地建模（原子的尾随参数），如黄等人，1999；Kutz和Selman，1998年B所讨论的，很容易对状态制定要求。这反过来又有助于表达宗派讨论的复杂目标。3.3。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了良好的性能外，基于SAT的规划还有另一个优点：由于状态在该框架中被明确地建模（原子的尾随参数），如黄等人，1999； Kutz和Selman，1998年的，很容易对状态制定要求。这反过来又有助于表达宗派讨论的复杂目标。3.3。</font></font></trans></span></p><h4><a name="4.4.2--------planning-as-description-logic-satisfiability" class="md-header-anchor"></a><span><trans data-src="4.4.2        Planning as Description Logic Satisfiability" data-dst="4.4.2规划作为描述逻辑可满足性"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4.2规划作为描述逻辑可满足性</font></font></trans></span></h4><p><span><trans data-src="Another approach that presents the planning task as a logical satisfiability problem is presented in (Berardi et al., 2003). More precisely, the article concentrates on the problem of automatic Web service composition. In this approach the “target logic” is not Propositional Logic, but the Description Logic ALU." data-dst="另一种将规划任务作为逻辑可满足性问题的方法出现在（贝拉尔迪等人，2003）中。更准确地说，本文集中讨论了Web服务自动组合问题。在这种方法中，“目标逻辑”不是命题逻辑，而是描述逻辑ALU。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一种将规划任务作为逻辑可满足性问题的方法出现在（贝拉尔迪等人，2003）中。更准确地说，这里集中讨论了Web服务自动组合问题。在这种方法中，”目标逻辑”不是命题逻辑，而是描述逻辑ALU。</font></font></trans></span></p><p><span><trans data-src="The approach defines a" data-dst="该方法定义了"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该方法定义了</font></font></trans></span><em><span><trans data-src="community" data-dst="社区"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">社区</font></font></trans></span></em><span><trans data-src="of Web services, which is characterized by a common set of actions, called the alphabet of the community and a set of Web services specified in terms of the common set of actions. The interaction protocols a service offers are expressed as" data-dst="Web服务的特点是一组共同的动作，称为社区的字母表和一组基于公共动作集合指定的Web服务。服务提供的交互协议表示为"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Web服务的特点是一组共同的动作，称为社区的样式和一组基于公共动作集合指定的Web服务。服务提供的交互协议表示为</font></font></trans></span><em><span><trans data-src="execution trees" data-dst="执行树"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行树</font></font></trans></span></em><span><trans data-src=", where each node represents a possible state in the client-server interplay and each edge represents an action invoked by the client following the protocol. The Web service composition problem is now to identify an execution tree composed of the actions of the services in the community, that corresponds with a given desired execution tree." data-dst="其中，每个节点表示客户端-服务器相互作用中的可能状态，并且每个边缘表示由客户端在协议之后调用的动作。Web服务组合问题现在识别由社区中的服务的动作组成的执行树，其对应于给定的期望执行树。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中，每个收件人表示客户端-服务器交互中的可能状态，并且每个边缘表示由客户端在协议之后调用的动作。Web服务组合问题现在识别由社区中的服务的动作组成的执行树，其对应于给定的期望执行树。</font></font></trans></span></p><p><span><trans data-src="The task of constructing such a tree is reminiscent of the task of producing a model of a description logic concept to prove its satisfiability (or its unsatisfiability): to exploit this property, the Web service domain and planning problem are transformed from a situation calculus representation to ALU, and then any of the highly efficient tableau-based Description Logic reasoners (such as (Volker Haarslev, 2001; Horrocks, 1999)) can be used to generate the tree model of the satisfiability check, from which the synthesized process (if it exists) can be directly extracted." data-dst="构造这样一棵树的任务是想起产生一个描述逻辑概念的模型来证明它的可满足性（或它的不可满足性）的任务：利用这一性质，将Web服务域和规划问题从情景演算表示转换为ALU，然后任何高效的基于表格的描述逻辑推理器（如（Volker Haarslev，2001；HORRORKS，1999））可以用来生成可满足性检查的树模型，从中可以直接提取合成过程（如果存在的话）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">构造这样一棵树的任务是想起产生一个描述逻辑概念的模型来证明它的可满足性（或它的不可满足性）的任务：利用这一性质，将Web服务域和规划问题从情景演算表示出来转换为ALU，然后任何高效的基于表格的描述逻辑推理器（如（Volker Haarslev，2001； HORRORKS，1999））可以构建生成可满足性检查的树模型，从中可以直接提取合成过程（如果存在的话）。</font></font></trans></span></p><h4><a name="4.4.3--------planning-as-petri-net-reachability" class="md-header-anchor"></a><span><trans data-src="4.4.3        Planning as Petri-Net Reachability" data-dst="4.4.3作为Petri网可达性的规划"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4.3作为Petri网可达性的规划</font></font></trans></span></h4><p><span><trans data-src="Another work that starts with a situation calculus based axiomatization of the planning problem and then transforms it to fit into a well-known formal framework was presented in (Narayanan and McIlraith, 2002): This article suggests that Web service planning tasks can be carried out under the notion of" data-dst="另一项工作是从一个基于情景演算的公理化规划问题开始，然后将它转换成一个众所周知的形式化框架（纳拉亚南和McILRAITS，2002）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一项工作是从一个基于情景演算的公理化规划问题开始，然后将其转换成一个替代的形式化框架（纳拉亚南和McILRAITS，2002）。</font></font></trans></span><em><span><trans data-src="reachability analysis" data-dst="可达性分析"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可达性分析</font></font></trans></span></em><span><trans data-src="of Petri nets (Petri, 1962). The idea is to create a Petri net based on atomic Web services that represents all possible combinations of atomic operations and to specify the desired goal as a state of this Petri net (i.e. as a configuration of tokens). Standard Petri net techniques, among them satisfiability checking, can then be used to determine if this goal state is reachable. These techniques can also be used to validate whether a plan is well-formed (Narayanan and McIlraith, 2002)." data-dst="Petri网（Petri，1962）。我们的想法是创建一个基于原子Web服务的Petri网，它代表原子操作的所有可能的组合，并指定作为Petri网（即令牌配置）的状态的期望目标。标准Petri网技术，其中可满足性检查，然后可以用来确定该目标状态是否可达。这些技术也可用于验证计划是否是良好形成的（纳拉亚南和McILRITES，2002）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Petri网（Petri，1962）。我们的想法是创建一个基于原子Web服务的Petri网，它代表原子操作的所有可能的组合，并指定为Petri网（即令牌配置）的状态的期望目标。这些技术也可以用于验证计划是否是良好形成的（纳拉亚南和McILRITES，2002）。</font></font></trans></span></p><h3><a name="4.5---------planning-as-logic-programming" class="md-header-anchor"></a><span><trans data-src="4.5         Planning as Logic Programming" data-dst="4.5规划作为逻辑程序设计"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5规划作为逻辑程序设计</font></font></trans></span></h3><p><span><trans data-src="Another approach that proposes a way to encode the action laws of a planning domain as a logical representation that is amendable to formal reasoning methods is the Planning as" data-dst="另一种提出一种将规划域的动作规律编码为可用于形式推理方法的逻辑表示的方法是规划。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一种提出一种将规划域的动作规律编码为可用于形式推理方法的逻辑表示的方法是规划。</font></font></trans></span><em><span><trans data-src="Logic Programming" data-dst="逻辑程序设计"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑程序设计</font></font></trans></span></em><span><trans data-src="approach." data-dst="方法。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font></trans></span></p><p><span><trans data-src="A Logic program is composed by a set of Horn clauses of the form" data-dst="逻辑程序由一组形式的HORN子句组成。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑程序由一组形式的HORN子句组成。</font></font></trans></span><em><span><trans data-src="A" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src="←" data-dst="γ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">γ</font></font></trans></span><em><span><trans data-src="B" data-dst="乙"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乙</font></font></trans></span></em><span><trans data-src="1" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span><em><span><trans data-src=",...,Bn" data-dst="，…，BN"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，…，BN</font></font></trans></span></em><span><trans data-src=". Each such Horn clause can also be interpreted as a disjunction of literals with at most one positive literal, i.e." data-dst=". 每个这样的HOLL子句也可以被解释为文本的析取，最多为一个正文字，即"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">每个这样的HOLL子句也可以被解释为文本的析取，最多为一个正文字，即</font></font></trans></span><em><span><trans data-src="A" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src="∨¬" data-dst="γ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">γ</font></font></trans></span><em><span><trans data-src="B" data-dst="乙"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乙</font></font></trans></span></em><span><trans data-src="1 ∨" data-dst="1℃"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1℃</font></font></trans></span><em><span><trans data-src="..." data-dst="…"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">…</font></font></trans></span></em><span><trans data-src="∨¬" data-dst="γ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">γ</font></font></trans></span><em><span><trans data-src="Bn" data-dst="氮化硼"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">氮化硼</font></font></trans></span></em><span><trans data-src=". Negativity in Logic programs is usually expressed as" data-dst=". 逻辑程序中的否定性通常表示为"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">逻辑程序中的否定性通常表示为</font></font></trans></span><em><span><trans data-src="negation-as-failure" data-dst="否定作为失败"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">否定作为失败</font></font></trans></span></em><span><trans data-src="(NAF), which makes them nonmonotonic." data-dst="（nAF），这使得它们不是单调的。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（nAF），这必然它们不是单调的。</font></font></trans></span></p><p><span><trans data-src="The relation between logic programming (LP) and planning, as well as the encoding of planning problems as Logic programs is extensively studied in the literature, e.g. in (Gelfond and Lifschitz, 1993; Turner, 1997; Lifschitz, 1999)." data-dst="逻辑编程（LP）和规划之间的关系，以及作为逻辑程序的规划问题的编码在文献中被广泛研究，例如在（GelFoand和LIFSHIZ，1993；Turnter，1997；LIFSHIZ，1999）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑编程（LP）和规划之间的关系，以及作为逻辑程序的规划问题的编码在文献中被广泛研究，例如在（GelFoand和LIFSHIZ，1993； Turnter，1997； LIFSHIZ，1999）。</font></font></trans></span></p><p><span><trans data-src="While the direct application of deductive reasoning, such as Prolog’s SLD would appear self-evident, much of the progress of the Planning as LP-approach has been achieved using alternative methods, inspired by (Subrahmanian and Zaniolo, 1995). (Subrahmanian and Zaniolo, 1995) show that planning problems can be converted to Logic programs in linear time such that a given goal" data-dst="虽然演绎推理的直接应用，如Prolog的SLD将是不言而喻的，作为LP方法的规划的许多进展已经实现使用替代方法，灵感来自（SurrHaman和ZANIOLO，1995）。（SurrHaman和ZANIOLO，1995）表明规划问题可以在线性时间转换成逻辑程序，使得给定的目标。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虽然演绎推理的直接应用，如Prolog的SLD将是不言而喻的，作为LP方法的规划的许多进展已经实现使用替代方法，灵感来自（SurrHaman和ZANIOLO，1995）。（SurrHaman和ZANIOLO，1995）存在规划问题可以在线性时间转换成逻辑程序，从而给定的目标。</font></font></trans></span><em><span><trans data-src="G" data-dst="G"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></trans></span></em><span><trans data-src="is achievable in the planning domain if and only if a related goal" data-dst="在规划域中，当且仅当相关目标是可实现的"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在规划域中，当且仅当相关目标是可实现的</font></font></trans></span><em><span><trans data-src="G" data-dst="G"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></trans></span></em><span><trans data-src="∗ is true in some" data-dst="在某些方面是正确的。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在某些方面是正确的</font></font></trans></span><em><span><trans data-src="stable model" data-dst="稳定模型"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">稳定模型</font></font></trans></span></em><span><trans data-src="of the logic program obtained by the transformation; the goal" data-dst="通过变换获得的逻辑程序；目标"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过变换获得的逻辑程序；目标</font></font></trans></span><em><span><trans data-src="G" data-dst="G"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></trans></span></em><span><trans data-src="∗ can be obtained in linear time as well (Subrahmanian and Zaniolo, 1995). These stable models can be efficiently generated by computing the" data-dst="也可以在线性时间内得到（SurabHaMaNi和ZaioLo，1995）。这些稳定模型可以通过计算"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也可以在线性时序得到（SurabHaMaNi和ZaioLo，1995）。这些稳定模型可以通过计算</font></font></trans></span><em><span><trans data-src="answer sets" data-dst="答案集"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">答案集</font></font></trans></span></em><span><trans data-src="of the logic program, as implemented in tools like SMODELS (Niemelae and Simons, 1997). (Dimopoulos et al., 1997) report empirical tests of this approach, and suggest that, given a proper encoding of the Logic programs, the performance can keep up with the performance of general-purpose planning algorithms such as Graphplan or Satplan." data-dst="逻辑程序，如在SMODEM（Nimelae和Simon，1997）之类的工具中实现的。（Dimopoulos等人，1997）报告了这种方法的经验测试，并建议，给定一个正确的逻辑程序编码，性能可以跟上通用规划算法的性能，如图形计划或SATPLAY。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑程序，如在SMODEM（Nimelae和Simon，1997）之类的工具中实现的。（Dimopoulos等人，1997）报告了这种方法的经验测试，并建议，给定一个正确的逻辑程序编码，性能可以跟上通用规划算法的性能，如图形计划或SATPLAY。</font></font></trans></span></p><p><span><trans data-src="Other applications of Logic programming have been Reiter’s implementation of Golog and regression for situation calculus (Reiter, 2001). Also mentioned should be (Shanahan, 2000) which presents a Logic programming encoding of the event calculus. In the realm of Web service composition, the SWORD toolkit was presented in (Ponnekanti and Fox, 2002), which uses Prolog to reason about information providing services, whereby plans are extracted directly from the execution trace of the Prolog interpreter." data-dst="逻辑编程的其他应用是赖特实现GOOG和回归的情形演算（ReITER，2001）。还应该提到的是（单阿汉，2000），它给出了事件演算的逻辑编程编码。在Web服务组合领域，PrimeKand和Fox（2002）提出了剑工具包，它使用Prolog对信息提供服务进行推理，从而直接从Prolog解释器的执行轨迹中提取计划。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑编程的其他应用是赖特实现GOOG和回归的正确演算（ReITER，2001）。还应该提到的是（单阿汉，2000），它发出了事件演算的逻辑编程编码。在Web服务组合领域，PrimeKand和Fox（2002）提出了剑工具包，它使用Prolog对信息提供服务进行推理，从而直接从Prolog解释器的执行轨迹中提取计划。</font></font></trans></span></p><h2><a name="5-----------planning-with-control-knowledge" class="md-header-anchor"></a><span><trans data-src="5           Planning with Control Knowledge" data-dst="5控制知识规划"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5控制知识规划</font></font></trans></span></h2><p><span><trans data-src="Although the performance of many of the planners described in the last sections is quite impressive, there is a belief among many researchers, that it is necessary to provide the planing agent with domain- or task dependent control knowledge in order to achieve good performance in real world domains." data-dst="虽然在最后部分中描述的许多规划师的性能是相当令人印象深刻的，在许多研究人员中有一种信念，有必要提供规划代理与域或任务相关的控制知识，以获得良好的性能在现实世界域。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虽然在最后部分中描述的许多规划师的性能是相当令人印象深刻的，在许多研究人员中有一种信念，有必要提供规划代理与域或任务相关的控制知识，从而具有很好的性能在现实中世界域。</font></font></trans></span></p><p><span><trans data-src="In the following sections, we will briefly review planning techniques that allow to incorporate and exploit domain or task-dependent control knowledge in one way or the other." data-dst="在下面的章节中，我们将简要回顾规划技术，允许以一种或另一种方式合并和利用域或任务相关的控制知识。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在下面的章节中，我们将简要回顾规划技术，允许以一种或另一种方式合并和利用域或任务相关的控制知识。</font></font></trans></span></p><h3><a name="5.1---------hierarchical-task-network-planning" class="md-header-anchor"></a><span><trans data-src="5.1         Hierarchical Task Network Planning" data-dst="5.1层次任务网络规划"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1层次任务网络规划</font></font></trans></span></h3><p><span><trans data-src="Hierarchical Task Network (HTN) planning was first introduced in the early Abstrips (Sacerdoti, 1973) planning system, followed by NOAH and several other planners; it was given a formal semantics in (Erol et al., 1994b; Erol et al., 1994a)." data-dst="分层任务网络（HTN）计划首先引入了早期的抽象（SACRDODI，1973）计划系统，其次是诺亚和其他几个规划师；它被赋予了正式的语义（ErOL等人，1994年B；Erol等人，1994年A）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分级任务网络（HTN）计划首先约会了早期的抽象（SACRDODI，1973）计划系统，其次是诺亚和其他几个规划师；它被赋予了正式的语义（ErOL等人，1994年B； Erol等人，1994年A）。</font></font></trans></span></p><p><span><trans data-src="HTN planning provides hierarchical abstraction, a powerful strategy to deal with the complexity of large and complicated real world planning domains. Like other planning paradigms, HTN planning assumes a set of operators that achieve certain defined effects when its preconditions hold directly before its execution. However, in addition to operations (which are called" data-dst="HTN规划提供了分层抽象，一个强大的策略，以应付复杂和复杂的现实世界规划领域。与其他规划范例一样，HTN规划假设一组运算符，当其先决条件在其执行之前直接持有时，实现一定的定义效果。然而，除了操作（被称为操作）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与其他规划范例一样，HTN规划提供了分类摘要，一个强大的策略，以应付复杂和复杂的现实世界规划领域。与其他规划范例一样，HTN规划假设具有运算符，当其先决条件在其执行之前直接举行时，实现一定的定义效果。然而，除了操作（被称为操作）</font></font></trans></span><em><span><trans data-src="primitive tasks" data-dst="原始任务"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原始任务</font></font></trans></span></em><span><trans data-src="in HTN planning), HTN planning also supports a set of" data-dst="在HTN规划中，HTN规划也支持一套"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在HTN规划中，HTN规划也支持一套</font></font></trans></span><em><span><trans data-src="methods" data-dst="方法"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font></trans></span></em><span><trans data-src=", where each is a prescription for how to decompose some task into some set of subtasks. Such method descriptions represent common" data-dst="其中每一个都是一个如何将某些任务分解成一组子任务的处方。这种方法描述代表了共同点。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中每一个都是一个如何将某些任务分解成一组子任务的处方。这种方法描述代表了共同点。</font></font></trans></span><em><span><trans data-src="domain knowledge" data-dst="领域知识"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">领域知识</font></font></trans></span></em><span><trans data-src=", or if viewed from the planner’s perspective, represent" data-dst="或者，如果从规划者的角度来看，代表"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或者，如果从规划者的角度来看，代表</font></font></trans></span><em><span><trans data-src="plan fragments" data-dst="计划碎片"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计划碎片</font></font></trans></span></em><span><trans data-src="." data-dst="."><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></trans></span></p><p><span><trans data-src="According to the definition in (Erol et al., 1994b), there are three types of goals in HTN planning: (i) goal tasks, which are desired properties of the final state, just like in most other planning paradigms, (ii) the already mentioned primitive tasks, and (iii) compound tasks that denote desired changes that involve several goal tasks and primitive tasks." data-dst="根据（EOL等人，1994年B）中的定义，HTN规划中有三种类型的目标：（i）目标任务，它是最终状态的期望属性，就像在大多数其他规划范例中一样，（ii）已经提到的原始任务，和（iii）表示涉及多个目标任务和原始任务的期望变化的复合任务。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据（EOL等人，1994年B）中的定义，HTN规划中有三种类型的目标：（i）目标任务，它是最终状态的期望属性，就像在大多数其他规划范例中一样，（ii ）已经提到的原始任务，和（iii）表示涉及多个目标任务和原始任务的期望变化的复合任务。</font></font></trans></span></p><p><span><trans data-src="A variant of HTN planning which received much attention recently is" data-dst="HTN规划的一个变型近来备受关注。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTN规划的一个变型近来备受关注。</font></font></trans></span><em><span><trans data-src="ordered task decomposition" data-dst="有序任务分解"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有序任务分解</font></font></trans></span></em><span><trans data-src="planning, where the agent plans for tasks in the same order that they will be executed, which reduces the complexity of the planning problem greatly. Planners based on that principle, like SHOP (Simple Hierarchical Ordered Planner) (Nau et al., 1999) accept goals as task lists, where compound tasks may consist of compound tasks or primitive tasks; goal tasks are not supported. Hence, ordered task decomposition system do not plan to achieve a defined (declarative) goal, but rather to carry out a given (complex or primitive) task." data-dst="规划，其中代理计划的任务，在相同的顺序，他们将被执行，这大大降低了规划问题的复杂性。基于这一原理的规划者，如商店（简单分层排序规划师）（NAU等人，1999）接受目标作为任务列表，其中复合任务可以由复合任务或原始任务组成；不支持目标任务。因此，有序任务分解系统不打算实现定义的（声明的）目标，而是执行给定的（复杂的或原始的）任务。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规划，其中代理计划的任务，在相同的顺序，他们将被执行，这大大降低了规划问题的复杂性。基于这一原理的规划者，如商店（简单分层规划师）（NAU等人） ，1999）接受目标作为任务列表，其中复合任务可以由复合任务或原始任务组成；不支持目标任务。因此，有序任务分解系统不打算实现定义的（声明的）目标，而是执行给定的（复杂的或原始的）任务。</font></font></trans></span></p><p><span><trans data-src="Such a HTN based planning system decomposes the desired task into a set of sub-tasks, and these tasks into another set of sub-tasks (and so forth), until the resulting set of tasks consists only of primitive tasks, which can be executed directly by invoking atomic operations. During each round of task decomposition, it is tested whether certain given conditions are violated. The planning problem is successfully solved if the desired complex task is decomposed into a set of primitive tasks without violating any of the given conditions." data-dst="这样的基于HTN的规划系统将期望的任务分解成一组子任务，并且将这些任务分成另一组子任务（等等），直到所得到的任务集仅由原始任务组成，这些任务可以通过调用原子操作直接执行。在每一轮任务分解期间，测试是否违反了某些给定条件。如果期望的复杂任务分解成一组原始任务而不违反任何给定条件，则成功地解决了规划问题。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样的基于HTN的规划系统将期望的任务分解成一组子任务，并且将这些任务分成另一组子任务（等等），直到所得到的任务集仅由原始任务组成，这些任务可以通过调用原子操作直接执行。在每个轮任务分解期间，测试是否违反了某些给定条件。如果期望的复杂任务分解成两个原始任务而不违反任何给定条件，则成功地解决了规划问题。</font></font></trans></span></p><p><span><trans data-src="An approach of using HTN planning in the realm of Web Services was proposed in (Hendler et al., 2003), facilitating the SHOP2 system (Nau et al., 2003), which belongs to the family of" data-dst="在Hunter等人，2003）中提出了一种在Web服务领域中使用HTN规划的方法，它促进了SuS2系统（NAU等人，2003），其属于"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Hunter等人，2003）中提出了一种在Web服务领域中使用HTN规划的方法，它促进了SuS2系统（NAU等人，2003），其属于</font></font></trans></span><em><span><trans data-src="ordered task decomposition" data-dst="有序任务分解"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有序任务分解</font></font></trans></span></em><span><trans data-src="planners we described above. The papers (Hendler et al., 2003; Wu et al., 2003) present a transformation method of OWL-S processes into a hierarchical task network. OWL-S processes are, like HTN task networks, pre-defined descriptions of actions to be carried out to get a certain task done, which makes the transformation rather natural. The advantage of the approach is its ability to deal with very large problem domains; however, the need to explicitly provide the planner with a task it needs to accomplish may be seen as a disadvantage, since this requires descriptions that may not always be available in dynamic environments." data-dst="我们上面描述的规划者。论文（HeDell等人，2003；吴等人，2003）提出了OWL-S过程到层次任务网络的转换方法。OWL-S进程和HTN任务网络一样，对要执行的任务进行预先定义的动作描述，这使得转换相当自然。该方法的优点是它能够处理非常大的问题域；然而，需要明确地为规划者提供它需要完成的任务可以被看作是一个缺点，因为这需要在动态环境中不总是可用的描述。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们（上面的描述的规划者。论文（HeDell等人，2003；吴等人，2003）提出了OWL-S过程到层次任务网络的转换方法。OWL-S进程和HTN任务网络一样，对要执行的任务进行预先定义的动作描述，这导致转换相当自然。该方法的优点是它能够处理非常大的问题域；然而，需要明确地为规划者提供它需要完成的任务可以被忽略是一个缺点，因为这需要在动态环境中不总是总是的描述。</font></font></trans></span></p><h3><a name="5.2---------high-level-program-execution" class="md-header-anchor"></a><span><trans data-src="5.2         High-level Program Execution" data-dst="5.2高级程序执行"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2高级程序执行</font></font></trans></span></h3><p><span><trans data-src="In the classical approaches to planning, a plan is synthesized given a domain description and a planning goal, where the planner has to search a – usually very large – space of possibilities to identify a proper solution to the planning problem. An alternative approach is" data-dst="在经典的规划方法中，一个计划是在给定一个领域描述和一个规划目标的基础上综合的，在这个计划中，规划者必须搜索一个通常是非常大的可能性空间来确定规划问题的正确解决方案。另一种方法是"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在经典的规划方法中，一个计划是在给定一个领域描述和一个规划目标的基础上综合的，在这个计划中，规划者必须搜索一个通常是非常大的可能空间来确定规划问题的正确解决方案。另一种方法是</font></font></trans></span><em><span><trans data-src="high-level program execution" data-dst="高级程序执行"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高级程序执行</font></font></trans></span></em><span><trans data-src="; the idea behind this approach is that, instead of searching for a sequence of actions that satisfies some declarative goal, the task is to identify a sequence of actions which constitutes a" data-dst="这种方法背后的思想是，不是搜索满足某种声明性目标的动作序列，而是识别构成一个动作的序列。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种方法背后的思想是，不是搜索满足某种声明性目标的动作序列，而是识别构成一个动作的序列。</font></font></trans></span><em><span><trans data-src="legal execution" data-dst="法律执行"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">法律执行</font></font></trans></span></em><span><trans data-src="of a given high level program. As in planning, it is necessary to reason about the preconditions and effects of the domain’s operators to find out which actions can be applied in detail. If the high level program is formulated in detail and is formulated deterministically, then not much reasoning is left to be carried out; otherwise, when the programm is formulated not in detail and if it makes use of nondeterministic control constructs, then the search task begins to resemble traditional planning (Giacomo et al., 2000)." data-dst="一个给定的高级程序。在规划中，有必要对域操作符的先决条件和影响进行推理，以找出哪些操作可以被详细应用。如果详细地制定高级程序并确定性地制定，那么就不需要进行太多的推理，否则，当程序不详细制定，如果它使用非确定性控制结构，那么搜索任务就开始类似于传统的计划（GiasMo等人，2000）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个给定的高级程序。在规划中，有必要对域操作符的先决条件和影响进行推理，以发现该操作可以被详细应用。如果详细地制定高级程序并确定性地制定，那么就不需要进行太多的推理，否则，当程序不详细制定，如果它使用非确定性控制结构，那么搜索任务就开始开始传统的计划（GiasMo等人，2000）。</font></font></trans></span></p><p><span><trans data-src="The Golog (alGOL in LOGic) (Levesque et al., 1997) language is such a high-level programming language, and it is particularly designed for the specification and execution of complex actions in dynamic domains. Further, it is logic-based, which means that Golog program are amendable to formal verification procedures and Golog based planning problems can be carried out by logic tools such as theorem provers." data-dst="GOOGO（逻辑中的ALGOL）（LaveSK等人，1997）语言是这样一种高级编程语言，它特别设计用于动态域中的复杂动作的规范和执行。此外，它是基于逻辑的，这意味着GOOG程序是可修改的形式验证程序和基于GOOG的规划问题可以通过逻辑工具，如定理证明器来执行。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GOOGO（逻辑中的ALGOL）（LaveSK等人，1997）语言是这样一种高级编程语言，它特别设计为动态域中的复杂动作的规范和执行。且，它是基于逻辑的，这意味着GOOG程序是可修改的形式验证程序和基于GOOG的规划问题可以通过逻辑工具，如定理证明器来执行。</font></font></trans></span></p><p><span><trans data-src="Golog is based on the situation calculus (cf. Sect. 3.1), which was introduced by (McCarthy, 1963) and since then is often used as a means for providing a formal account of dynamic systems. While early treatments of the situation calculus identify situations with states, i.e. a description of the universe at an instant of time (McCarthy and Hayes, 1969), more recent formal treatment (Levesque et al., 1998; Pirri and Reiter, 1999) of the situation calculus identifies situations with world histories. All changes to the world are results of named actions. A situation is a possible world history, resulting from a sequence of actions, and it is expressed as a first order term. The constant" data-dst="GOOGO是基于情境演算的。3.1），它是由（麦卡锡，1963）引入的，此后常常被用作提供动态系统的正式帐户的手段。虽然情况演算的早期处理识别状态的状态，即在瞬间的宇宙描述（麦卡锡和海因斯，1969），更近期的正式治疗（莱维斯克等人，1998；Pirri和赖特，1999）的情况演算确定的情况与世界历史。世界的所有变化都是命名行动的结果。情境是一个可能的世界历史，是由一系列动作产生的，它被表达为一阶项。常数"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GOOGO是基于情境演算的。3.1），它是由（麦卡锡，1963）约会的，此后常常被采用提供动态系统的正式帐户的手段。虽然情况演算的早期处理识别状态的状态，即在瞬间的宇宙描述（麦卡锡和海因斯，1969），更近期的正式治疗（莱维斯克等人，1998； Pirri和赖特，1999）的情况演算确定的情况与世界历史。世界的所有变化都是命名行动的结果。情境是一个可能的世界历史，是由串联动作产生的，它被表达为一阶项。常数</font></font></trans></span><em><span><trans data-src="S" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="0 denotes the" data-dst="0表示"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0表示</font></font></trans></span><em><span><trans data-src="initial situation" data-dst="初始情况"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始情况</font></font></trans></span></em><span><trans data-src=", i.e. the empty sequence of actions. The function" data-dst="Distr.函数"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distr。函数</font></font></trans></span><em><span><trans data-src="do" data-dst="做"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> α，s</font></font></span></em><font style="vertical-align: inherit;"><em><span><font style="vertical-align: inherit;"> α而</font></span></em></font><span><trans data-src=") denotes the situation that results from executing action" data-dst="表示执行动作所导致的情况。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示执行动作所导致的情况。</font></font></trans></span><em><span></span></em><span><trans data-src="in situation" data-dst="在形势中"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在官员中</font></font></trans></span><em><span><trans data-src="s" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src=". Actions are written as functions and may be parameterized. For example, the function" data-dst=". 操作是作为函数编写的，并且可以被参数化。例如，函数"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">操作是作为函数编写的，并且可以被参数化。例如，函数</font></font></trans></span><em><span><trans data-src="paint" data-dst="油漆"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">油漆</font></font></trans></span></em><span><trans data-src="(?" data-dst="？"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font></trans></span><em><span><trans data-src="o," data-dst="哦，"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哦，</font></font></trans></span></em><span><trans data-src="?" data-dst="？"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font></trans></span><em><span><trans data-src="c" data-dst="C"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></trans></span></em><span><trans data-src=") might stand for painting an object ?" data-dst="可能代表画一个物体吗？"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能代表画一个物体吗？</font></font></trans></span><em><span><trans data-src="o" data-dst="o"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ø</font></font></trans></span></em><span><trans data-src="with color ?" data-dst="颜色？"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">颜色？</font></font></trans></span><em><span><trans data-src="c" data-dst="C"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></trans></span></em><span><trans data-src=", in which case" data-dst="，在这种情况下"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在这种情况下</font></font></trans></span><em><span><trans data-src="do" data-dst="做"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="paint" data-dst="油漆"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">油漆</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="Door,Red" data-dst="红门"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">红门</font></font></trans></span></em><span><trans data-src=")" data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span><em><span><trans data-src=",s" data-dst="的S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的S</font></font></trans></span></em><span><trans data-src=") would denote the situation resulting from painting the" data-dst="会说明绘画造成的情况。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会说明绘画造成的情况。</font></font></trans></span><em><span><trans data-src="Door" data-dst="门"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">门</font></font></trans></span></em><span><trans data-src="with red color. The expression" data-dst="红色的。表达式"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">红色的。表达式</font></font></trans></span><em><span><trans data-src="do" data-dst="做"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="putDown" data-dst="推倒"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推倒</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="Red" data-dst="红色"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">红色</font></font></trans></span></em><span><trans data-src=")" data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span><em><span><trans data-src=",do" data-dst="做"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="paint" data-dst="油漆"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">油漆</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="Door,Red" data-dst="红门"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">红门</font></font></trans></span></em><span><trans data-src=")" data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span><em><span><trans data-src=",do" data-dst="做"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="pickUp" data-dst="拾音器"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拾音器</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="Red" data-dst="红色"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">红色</font></font></trans></span></em><span><trans data-src=")" data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span><em><span><trans data-src=",S" data-dst="的S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的S</font></font></trans></span></em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0）））表示</font><font style="vertical-align: inherit;">执行</font></font></span><em><span><trans data-src="pickUp(Red)" data-dst="拾取（红色）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拾取（红色）</font></font></trans></span></em><span><trans data-src="in situation" data-dst="在形势中"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在官员中</font></font></trans></span><em><span><trans data-src="S" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="0, then executing" data-dst="0，然后执行"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0，然后执行</font></font></trans></span><em><span><trans data-src="paint(Door, Red)" data-dst="油漆（门，红色）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">油漆（门，红色）</font></font></trans></span></em><span><trans data-src=", followed by" data-dst="紧随其后"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">紧随其后</font></font></trans></span><em><span><trans data-src="putDown(Red)" data-dst="倒下（红色）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">倒下（红色）</font></font></trans></span></em><span><trans data-src="." data-dst="."><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></trans></span></p><p><span><trans data-src="Golog builds on top of the situation calculus by providing a set of extralogical constructs which serve as" data-dst="GOROG通过提供一组外层结构来构建情境演算之上。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GOROG通过提供一个外层结构来合并情境演算之上。</font></font></trans></span><em><span><trans data-src="abbreviations" data-dst="缩写"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简称</font></font></trans></span></em><span><trans data-src="for logical expressions in the language of the situation calculus. The abbreviation" data-dst="用于逻辑表达式在情境演算语言中的应用。缩写"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于逻辑表达式在情境演算语言中的应用。</font></font></trans></span><em><span><trans data-src="Do" data-dst="做"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="δ,s,s" data-dst="δ，S，S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">δ，S，S</font></font></trans></span></em><span><trans data-src="0)," data-dst="0）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0）</font></font></trans></span><em><span><trans data-src="macroexpands" data-dst="宏扩展"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宏扩展</font></font></trans></span></em><span><trans data-src="into a situation calculus formula that says that it is possible to reach situation" data-dst="转化为一个情境演算公式，表示可能达到的情况"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转化为一个情境演算公式，表示可能达到的情况</font></font></trans></span><em><span><trans data-src="s" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span></span><font style="vertical-align: inherit;"><em><span><font style="vertical-align: inherit;"> δ</font></span></em><span><font style="vertical-align: inherit;">从情境</font></span><span><font style="vertical-align: inherit;"> 0</font></span></font><em><span><trans data-src="s" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="by executing a sequence of actions as specified by" data-dst="通过执行指定的动作序列"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过执行指定的动作序列</font></font></trans></span><em><span></span></em><span><trans data-src=", which is a complex action expression. Golog provides the following macro-expandable language constructs: primitive actions, test actions, sequence, nondeterministic choice of two actions, nondeterministic choice of action arguments and nondeterministic iteration (while loops). Golog also allows for the definition of (possibly recursive) procedures (Reiter, 2001)." data-dst="，这是一个复杂的动作表达式。GOOG提供以下宏可扩展语言构造：原始动作、测试动作、序列、两个动作的非确定性选择、动作参数的非确定性选择和非确定性迭代（while循环）。GOOG还允许（可能递归）过程的定义（ReITER，2001）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是一个复杂的动作表达式。GOOG提供以下宏可扩展语言构造：原始动作，测试动作，序列，两个动作的非确定性选择，动作参数的非确定性选择和非确定性迭代（同时循环）。GOOG还允许（可能递归）过程的定义（ReITER，2001）。</font></font></trans></span></p><p><span><trans data-src="Given a situation calculus-based domain axiomatization" data-dst="给出一种基于态势演算的领域公理化方法"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">称为一种基于态势演算的领域公理化方法</font></font></trans></span><em><span><trans data-src="Axioms" data-dst="公理"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公理</font></font></trans></span></em><span><trans data-src=", an initial situation" data-dst="初步情况"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初步情况</font></font></trans></span><em><span><trans data-src="S" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="0 and a Golog program" data-dst="0和GOOG程序"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0和GOOG程序</font></font></trans></span><em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> δ</font></font></span></em><span><trans data-src=", the planning (i.e. program execution) task can be expressed as the following theorem proving task (Reiter, 2001):" data-dst="，规划（即程序执行）任务可以表示为以下定理证明任务（ReITER，2001）："><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，规划（即程序执行）任务可以表示为以下定理证明任务（ReITER，2001）：</font></font></trans></span></p><p><em><span><trans data-src="Axioms" data-dst="公理"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公理</font></font></trans></span></em><span><trans data-src="` (∃" data-dst="“"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“</font></font></trans></span><em><span><trans data-src="s" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src=")" data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span><em><span><trans data-src="Do" data-dst="做"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="δ,S" data-dst="δ，s"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">δ，秒</font></font></trans></span></em><span><trans data-src="0" data-dst="零"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">零</font></font></trans></span><em><span><trans data-src=",s" data-dst="的S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的S</font></font></trans></span></em><span><trans data-src=")" data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span></p><p><span><trans data-src="In other words, the planner has to identify a situation" data-dst="换句话说，规划师必须识别一种情况。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，规划师必须识别一种情况。</font></font></trans></span><em><span><trans data-src="s" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="for which the macroexpansion is provable from the axioms. The instance of" data-dst="宏公理可从公理证明。实例"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宏公理可从公理证明。实例</font></font></trans></span><em><span><trans data-src="s" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="is obtained as a side effect of the proof, and from this instance a sequence of actions" data-dst="作为证明的副作用而获得，并且从该实例获得动作序列。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为证明的异常而获得，并且从该实例获得动作序列。</font></font></trans></span><em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">〜一个</font></font></span></em><font style="vertical-align: inherit;"><span><font style="vertical-align: inherit;"> | =</font></span><span><font style="vertical-align: inherit;">））成立，其中</font></span><em><span><font style="vertical-align: inherit;">〜一</font></span></em></font><span><trans data-src="can be extracted such that" data-dst="可以提取这样的"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以提取这样的</font></font></trans></span><em><span><trans data-src="Axioms" data-dst="公理"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公理</font></font></trans></span></em><span></span><em><span><trans data-src="Do" data-dst="做"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="δ,S" data-dst="δ，s"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">δ，秒</font></font></trans></span></em><span><trans data-src="0" data-dst="零"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">零</font></font></trans></span><em><span><trans data-src=",do" data-dst="做"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="~a,s" data-dst="a，s"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如</font></font></trans></span></em><span></span><em><span></span></em><span><trans data-src="abbreviates" data-dst="缩写"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简称</font></font></trans></span><em><span><trans data-src="do" data-dst="做"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="an,do" data-dst="安，做"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安，做</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="an" data-dst="安"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安</font></font></trans></span></em><span><trans data-src="−1" data-dst="1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></trans></span><em><span><trans data-src=",...,do" data-dst="，……"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，……</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="a" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src="1" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span><em><span><trans data-src=",S" data-dst="的S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的S</font></font></trans></span></em><span><trans data-src="0))). A Prolog-based implementation of a Golog interpreter is presented in (Levesque et al., 1997)." data-dst="联合国在Levesque等人（1997年）中提出了一个基于Golog Interpreter的序言。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">联合国在Levesque等人（1997年）中提出了一个基于Golog Interpreter的序言。</font></font></trans></span></p><p><span><trans data-src="A variant of Golog capable of dealing with concurrency is ConGolog (Concurrent Golog) (Giacomo et al., 2000): it allows concurrent processes, whereby the concurrency is established by interleaving the atomic actions in the component processes; it also supports interrupts (e.g. to handle the situation when an alarm button is hit in an elevator) and exogenous actions, i.e. actions that may occur in parallel to the program but are not under control of the interpreter. A Prolog-based interpreter for ConGolog is presented in (Giacomo et al., 2000)." data-dst="能够处理并发的GOROG的变体是COOGORG（并发GOOGO）（GIACOMO等人，2000）：它允许并发进程，从而通过在组件进程中交织原子动作来建立并发性；它还支持中断（例如，当在电梯中敲击报警按钮时处理情况）和外生动作，即可能发生在与程序并行但不在解释器控制之下的动作。提出了一种基于PROLoG的COGORGOG解释器（GiAcMo等人，2000）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">能够处理并发的GOROG的变体是COOGORG（并发GOOGO）（GIACOMO等人，2000）：它允许并发进程，从而通过组件进程中交织原子动作来建立并发性；它还支持中断（例如，当在电梯中敲击报警按钮时处理情况）和外生动作，即可能发生在与程序并行但没有解释器控制之下的动作。提出了一种基于PROLoG的COGORGOG解释器（GiAcMo等人，2000）。</font></font></trans></span></p><p><span><trans data-src="In (McIlraith and Son, 2001; McIlraith and Son, 2002) a modified version of ConGolog is applied to the problem of Web Service composition. The ConGolog interpreter is extended with the ability to include customized user constraints, a more flexible variant of Golog’s sequence construct and the ability to implement sensing actions as external function calls. In (Narayanan and McIlraith, 2002), a formal tranformation from OWL-S to situation calculus and Golog is given. In this context, OWL-S processes can serve as specification of desired processes to be carried out as well as a description of the atomic and complex actions offerered by Web services. The Web service composition problem would then be to find an execution of a Golog program that does satisfy the properties defined in the goal." data-dst="在（McIlraith和儿子，2001；McIrrase＆Son，2002），一个修改版本的COGGORG应用于Web服务组合的问题。CONGORGOG解释器被扩展为包括定制用户约束、GOOG序列构造的更灵活变体以及实现感测动作作为外部函数调用的能力。在（纳拉亚南和McILRAITS，2002）中，给出了从OWL-S到态势演算和Golog的形式变换。在这种情况下，OWL-S过程可以作为执行所需过程的规范以及对Web服务所提供的原子和复杂动作的描述。Web服务组合问题将是找到满足目标中定义的属性的GOOG程序的执行。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在（McIlraith和儿子，2001； McIrrase＆Son，2002），一个修改版本的COGGORG解决方案Web服务组合的问题。在（纳拉亚南和McILRAITS，2002）中，指定了从OWL-S到态势演算和Golog的形式变换。在这种情况下，OWL-S过程可以作为执行所需求过程的规范以及对Web服务所提供的原子和复杂动作的描述。Web服务组合问题将是找到满足目标中定义的属性的GOOG程序的执行。</font></font></trans></span></p><h3><a name="5.3---------planning-as-model-checking" class="md-header-anchor"></a><span><trans data-src="5.3         Planning As Model Checking" data-dst="5.3规划作为模型检验"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3规划作为模型检验</font></font></trans></span></h3><p><span><trans data-src="The planning as model checking approach was first proposed in (Cimatti et al., 1997; Giunchiglia and Traverso, 1999), which formulates the planning problem as semantic model checking problem. Model checking is a formal verification technique, which allows to determine whether a property holds in a certain system formalized as a finite state model. This technique is used for the verification of hardware and software systems, to achieve a formal account of the system’s behavior, e.g. that a system does never reach a certain unwanted state (safety), or that it is guaranteed to reach a certain state at some point (liveness). For example, the SPIN model-checker was used to verify the multi-threaded plan execution module in NASA’s DEEP SPACE 1 mission and discovered five previously unknown concurrency errors (Havelund et al., 2001). A more general, detailed discussion of model checking for reasoning over systems can be found in (Halpern and Vardi," data-dst="规划模型检查方法首次提出（CimaTi等人，1997；Giunchiglia和TravSO，1999），制定规划问题作为语义模型检查问题。模型检查是一种形式化的验证技术，它允许确定某一系统中的属性是否被形式化为有限状态模型。该技术用于硬件和软件系统的验证，以实现对系统行为的正式说明，例如系统从不达到某个不想要的状态（安全），或者保证在某个点（活性）达到某一状态。例如，自旋模型检查器被用来验证NASA的深空1任务中的多线程计划执行模块，并发现五个先前未知的并发错误（Havunund等人，2001）。关于系统推理的模型检查更一般、详细的讨论可以在（哈尔彭和VADI）中找到，"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规划模型检查方法首次提出（CimaTi等人，1997； Giunchiglia和TravSO，1999），制定规划问题作为语义模型检查问题。模型检查是一种形式化的验证技术，它允许确定某些系统中的属性是否该技术用于硬件和软件系统的验证，以实现对系统行为的正式说明，例如系统从不达到某个不想要的状态（安全），或者保证在某个点（例如，自旋模型检查器被激活并验证NASA的深空1任务中的多线程计划执行模块，并发现多个先前未知的并发错误（Havunund等人，2001）。系统推理的模型检查更一般，详细的讨论可以在（哈尔彭和VADI）中找到，</font></font></trans></span></p><p><span><trans data-src="1991)." data-dst="1991）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1991）</font></font></trans></span></p><p><span><trans data-src="Planning by model checking (PBM) is semantically well founded and is capable of dealing with nondeterminism, partial observability and extended goals. In PBM, the planning domain is formalized as a nondeterministic state-transition system, where an action is a transition that may bring the system from one state to a set of possible successor states. As in other planning approaches, planning goals may be expressed as constraints about a desired goal state; additionally, goals may be extended by statements about properties about the" data-dst="通过模型检查（PBM）的规划是语义良好的基础，并能够处理非确定性，部分可观测性和扩展目标。在PBM中，规划域被形式化为一个非确定性状态转移系统，其中一个动作是一个过渡，它可以使系统从一个状态变为一组可能的后续状态。正如在其他规划方法中，规划目标可以表示为期望目标状态的约束；此外，目标可以通过关于属性的声明来扩展。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过模型检查（PBM）的规划是语义良好的基础，并能够处理非确定性，部分可观察性和扩展目标。在PBM中，规划域被形式化为一个非确定性状态转移系统，其中一个动作是一个过渡，它可以使系统从一个状态转变成可能的后续状态。何时在其他规划方法中，规划目标可以表示为期望目标状态的约束；从而，目标可以通过关于属性的声明来扩展。</font></font></trans></span><em><span><trans data-src="plan itself" data-dst="计划本身"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计划本身</font></font></trans></span></em><span><trans data-src=", e.g. by CTL (Computation Tree Logic) temporal formulas (Emerson, 1990) or using the recently proposed Eagle (Lago et al., 2002) language." data-dst="，例如通过CTL（计算树逻辑）时间公式（爱默生，1990）或使用最近提出的EAG（LaGo等人，2002）语言。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，例如通过CTL（计算树逻辑）时间公式（爱默生，1990）或使用最近提出的EAG（LaGo等人，2002）语言。</font></font></trans></span></p><p><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PBM方法的基本思想是通过确定目标公式在模型中是否成立来生成计划，从而通常将模型形式化为Kripke结构。</font><font style="vertical-align: inherit;">由PBM生成的计划是“处境计划”（Georgeff和Lansky，1990），是由反应性代理执行的计划，在每个迭代循环中，反应性代理都会确定其所处的状态，然后应用计划为该州预见的行动。</font><font style="vertical-align: inherit;">为了更正式地说明这一点，请考虑一个规划域Σ=（</font></font></span><em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S，A，γ</font></font></span></em><font style="vertical-align: inherit;"><em><span><font style="vertical-align: inherit;"> γ</font></span></em></font><span><trans data-src="), where" data-dst="页：1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">页：1</font></font></trans></span><em><span><trans data-src="S" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="is a finite set of states," data-dst="是一组有限状态，"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一组有限状态，</font></font></trans></span><em><span><trans data-src="A" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src="is a finite set of actions and" data-dst="是一组有限的动作和"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一组有限的动作和</font></font></trans></span><em><span></span></em><span><trans data-src=":" data-dst="："><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font></trans></span><em><span><trans data-src="S" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="×" data-dst="×"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">×</font></font></trans></span><em><span><trans data-src="A" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src="→ 2" data-dst="“2”"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ 2”</font></font></trans></span><em><span><trans data-src="s" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="is the nondeterministic state transition function. Now, a valid PBM-generated plan" data-dst="是非确定性状态转移函数。现在，一个有效的PBM生成计划"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是非确定性状态转移函数。现在，一个有效的PBM生成计划</font></font></trans></span><em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> π</font></font></span></em><font style="vertical-align: inherit;"><span><font style="vertical-align: inherit;">使得（</font></span><em><span><font style="vertical-align: inherit;"> π</font></span></em></font><span><trans data-src=", also called" data-dst="也称为"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也称为</font></font></trans></span><em><span><trans data-src="policy" data-dst="政策"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">政策</font></font></trans></span></em><span><trans data-src="for this planning domain Σ, is a set of pairs (" data-dst="对于这个规划域，是一组对（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于这个规划域，是一组对（</font></font></trans></span><em><span><trans data-src="s,a" data-dst="A，A"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A，A</font></font></trans></span></em><span><trans data-src=") such that" data-dst="这样"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样</font></font></trans></span><em><span><trans data-src="s" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="∈" data-dst="γ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">γ</font></font></trans></span><em><span><trans data-src="S" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="and" data-dst="和"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font></trans></span><em><span><trans data-src="a" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src="∈" data-dst="γ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">γ</font></font></trans></span><em><span><trans data-src="A" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span><trans data-src="(" data-dst="（"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></trans></span><em><span><trans data-src="s" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="). It is required that for any state" data-dst="）需要任何状态"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）需要任何状态</font></font></trans></span><em><span><trans data-src="s" data-dst="S"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></trans></span></em><span><trans data-src="there is (at most) one action" data-dst="（最多）一个动作"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（最多）一个动作</font></font></trans></span><em><span><trans data-src="a" data-dst="一"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></trans></span></em><span></span><em><span><trans data-src="s,a" data-dst="A，A"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A，A</font></font></trans></span></em><span><trans data-src=") ∈" data-dst="）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></trans></span><em><span></span></em><span><trans data-src="." data-dst="."><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></trans></span></p><p><span><trans data-src="Due to the nondeterminism allowed in PBM domains, the definition of a solution differs from the definition of a solution under classical planning assumptions. Depending on the contingency inherent in a solution, it may be either" data-dst="由于PBM域中所允许的不确定性，解决方案的定义不同于经典规划假设下的解决方案的定义。根据解决方案固有的偶然性，它可能是"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于PBM域中所允许的不确定性，解决方案的定义为经典规划假设下的解决方案的定义。根据解决方案固有的偶然性，它可能是</font></font></trans></span><em><span><trans data-src="weak" data-dst="虚弱的"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虚弱的</font></font></trans></span></em><span><trans data-src="," data-dst="，"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></trans></span><em><span><trans data-src="strong" data-dst="坚强的"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">坚强的</font></font></trans></span></em><span><trans data-src="or" data-dst="或"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font></trans></span><em><span><trans data-src="strong cyclic" data-dst="强循环"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">强循环</font></font></trans></span></em><span><trans data-src=": A weak solution is a solution that may achieve the goal but does not guarantee to do so. A strong solution is guaranteed to achieve the goal regardless of the nondeterministic nature of the domain. A strong cyclic solution is one which guarantees to achieve the goal, if" data-dst="一个弱的解决方案是一个可以达到目标但却不能保证做到的解决方案。一个强大的解决方案保证实现的目标，无论域的不确定性性质。强循环解是保证实现目标的一种方法。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个强大的解决方案保证实现的目标，无论域的不确定性性质。强循环解是保证实现目标的一种方法。</font></font></trans></span><em><span><trans data-src="fairness assumptions" data-dst="信念"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信念</font></font></trans></span></em><span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该状态说明了解决方案所预期的循环最终将终止（Giunchiglia and Traverso，1999）。</font></font></span></p><p><span><trans data-src="Analogously, several algorithms have been proposed, capable of either constructing weak (e.g. (Cimatti et al., 1997)), strong (e.g. (Daniele et al., 2000)) or strong cyclic (e.g. (Cimatti et al., 1998)) solutions. These algorithms have in common that they always terminate." data-dst="类似地，已经提出了几种算法，它们能够构造弱的（例如（CimaTi等人，1997））、强的（例如（Daniele等人，2000））或强循环（例如（CimaTi等人，1998））溶液。这些算法有一个共同点，即它们总是终止。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类似地，已经提出了几种算法，它们能够构造弱的（例如（CimaTi等人，1997）），强的（例如（Daniele等人，2000）或强循环（例如（CimaTi等人，1998）） ）溶液。这些算法有一个共同点，即它们总是终止。</font></font></trans></span></p><p><span><trans data-src="Since real-world problems involve models that may contain very large numbers of states, practical implementations of these algorithm usually resort to" data-dst="由于现实世界问题涉及可能包含大量状态的模型，这些算法的实际实现通常诉诸于"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于现实世界问题涉及可能包含大量状态的模型，这些算法的实际实现通常诉诸于</font></font></trans></span><em><span><trans data-src="Symbolic Model Checking" data-dst="符号模型检验"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">符号模型检验</font></font></trans></span></em><span><trans data-src="(Burch et al., 1990). In Symbolic Model Checking the sets of possible states of a Kripke-structure and the transition relations between states are represented" data-dst="（Burh等人，1990）。在符号模型中，检查克里普克结构的可能状态的集合和状态之间的转换关系。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Burh等人，1990）。在符号模型中，检查克里普克结构的可能状态的集合和状态之间的转换关系。</font></font></trans></span><em><span><trans data-src="symbolically" data-dst="象征性地"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">象征性地</font></font></trans></span></em><span><trans data-src=", usually using vectors of variables that represent the truth value of propositions in states, allowing for more concise, less redundant representation of states and for efficient application of set-theoretic and logical operations. Planning is performed by searching through sets of states, rather then individual states, and the plans themselves are represented as formulas. The practical implementation of the representation and the reasoning techniques of Symbolic Model Checking is often carried out using Binary Decision Diagrams (BDDs) (Bryant, 1986)." data-dst="通常使用表示状态中命题的真值的变量向量，从而允许更简洁、更少冗余的状态表示和集合理论和逻辑运算的有效应用。规划是通过搜索状态集，而不是单独的状态来执行的，并且计划本身被表示为公式。符号模型检查的表示和推理技术的实际实现经常使用二元决策图（BDDS）来执行（布莱恩特，1986）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常使用表示状态中命题的真值的变量向量，从而允许更简单，重复冗余的状态表示和集合理论和逻辑运算的有效应用。规划是通过搜索状态集，而不是单独的状态来执行的，符号模型检查的表示和推理技术的实际实现经常使用二元决策图（BDDS）来执行（布莱恩特，1986）。</font></font></trans></span></p><p><span><trans data-src="One implementation of the Planning for Model Checking approach is MIPS (Edelkamp and Helmert, 2000), which is based on BDDs. The main strength of MIPS is its precompilation phase, which identifies implicit domain knowledge, e.g. state invariants, which, when properly encoded can lead to a reduction of the state description length. Further, MIPS implements numerous novel techniques to increase the efficiency of BDD traversal (Edelkamp and Helmert, 2000)." data-dst="模型检查方法的规划的一个实现是MIPS（EdelkAMP和赫尔默特，2000），它是基于BDDS的。MIPS的主要优点是其预编译阶段，它标识隐式领域知识，例如状态不变量，当状态编码时，当正确编码时会导致状态描述长度的减少。此外，MIPS实现了许多新的技术来提高BDD遍历的效率（EdelkAMP和赫尔默特，2000）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模型检查方法的规划的一个实现是MIPS（EdelkAMP和赫尔默特，2000），它是基于BDDS的。MIPS的主要优点是其预编译阶段，它标识隐式领域知识，例如状态不变量，当状态，时，MIPS实现了许多新的技术来提高BDD遍历的效率（EdelkAMP和赫尔默特，2000）。</font></font></trans></span></p><p><span><trans data-src="Other PBM implementations for deterministic domains are Proplan (Fourman, 2000) and BDDPlan (H¨olldobler and St¨orr, 2000); however, these lack a MIPS-like pre-compilation phase and therefore do not reach the high performance of MIPS in larger domains." data-dst="确定性域的其他PBM实现是PROPLAN（FROWMAN，2000）和BDDPLAY（H·OrdodoBER和ST South-ORR，2000）；然而，这些缺少MIPS类的预编译阶段，因此在更大的域中没有达到MIPS的高性能。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定性域的其他PBM实现是PROPLAN（FROWMAN，2000）和BDDPLAY（H·OrdodoBER和ST South-ORR，2000）；而，这些MIPS类的预编译阶段，因此在某些的域中没有达到MIPS的高级。</font></font></trans></span></p><p><span><trans data-src="While MIPS, Proplan and BDDPLan are designed for" data-dst="而MIPS、PROPLAY和BDDPLan则是为"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而MIPS，PROPLAY和BDDPLan则是为</font></font></trans></span><em><span><trans data-src="deterministic" data-dst="确定性的"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定性的</font></font></trans></span></em><span><trans data-src="domains, systems like MBP (Model Based Planner) (Bertoli et al., 2001) and UMOP (Universal Multi-agent Obdd-based Planner) (Jensen and Veloso, 2000) have been designed to leverage a key advantage of model checking, which is to deal with" data-dst="域，系统如MBP（基于模型的规划师）（Btotoi等人，2001）和UMPP（通用多代理OBDD为基础的规划师）（延森和VeloSO，2000）已经被设计为利用模型检查的关键优势，这是要处理的。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">域，系统如MBP（基于模型的规划师）（Btotoi等人，2001）和UMPP（通用多代理OBDD为基础的规划师）（延森和VeloSO，2000）已经被设计为利用模型检查的关键优势，这是要处理的。</font></font></trans></span><em><span><trans data-src="nondeterministic" data-dst="非确定性"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非确定性</font></font></trans></span></em><span><trans data-src="environments: MBP can deal with uncertainty on the initial situation, on the action effects and on the state in which the actions are executed. It uses its own action description language NuPDDL, a variant of PDDL 2.1 which can express uncertainty in the initial state, nondeterministic action effects and non-perfect sensing actions." data-dst="环境：MBP可以处理初始情况下的不确定性、动作效果和执行动作的状态。它使用自己的动作描述语言NUPDDL，PDDL 2.1的变体，它可以表示初始状态的不确定性、不确定性的动作效果和非完美的感知动作。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">环境：MBP可以处理初始情况下的不确定性，动作效果和执行动作的状态。它使用自己的动作描述语言NUPDDL，PDDL 2.1的变体，它可以表示初始状态的不确定性，不确定性的动作效果和非完美的感知动作。</font></font></trans></span></p><p><span><trans data-src="Similarly, UMOP uses its own domain description language NADL (Nondeterministic Agent Domain Language); NADL problem and domain specifications are translated into symbolic Kripke structures, represented by OBDDs (Bryant, 1986)." data-dst="类似地，UMPP使用其自己的域描述语言NADL（非确定性代理域语言）；NADL问题和域规范被翻译成符号克里普克结构，由OBDDs（布莱恩特，1986）表示。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类似地，UMPP使用其自己的域描述语言NADL（非确定性代理域语言）； NADL问题和域规范被翻译成符号克里普克结构，由OBDDs（布莱恩特，1986）表示。</font></font></trans></span></p><h3><a name="5.4---------temporal-planning" class="md-header-anchor"></a><span><trans data-src="5.4         Temporal Planning" data-dst="5.4时间规划"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.4时间规划</font></font></trans></span></h3><p><span><trans data-src="The term “temporal planning” does not necessarily refer to a particular planning technique in the narrow sense, it rather refers to the ability of planners to deal with" data-dst="“时间规划”一词并不一定指狭义上的特定规划技术，而是指规划师应对的能力。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“时间规划”一词并不一定指狭义上的特定规划技术，而是指规划师应对的能力。</font></font></trans></span><em><span><trans data-src="temporal aspects" data-dst="时间方面"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间方面</font></font></trans></span></em><span><trans data-src="of planning domains and problems. Most planning paradigms have been extended in some way to support some temporal aspects of planning. Examples of such temporal aspects are:" data-dst="规划领域和问题。大多数规划范式已经在某种程度上被扩展以支持规划的一些时间方面。这样的时间方面的例子是："><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规划领域和问题。大多数规划范式已经在某种程度上被扩展以支持规划的一些时间方面。这样的时间方面的例子是：</font></font></trans></span></p><p><span><trans data-src="•    Durative actions: In classical planning approaches actions are usually formalized as having no temporal extension. However, in many domains, the duration of actions play a role. As a consequence the exact timing of effects and time efficient plans are of interest to the planner." data-dst="持续行动：在经典的规划方法中，行动通常被形式化为没有时间扩展。然而，在许多领域中，行动的持续时间起着一定的作用。因此，精确的时间和时间效率的计划是计划人员感兴趣的。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">持续行动：在经典的规划方法中，行动通常被形式化为没有时间扩展。然而，在许多领域中，行动的持续时间开始着一定的作用。因此，精确的时间和时间效率的计划是计划人员兴趣的。</font></font></trans></span></p><p><span><trans data-src="•    Validity intervals of propositions: in classical planning, a proposition remains unchanged until it is explicitly changed by the agent using an operator. In the real world, many fluents are dependent on time; for instance the permission to access a Web service may be valid only during a defined temporal interval." data-dst="命题的有效间隔：在经典规划中，一个命题保持不变，直到它被操作员明确地改变。在现实世界中，许多流依赖于时间；例如，访问Web服务的权限可能仅在定义的时间间隔内有效。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命题的有效间隔：在经典规划中，一个命题保持不变，直到它被操作员明确地改变。在现实世界中，许多流依赖于时间；例如，访问Web服务的权限可能仅在定义的时间间隔内有效。</font></font></trans></span></p><p><span><trans data-src="•    Concurrent actions: classical planning usually assumes that only one action is executed at once. POP and its partially ordered plans appear like an exception, but it is not that the temporal concurrency of actions in such plans is deliberatively sought; it just means that these actions are independent and that no constraints excluding their concurrency have been identified. Some problems, however," data-dst="并发动作：经典规划通常假设只有一个动作立即执行。POP及其偏序计划看起来像是一个例外，但并不是故意地计划此类行动中的时间并发性；它只是意味着这些行动是独立的，并且没有识别出它们的并发性的约束。然而，有些问题，"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并发动作：经典规划通常假设只有一个动作立即执行。POP及其偏序计划看起来像是一个例外，但并非偶然地计划此类行动中的时间并发性；它只是意味着这些行动是独立的，并且没有识别出它们的并发性的约束。然而，有些问题，</font></font></trans></span><em><span><trans data-src="require" data-dst="要求"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要求</font></font></trans></span></em><span><trans data-src="that two actions must be executed at the same time because a sequential operation would not yield the desired result." data-dst="这两个动作必须同时执行，因为顺序操作不会产生期望的结果。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这两个动作必须同时执行，因为顺序操作不会产生期望的结果。</font></font></trans></span></p><p><span><trans data-src="•    Specification of temporally extended goals (Bacchus and Kabanza, 1996), which do not only express classical goals of achieving some final state, but also express a set of acceptable" data-dst="•时间延长目标的规范（酒神巴克斯和KabANZA，1996），它不仅表达了实现某些最终状态的经典目标，而且表达了一组可接受的目标。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">•时间延长目标的规范（酒神巴克斯和KabANZA，1996），它既表达了实现某些最终状态的经典目标，又表达了一个替代的目标。</font></font></trans></span><em><span><trans data-src="sequences of states" data-dst="状态序列"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态序列</font></font></trans></span></em><span><trans data-src=". Temporally extended goals may also extend temporal deadlines, safety and maintenance goals (Weld and Etzioni, 1994; Penberthy and Weld, 1992)." data-dst=". 时间延长的目标也可以延长时间期限，安全和维护目标（焊接和EtZoii，1994；彭伯西和焊接，1992）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">时间延长的目标也可以延长时间期限，安全和维护目标（焊接和EtZoii，1994；彭伯西和焊接，1992）。</font></font></trans></span></p><p><span><trans data-src="The problem of" data-dst="问题"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></trans></span><em><span><trans data-src="durative actions" data-dst="持续性行动"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">持续性行动</font></font></trans></span></em><span><trans data-src="was already addressed by early planners such as the partial order planner NONLIN (Tate, 1977) and the hierarchical SIPE (Wilkins, 1988) planner and is also addressed by more recent planners like VHPOP(Younes and Simmons, 2003), LPG (Gerevini and Serina, 2002) and MIPS (Edelkamp and Helmert, 2000)." data-dst="已经由早期规划者解决，如偏序策划NoLin（TATE，1977）和分层SIPE（威尔金斯，1988）规划师，并且也由最近的规划者，如VHPOP（Youes和西蒙斯，2003），LPG（Gerevini和Serina，2002）和MIPS（EdelkAMP和赫尔默特，2000）来解决。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已经由早期规划者解决，如偏序策划NoLin（TATE，1977）和分段SIPE（威尔金斯，1988）规划师，并且也由最近的规划者，如VHPOP（Youes和西蒙斯，2003） ，LPG（Gerevini和Serina，2002）和MIPS（EdelkAMP和赫尔默特，2000）来解决。</font></font></trans></span></p><p><em><span><trans data-src="Temporally extended goals" data-dst="时间扩展目标"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间扩展目标</font></font></trans></span></em><span><trans data-src="have been addressed by the TLPlan (Bacchus and Kabanza, 1995; Bacchus and Ady, 2001) system, which supports goals specified in an extended version of the Metric Interval Temporal Logic (MITL) (Alur et al., 1996). TLPlan is based on a forward-chaining planning engine. Usually, forward-chaining planners (or state-space planners in general) evaluate the contribution a state makes towards the desired goal by determining its heuristic value (cf. Sect. 4.1). TPLan takes a different approach. It treats each state as a database which it checks against an inverse formulation of the goal formula, and it prunes each state that satisfies such a formula, because this means that it violates a property of the desired goal. It should be noted that the notion of a temporally extended goal formula can be extended to the notion of" data-dst="已经解决了TLPLAN（酒神巴克斯和KabANZA，1995；BACCHUS和ADY，2001）系统，它支持在度量区间时态逻辑（MITL）的扩展版本中指定的目标（ALUR等人，1996）。TLPLAN是基于前向链规划引擎的。通常，向前链规划者（或状态空间规划者一般）通过确定其启发式值来评估状态对期望目标的贡献（参见SeCT）。4.1）。TPLan采取了不同的方法。它将每个状态视为一个数据库，它检查目标公式的逆公式，并且修剪每个满足这种公式的状态，因为这意味着它违背了期望目标的属性。应该注意的是，时间扩展的目标公式的概念可以扩展到"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已经解决了TLPLAN（酒神巴克斯和KabANZA，1995； BACCHUS和ADY，2001）系统，它支持在间隔时态逻辑（MITL）的扩展版本中指定的目标（ALUR等人，1996）。基于前向链规划引擎的。通常，向前链规划者（或状态空间规划者一般）通过确定其启发式值来评估状态对期望目标的贡献（见SeCT）。4.1）。TPLan采取了不同的方法。首先，每个状态都考虑到一个数据库，它检查目标公式的逆向公式，以及是否每个满足该公式的状态，因为这意味着它违背了期望目标的属性。应该注意的是，时间扩展的目标公式的概念可以扩展到</font></font></trans></span><em><span><trans data-src="domain control knowledge" data-dst="领域控制知识"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">领域控制知识</font></font></trans></span></em><span><trans data-src=", which encodes hints to the planners by specifying desired or undesired properties of the states it is supposed to identify." data-dst="通过指定希望识别的状态或期望的状态来对规划者进行编码。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过指定希望识别的状态或期望的状态来对规划者进行编码。</font></font></trans></span></p><p><span><trans data-src="A successor of TLPlan is TALPlanner (Kvarnstrom and Haslum, 2001), which is, like TLPlan, based on forward search, but uses the TAL language instead of MITL to specify the planning goals and domain control knowledge. TAL is a narrative-based linear metric time logic used for reasoning about action and change in incompletely specified dynamic environments. A TAL goal (or control) formula is input to TALplanner which then generates a solution that entails the goal (or control) formulas." data-dst="TLPLAN的继承者是TALPlanner（KvnnStrum和Haslum，2001），它类似于TLPLAN，基于前向搜索，但是使用TAL语言代替MITL来指定规划目标和域控制知识。TAL是一种基于叙事的线性度量时间逻辑，用于推理在不完全指定的动态环境中的动作和变化。一个TAL目标（或控制）公式输入到TALplanner，然后生成一个包含目标（或控制）公式的解决方案。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLPLAN的继承者是TALPlanner（KvnnStrum和Haslum，2001），它是TLPLAN，基于前向搜索，但是使用TAL语言替代了MITL来指定规划目标和域控制知识。 ，则用于推理在不完全指定的动态环境中的动作和变化。一个TAL目标（或控制）公式输入到TALplanner，然后生成一个包含目标（或控制）公式的解决方案。</font></font></trans></span></p><h2><a name="6-discussion-and-outlook" class="md-header-anchor"></a><span><trans data-src="6 Discussion and Outlook" data-dst="6讨论与展望"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6讨论与展望</font></font></trans></span></h2><p><span><trans data-src="We will now review the most important requirements we previously discussed and we will contrast them with a selection of state-of-the art planning systems. The core requirements we identified for our problem scenarios (cf. Sect. 2) are:" data-dst="我们现在将回顾我们先前讨论过的最重要的要求，我们将把它们与最先进的规划系统的选择进行对比。我们为我们的问题场景确定的核心要求（参见SeCT）。2）是："><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们现在将回顾我们先前讨论过的最重要的要求，我们将把它们与其最先进的规划系统的选择进行对比。我们为我们的问题场景确定的核心要求（视为SeCT）。2）是：</font></font></trans></span></p><p><span><trans data-src="\1.    The" data-dst="1。这个"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1。这个</font></font></trans></span><em><span><trans data-src="domain complexity" data-dst="领域复杂性"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">领域复杂性</font></font></trans></span></em><span><trans data-src="should support a significant subset of ADL: for instance, universally quantified effects are needed to describe web services that deal with multiple objects (e.g. an operation that removes all items from a virtual shopping cart). Explicit markup of sensing actions and nondeterministic service results is desirable as well." data-dst="应该支持ADL的一个重要子集：例如，需要通用量化的效果来描述处理多个对象的Web服务（例如，从虚拟购物车中移除所有项目的操作）。感测动作和非确定性服务结果的显式标记也是理想的。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该支持ADL的一个重要子集：例如，需要通用量化的效果来描述处理多个对象的Web服务（例如，从虚拟购物车中移除所有项目的操作）。感测动作和非确定性服务结果的显式标记也是理想的。</font></font></trans></span></p><p><span><trans data-src="\2.    Support for" data-dst="2。支持"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2。支持</font></font></trans></span><em><span><trans data-src="complex goals" data-dst="复杂目标"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复杂目标</font></font></trans></span></em><span><trans data-src="(cf. Sect. 3.3), i.e. “hints” that tell the planner which actions should precede which other actions. This is needed for almost all complex problems, for instance in comparison shopping, where the solution is a sequence of three distinct phases (getting price quotes, making a decision, carrying out the purchase)." data-dst="（参见教派）。3.3），即“提示”告诉规划师行动应该先于其他行动。这是几乎所有复杂问题所需要的，例如在比较购物中，解决方案是三个不同阶段的序列（得到价格报价，做出决定，执行购买）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（见教派）。3.3），即“提示”告诉规划师行动应该先于其他行动。这是几乎所有复杂问题所需要的，例如在比较购物中，解决方案是多个不同阶段的序列（得到价格）报价，做出决定，执行购买）。</font></font></trans></span></p><p><span><trans data-src="\3.    As already mentioned, the ability to deal with" data-dst="3。正如已经提到的，处理问题的能力"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3。初步已经提到的，处理问题的能力</font></font></trans></span><em><span><trans data-src="incomplete information" data-dst="不完全信息"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不完全信息</font></font></trans></span></em><span><trans data-src="(cf. Sect. 3.2), for instance to query catalogs in the Web shopping domain, is a core requirement for most Web service domains. This, in turn calls for support of" data-dst="（参见教派）。3.2），例如，查询Web购物领域中的目录，是大多数Web服务域的核心需求。这又需要支持。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（见教派）。3.2），例如，查询Web购物领域中的目录，是大多数Web服务域的核心需求。这又需要支持。</font></font></trans></span><em><span><trans data-src="sensing" data-dst="传感"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传感</font></font></trans></span></em><span><trans data-src="actions which help the agent to acquire the needed data (e.g. a method that returns a list of products an online retailer sells)" data-dst="帮助代理获取所需数据的动作（例如，返回在线零售商销售的产品列表的方法）"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">帮助代理获取所需数据的动作（例如，返回在线零售商销售的产品列表的方法）</font></font></trans></span></p><p><span><trans data-src="\4.    Related to the problem of supporting sensing actions is the ability of planners to" data-dst="4。与支持感知动作有关的问题是规划者的能力。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4。与支持感知动作有关的问题是规划者的能力。</font></font></trans></span><em><span><trans data-src="dynamically add (or remove) objects" data-dst="动态添加（或删除）对象"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动态添加（或删除）对象</font></font></trans></span></em><span><trans data-src="to (or from) the domain, for instance to add knowledge about product information queried from a sensing action, or to properly model a file copy function in the document handling domain." data-dst="（或来自）域，例如，添加关于从感测动作查询的产品信息的知识，或适当地在文档处理域中建模文件复制功能。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（或来自）域，例如，添加关于从感测动作查询的产品信息的知识，或适当地在文档处理域中建模文件复制功能。</font></font></trans></span></p><p><span><trans data-src="\5.    Finally, there is a strong need for dealing with the" data-dst="5。最后，我们非常需要处理这个问题。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5。最后，我们非常需要处理这个问题。</font></font></trans></span><em><span><trans data-src="nondeterministic behavior" data-dst="非确定性行为"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非确定性行为</font></font></trans></span></em><span><trans data-src="of services: Web service operations may fail during execution time or they may yield unexpected or undesired results; for instance, an airline in the traveling domain may suddenly run out of free seats (possibly violated the IRP assumption), or an image conversion operation in the e-mail replication scenario may fail." data-dst="服务：Web服务操作可能在执行期间失败，或者它们可能产生意想不到的或不期望的结果；例如，旅行领域中的航空公司可能突然耗尽空闲座位（可能违反了IRP假设），或者电子邮件复制方案中的图像转换操作可能失败。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务：Web服务操作可能在执行期间失败，或者它们可能产生意想不到的或不期望的结果；例如，旅行领域中的位置可能突然替换位置（可能违反了IRP假设），或者电子邮件复制方案中的图像转换操作可能失败。</font></font></trans></span><span></span></p><p><span><trans data-src="In the Tables 1 and 2 we contrast a collection of representative planner implementations against our collection of core requirements for WSC problems. The planners listed in Tab. 1 are neoclassical[" data-dst="在表1和表2中，我们对比了具有代表性的规划者实现的集合与WSC问题的核心需求的集合。规划者列出在选项卡中。1是新古典主义。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在表1和表2中，我们对比了具有公认的规划者实现的集合与WSC问题的核心需求的集合。规划者列出在选项卡中。1是新古典主义。</font></font></trans></span><a href="https://ziyanliupb.github.io/#"><span><trans data-src="7" data-dst="七"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">七</font></font></trans></span><span><trans data-src="]" data-dst="]"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]</font></font></trans></span></a><span><trans data-src="planners based on the techniques we discussed in Sect. 4, and the tools listed in Tab. 2 are implementations of the planning with control knowledge approach discussed in Sect. 5." data-dst="规划师基于我们所讨论的技术。4，以及在选项卡中列出的工具。2是在SCT中讨论的具有控制知识的计划的实现。5。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规划师基于我们所讨论的技术。4，以及在选项卡中列出的工具。2是在SCT中讨论的具有控制知识的计划的实现。5。</font></font></trans></span></p><p><span><trans data-src="Table 1 shows that most of the neoclassical planners we listed allow for domain descriptions of the necessary complexity, i.e. a significant subset of ADL. However, with the exception of SGP, which provides support for incomplete initial states and sensing operations, the rest of the WSC requirements is not supported by any of these planners." data-dst="表1显示，我们列出的大多数新古典规划者允许必要复杂性的域描述，即ADL的一个重要子集。然而，除了SGP之外，SGP为不完整的初始状态和感测操作提供支持，这些规划者中的任何一个都不支持WSC的其他要求。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表1显示，我们列出的大多数新古典规划者允许必要的复杂性的域描述，即ADL的一个重要子集。然而，除了SGP之外，SGP为不完整的初始状态和感测操作提供支持，这些规划者中的任何一个都不支持WSC的其他要求。</font></font></trans></span></p><p><span><trans data-src="On the other hand, the planners using domain control knowledge offer a much broader support for our requirements: They support complex domains and they allow complex goals as well. For instance, MBP allows to define temporally extended goals and Golog represent goals in a program-like fashion, including branching and iteration. Consequently, nondeterministic domains can be addressed by providing contingency-handling code (e.g. nondeterministic iteration which forces the planner to continue a loop unit the desired effect of some operation is achieved)." data-dst="另一方面，使用领域控制知识的规划者为我们的需求提供了更广泛的支持：他们支持复杂的领域，他们也允许复杂的目标。例如，MBP允许定义在时间上扩展的目标，GOOGO表示在一个程序中的目标，如分支和迭代。因此，不确定性域可以通过提供权变处理代码来解决（例如，非确定性迭代，这迫使策划者继续循环单元，实现了某些操作的期望效果）。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，MBP允许定义在时间上扩展的目标，GOOGO表示在，同时，使用领域控制知识的规划者为我们的需求提供了更多广泛的支持：他们支持复杂的领域，他们也可以提供复杂的目标。一个程序中的目标，如分支和迭代。因此，不确定性域可以通过提供权变处理代码来解决（例如，非确定性互换，这意味着策划者继续循环单元，实现了某些操作的期望效果） 。</font></font></trans></span></p><p><span><trans data-src="Does this mean that the WSC problem is already solved by planners with control knowledge and that neoclassical planners can not be used for the task?" data-dst="这是否意味着WSC问题已经由有控制知识的规划者解决，而新古典规划者不能被用于这个任务？"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是否意味着WSC问题已经由有控制知识的规划者解决，而新古典规划者不能被用作此任务？</font></font></trans></span></p><p><span><trans data-src="We think this is not the case: While it is apparent that domain knowledge is a key to solving the WSC problem, it is not clear" data-dst="我们认为情况并非如此：尽管很明显，领域知识是解决WSC问题的关键，但目前还不清楚。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们认为情况并非如此：尽管很明显，领域知识是解决WSC问题的关键，但目前还不清楚。</font></font></trans></span><em><span><trans data-src="which" data-dst="哪一个"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哪一个</font></font></trans></span></em><span><trans data-src="form of domain knowledge is best suited and" data-dst="领域知识的形式最适合"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">领域知识的形式最适合</font></font></trans></span><em><span><trans data-src="how" data-dst="怎样"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">怎样</font></font></trans></span></em><span><trans data-src="it should be gathered and encoded. Here, “soft requirements” like the acceptance of the targeted developer communities are relevant as well. The idea of transforming pre-existing process descriptions (in OWL-S) to domain control information (HTN methods) as exercised by (Hendler et al., 2003) seems a reasonable approach: it does not require the developers to adopt a new logic-based language, but allows them to use wide spread process engineering skills. However, (Hendler et al., 2003) use a restricted variant of HTN planning, i.e. ordered task decomposition planning, which does not support declarative goal tasks. This means that the agent solely depends on the task lists it is given and that is does not attempt to find “creative” solutions on its own. Similarly, sensing actions are not called because the" data-dst="它应该被收集和编码。在这里，“软需求”，如接受目标开发商社区也是相关的。将预先存在的过程描述（OWL-S）转换为域控制信息（HTN方法）的想法（如Hendler等人，2003）似乎是一种合理的方法：它不要求开发人员采用一种新的基于逻辑的语言，而是允许它们使用广泛的过程工程技能。然而，（Hendler等人，2003）使用受限的HTN规划变型，即有序任务分解规划，它不支持声明性目标任务。这意味着，代理只依赖于它所给出的任务列表，而不是试图自己找到“创造性”的解决方案。类似地，不调用感测动作，因为"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它应该被收集和编码。在这里，“软需求”，如接受目标开发商社区也是相关的。将预先存在的过程描述（OWL-S）转换为域控制信息（HTN方法）的想法（如Hendler）等人，2003）似乎是一种合理的方法：它不要求开发人员采用一种新的基于逻辑的语言，而是允许其使用广泛的过程工程技能。然而，（Hendler等人，2003）使用受限制的HTN规划变型，即有序任务分解规划，它不支持声明性目标任务。这意味着，代理只依赖于它所引发的任务列表，而不是试图自己找到“创造”的解决方案。类似地，不调用感测动作，因为</font></font></trans></span><em><span><trans data-src="agent" data-dst="代理"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代理</font></font></trans></span></em><span><trans data-src="identifies the need for sensing; instead the sensing action is explicitly predefined in the task list. While this is a useful and pragmatic approach for many domains, we think it would still be interesting to look for alternative approaches that allow for more flexibility on the agent’s part, for instance to deal with situations where no predefined strategies exist yet." data-dst="标识感测的需要；相反，在任务列表中显式预定义感测动作。虽然这是一个有用的和务实的方法，许多领域，我们认为它仍然是有趣的寻找替代方法，使更多的灵活性，在代理的一部分，例如，处理的情况下，没有预先定义的策略还存在。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标识这是一个有用的和务实的方法，很多领域，我们认为它仍然是有趣的寻找替代方法，使更多的灵活性，在代理的一部分，例如，处理的情况下，没有预先定义的策略还存在。</font></font></trans></span></p><p><span><trans data-src="Furthermore, the domain-independent neoclassical planners of Tab. 1 are far from being inapplicable to the WSC problem. What is required, however, is a proper architecture that allows for the decomposition of the planning problem into a set of subproblems that match the capabilities of the neoclassical planners." data-dst="此外，领域无关的新古典规划师选项卡。1的问题远不能适用于WSC问题。然而，所需要的是一个适当的体系结构，它允许将规划问题分解成与新古典规划者的能力相匹配的一个子问题。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，领域无关的新古典规划师选项卡。1的问题远不能适用于WSC问题。然而，所需要的是一个适当的体系结构，它允许将规划问题分解成与新古典规划者的能力相匹配的一个子问题。</font></font></trans></span></p><p><span><trans data-src="An example would be an execution monitoring &amp; replanning architecture (e.g. (Haigh, 1998)), where a controller component transforms the problem into a sequence of simpler planning problems and uses the feedback from plan execution to better inform the heuristics of the embedded planner(s). Since the planning problem is split up into a sequence of planning problems, the problem of dynamic object creation and destruction disappears (because the world is re-created at each step) and even the planning for sensing actions becomes possible for classical planners, as informally described in (Peer, 2004a)." data-dst="一个例子是执行监控和重新规划体系结构（例如（HAHY，1998）），其中控制器组件将问题转化为一系列简单的规划问题，并使用来自计划执行的反馈来更好地告知嵌入式规划人员的启发式。由于规划问题被分解成一系列的规划问题，动态对象创建和销毁的问题消失（因为世界在每个步骤中被重新创建），甚至对于感知规划者的规划也成为可能的（如同行，2004年A）非正式描述的规划师。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个例子是执行监控和重新规划体系结构（例如（HAHY，1998）），其中控制器组件将问题转化为一系列简单的规划问题，并使用来自计划执行的反馈来更好地告知嵌入式规划人员的启发式。由于规划问题被分解成一系列的规划问题，动态对象创建和销毁的问题消失（因为世界在每个步骤中被重新创建），甚至对于感知规划者的规划也成为可能的（如同行，2004年A）非正式描述的规划师。</font></font></trans></span></p><p><span><trans data-src="Finally, there is a number of unaddressed issues, which, once solved, may turn out to be very helpful regardless of the planning approach taken. One central issue is" data-dst="最后，有许多未解决的问题，一旦解决了问题，无论规划方法如何，都可能是非常有帮助的。一个中心问题是"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，有很多未解决的问题，一旦解决了问题，无论规划方法如何，都可能是非常有帮助的。一个中心问题是</font></font></trans></span><em><span><trans data-src="automatic domain analysis" data-dst="自动领域分析"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自动领域分析</font></font></trans></span></em><span><trans data-src="; in this survey we discussed several planning implementations which outperformed their direct competition because of" data-dst="在本次调查中，我们讨论了几个计划实现，其表现优于他们的直接竞争，因为"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本次调查中，我们讨论了几个计划实现，其表现令人满意他们的直接竞争，因为</font></font></trans></span><em><span><trans data-src="automatically generated" data-dst="自动生成"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自动生成</font></font></trans></span></em><span><trans data-src="domain knowledge gathered during a preprocessing phase (e.g. STAN, MIPS). Therefore, it appears to be a worthwhile undertaking to identify ways of gathering useful control knowledge from Web service domains. Similarly, the application of" data-dst="在预处理阶段收集的领域知识（例如STAN、MIPS）。因此，从Web服务域中收集有用的控制知识似乎是值得的。同样，应用"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，从Web服务域中收集有用的控制知识似乎是值得的。同样，应用在预先阶段收集的领域知识（例如STAN，MIPS）。</font></font></trans></span><em><span><trans data-src="learning techniques" data-dst="学习技巧"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学习技巧</font></font></trans></span></em><span><trans data-src="(e.g. based on feedback from earlier runs) may be considered to improve the agent’s planning heuristics." data-dst="（例如，基于早期运行的反馈）可以被认为是改进代理的计划启发。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（例如，基于早期运行的反馈）可以被认为是改进代理的计划启发。</font></font></trans></span></p><p><strong><span><trans data-src="Acknowledgements" data-dst="致谢"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">致谢</font></font></trans></span></strong></p><p><span><trans data-src="This work has been supported by the European Commission and by the Swiss Federal Office for Education and Science within the 6th Framework Programme project REWERSE number 506779 and by the Swiss National Science Foundation under contract 200021-104009. The author would like to thank Juergen Zimmer, Drew McDermott and Maja Vukovic for their comments and valuable feedback." data-dst="这项工作得到了欧洲委员会和瑞士联邦教育和科学办公室在第六框架计划项目ReWiSE 506779和瑞士国家科学基金会2000年1月1日至10400年的支持。作者要感谢Juergen Zimmer、Drew McDermott和Maja Vukovic的评论和宝贵的反馈。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初工作得到了欧洲委员会和瑞士联邦教育和科学办公室在第六框架计划项目ReWiSE 506779和瑞士国家科学基金会2000年1月1日至10400年的支持。 Vukovic的评论和宝贵的反馈。</font></font></trans></span></p><p><span></span></p></div><div id="goog-gt-tt" class="skiptranslate" dir="ltr"><div style="padding: 8px;"><div><div class="logo"><img src="file:///E:/GitHub/ziyanliupb.github.io/web_files/translate_24dp.png" width="20" height="20" alt="Google 翻译"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray"><trans data-src="原文" data-dst=" original text"> original text</trans></h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link"><trans data-src="提供更好的翻译建议" data-dst=" Providing better translation suggestions"> Providing better translation suggestions</trans></span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div><div style="position: static; display: none; width: 0px; height: 0px; border: none; padding: 0px; margin: 0px;"><div id="trans-tooltip" style="visibility: hidden; left: 463.5px; top: 1985px;"><div id="tip-left-top" style="background: url(&quot;chrome-extension://edhchknefojhifoiebpcbkhcjlkkklci/imgs/map/tip-left-top.png&quot;);"></div><div id="tip-top" style="background: url(&quot;chrome-extension://edhchknefojhifoiebpcbkhcjlkkklci/imgs/map/tip-top.png&quot;) repeat-x; width: 282px;"></div><div id="tip-right-top" style="background: url(&quot;chrome-extension://edhchknefojhifoiebpcbkhcjlkkklci/imgs/map/tip-right-top.png&quot;);"></div><div id="tip-right" style="background: url(&quot;chrome-extension://edhchknefojhifoiebpcbkhcjlkkklci/imgs/map/tip-right.png&quot;) repeat-y; height: 142px;"></div><div id="tip-right-bottom" style="background: url(&quot;chrome-extension://edhchknefojhifoiebpcbkhcjlkkklci/imgs/map/tip-right-bottom.png&quot;);"></div><div id="tip-bottom" style="background: url(&quot;chrome-extension://edhchknefojhifoiebpcbkhcjlkkklci/imgs/map/tip-bottom.png&quot;) repeat-x; width: 275px;"></div><div id="tip-left-bottom" style="background: url(&quot;chrome-extension://edhchknefojhifoiebpcbkhcjlkkklci/imgs/map/tip-left-bottom.png&quot;);"></div><div id="tip-left" style="background: url(&quot;chrome-extension://edhchknefojhifoiebpcbkhcjlkkklci/imgs/map/tip-left.png&quot;); height: 149px;"></div><div id="trans-content"><div><div style="padding:13px 13px;width: 266px;"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">译文：</font></font></p><div style="width:250px;white-space:normal;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决此限制的一种方法是在服务器中写下服务的语义的足够大的部分。</font></font></div><div><img src="chrome-extension://edhchknefojhifoiebpcbkhcjlkkklci/imgs/map/logo.png" style="height:22px;margin-top:12px;"><a href="https://ziyanliupb.github.io/#" id="check_in_fanyi_baidu_com_20" style="float:right;margin-top:21px;margin-right:-10px;text-decoration: none;color: #0066ff;letter-spacing:1px;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到百度翻译中打开〉</font></font></a></div></div></div></div></div><div id="tip-arrow-bottom" style="background: url(&quot;chrome-extension://edhchknefojhifoiebpcbkhcjlkkklci/imgs/map/tip-arrow-bottom.png&quot;); visibility: hidden;"></div><div id="tip-arrow-top" style="background: url(&quot;chrome-extension://edhchknefojhifoiebpcbkhcjlkkklci/imgs/map/tip-arrow-top.png&quot;); visibility: hidden; left: 596.5px; top: 1975px;"></div></div><div class="goog-te-spinner-pos" style="top: 36px;"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>